{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GUILDA Documentation \u00b6 This is the official documentation of GUILDA. Contents: Description. Mathematical Model of GUILDA. GUILDA Setup. Power System Model (simple). Guided Example. GUILDA in Detail. Source Code Explanation. Operation using User Interface (UI). Description \u00b6 GUILDA stands for Grid & Utility Infrastructure Linkage Dynamics Analyzer. It is a numerical simulation platform for smart energy management. The purpose of this program is to provide students and researchers in the field of systems and control engineering with an advanced numerical simulation environment that can be used with minimal knowledge of power systems. To achieve this, it is recommended to use this program in closeness with the textbook \"Power Systems Control Engineering: Systems Theory and MATLAB Simulation\" (only available in its original language, Japanese. The English translation is currently being developed). In this textbook the authors explain the structure and mathematical fundamentals of power systems in the language of systems and control engineering. We are devising a way for students to learn the mathematical fundamentals and the construction of a numerical simulation environment in parallel. Through these activities, we aim to establish power systems as one of the familiar benchmark models in the field of systems and control, thereby helping to promote power system reform through the technologies and knowledge in this field. This is an in-development project by the Ishizaki Laboratory at Tokyo Institute of Technology and Assistant Professor Kawaguchi of Gunma University. To learn more visit here . Mathematical Model of GUILDA \u00b6 The mathematical models used in GUILDA are in line with the contents of the textbook \"Power Systems Control Engineering: Systems Theory and MATLAB Simulation\" . The detailed mathematical models and formulas for the state-space model are also introduced in different sections of this documentation, but if you want a systematic understanding, please refer to the textbook. GUILDA Setup \u00b6 This section explains how to download the public source code and set up the environment (Click on the illustration \u2193). Power System Model (Simple) \u00b6 The following is a brief description of the power system model configuration (Click on the illustration \u2193). Guided Example \u00b6 This section provides a guided example in which the most important functionalities of GUILDA are shown: Define a Power System, Simulate the System's Response, Add a Controller, Simulate the System's Response with a Controller. If you are new to GUILDA, please refer to this page to get an idea of the overall flow of the simulator. The three busbar system introduced in the text is used as the analysis target, and the model is implemented on this simulator to actually run the simulation and see the response (Click on the illustration \u2193). GUILDA in Detail \u00b6 This section explains each step in the process of implementing a model and performing an analysis. Specifically, it explains: how to use the methods for performing the analysis, how to define a new component, how to define a new controller (Click on the Illustration \u2193). Source Code Explanation \u00b6 This section explains the functions, properties, methods, classes, etc. useed in the source code of GUILDA (Click on the Illustration \u2193). Operation Using User Interface (UI) \u00b6 Not available - Under Development. This section explains how to use GUILDA with the User Interface (UI) (Click on the Illustration \u2193).","title":"Home"},{"location":"#guilda_documentation","text":"This is the official documentation of GUILDA. Contents: Description. Mathematical Model of GUILDA. GUILDA Setup. Power System Model (simple). Guided Example. GUILDA in Detail. Source Code Explanation. Operation using User Interface (UI).","title":"GUILDA Documentation"},{"location":"#description","text":"GUILDA stands for Grid & Utility Infrastructure Linkage Dynamics Analyzer. It is a numerical simulation platform for smart energy management. The purpose of this program is to provide students and researchers in the field of systems and control engineering with an advanced numerical simulation environment that can be used with minimal knowledge of power systems. To achieve this, it is recommended to use this program in closeness with the textbook \"Power Systems Control Engineering: Systems Theory and MATLAB Simulation\" (only available in its original language, Japanese. The English translation is currently being developed). In this textbook the authors explain the structure and mathematical fundamentals of power systems in the language of systems and control engineering. We are devising a way for students to learn the mathematical fundamentals and the construction of a numerical simulation environment in parallel. Through these activities, we aim to establish power systems as one of the familiar benchmark models in the field of systems and control, thereby helping to promote power system reform through the technologies and knowledge in this field. This is an in-development project by the Ishizaki Laboratory at Tokyo Institute of Technology and Assistant Professor Kawaguchi of Gunma University. To learn more visit here .","title":"Description"},{"location":"#mathematical_model_of_guilda","text":"The mathematical models used in GUILDA are in line with the contents of the textbook \"Power Systems Control Engineering: Systems Theory and MATLAB Simulation\" . The detailed mathematical models and formulas for the state-space model are also introduced in different sections of this documentation, but if you want a systematic understanding, please refer to the textbook.","title":"Mathematical Model of GUILDA"},{"location":"#guilda_setup","text":"This section explains how to download the public source code and set up the environment (Click on the illustration \u2193).","title":"GUILDA Setup"},{"location":"#power_system_model_simple","text":"The following is a brief description of the power system model configuration (Click on the illustration \u2193).","title":"Power System Model (Simple)"},{"location":"#guided_example","text":"This section provides a guided example in which the most important functionalities of GUILDA are shown: Define a Power System, Simulate the System's Response, Add a Controller, Simulate the System's Response with a Controller. If you are new to GUILDA, please refer to this page to get an idea of the overall flow of the simulator. The three busbar system introduced in the text is used as the analysis target, and the model is implemented on this simulator to actually run the simulation and see the response (Click on the illustration \u2193).","title":"Guided Example"},{"location":"#guilda_in_detail","text":"This section explains each step in the process of implementing a model and performing an analysis. Specifically, it explains: how to use the methods for performing the analysis, how to define a new component, how to define a new controller (Click on the Illustration \u2193).","title":"GUILDA in Detail"},{"location":"#source_code_explanation","text":"This section explains the functions, properties, methods, classes, etc. useed in the source code of GUILDA (Click on the Illustration \u2193).","title":"Source Code Explanation"},{"location":"#operation_using_user_interface_ui","text":"Not available - Under Development. This section explains how to use GUILDA with the User Interface (UI) (Click on the Illustration \u2193).","title":"Operation Using User Interface (UI)"},{"location":"index_python/","text":"GUILDA Python Documentation \u00b6 This is the official documentation of GUILDA. \u3010Description\u3011 \u00b6 GUILDA Python is the Python version of the original MATLAB based program GUILDA . While both programs are ment to be equivalent versions of each other, GUILDA is developed in MATLAB and documented in Japanese, while GUILDA Python is developed in Python and documented in English. GUILDA stands for Grid & Utility Infrastructure Linkage Dynamics Analyzer. GUILDA is a numerical simulator platform for smart energy management. The purpose of this program is to provide students and researchers in the field of systems and control engineering with an advanced numerical simulation environment that can be used with minimal knowledge of power systems. To achieve this, it is recommended to use this program in closeness with the textbook \"Power Systems Control Engineering: Systems Theory and MATLAB Simulation\" (only available in its original language, Japanese. The English translation is currently being developed). As in this textbook the authors explain the structure and mathematical fundamentals of power systems in the language of systems and control engineering. We are devising a way for students to learn the mathematical fundamentals and the construction of a numerical simulation environment in parallel. Through these activities, we aim to establish power systems as one of the familiar benchmark models in the field of systems and control, thereby helping to promote power system reform through the technologies and knowledge in this field. This is an in-development project by the Ishizaki Laboratory at Tokyo Institute of Technology and Assistant Professor Kawaguchi of Gunma University. To learn more visit here . \u3010Mathematical Model of GUILDA\u3011 \u00b6 The mathematical models used in GUILDA are in line with the contents of the textbook mentioned above, and the series of execution processes necessary for analysis are organized as procedures based on the theory introduced here. The rough structure of an electric power system is also introduced in the following page [What does an electric power system consist of? Please also refer to the following page for a rough explanation of the composition of the power system. Detailed mathematical models and formulas for state-space models are also introduced here and there, but if you want a systematic understanding, please refer to the textbook. \u3010Power System Configuration\u3011 \u00b6 The following is a brief description of the power system configuration. ( Click on the Illustration \u2193 ) \u3010GUILDA Set up\u3011 \u00b6 This section explains how to download the public source code and set up the environment. ( Click on the Illustration\u2193 ) \u3010A Series of Examples: Analysis using a Simple Model\u3011 \u00b6 The three busbar system introduced in the text is used as the analysis target, and the model is implemented on this simulator to actually run the simulation and see the response. The flow from definition to analysis is designed to be a single story. If you are new to GUILDA, please refer to this page to get an idea of the overall flow. ( Click on the Illustration \u2193 ) \u3010Reference\u3011 \u00b6 Each step in the process of implementing a model and performing an analysis will be explained. Specifically, we will explain how to use the methods used to perform the analysis and how to define a new device/controller model as a class. (Click on the Illustration \u2193) \u3010Explanation of Source Code\u3011 \u00b6 (Click on the Illustration \u2193) \u3010Operation Using UI\u3011 \u00b6 (Click on the Illustration \u2193) \u3010Requirements\u3011 \u00b6 Toolboxes necessary to run this simulator: Optimizaiton Toolbox. Control System Toolbox. Robus Control Toolbox.","title":"<div style=\"text-align: center;\"><span style=\"font-size: 130%; color: black;\">GUILDA Python Documentation</span></div>"},{"location":"index_python/#guilda_python_documentation","text":"This is the official documentation of GUILDA.","title":"GUILDA Python Documentation"},{"location":"index_python/#description","text":"GUILDA Python is the Python version of the original MATLAB based program GUILDA . While both programs are ment to be equivalent versions of each other, GUILDA is developed in MATLAB and documented in Japanese, while GUILDA Python is developed in Python and documented in English. GUILDA stands for Grid & Utility Infrastructure Linkage Dynamics Analyzer. GUILDA is a numerical simulator platform for smart energy management. The purpose of this program is to provide students and researchers in the field of systems and control engineering with an advanced numerical simulation environment that can be used with minimal knowledge of power systems. To achieve this, it is recommended to use this program in closeness with the textbook \"Power Systems Control Engineering: Systems Theory and MATLAB Simulation\" (only available in its original language, Japanese. The English translation is currently being developed). As in this textbook the authors explain the structure and mathematical fundamentals of power systems in the language of systems and control engineering. We are devising a way for students to learn the mathematical fundamentals and the construction of a numerical simulation environment in parallel. Through these activities, we aim to establish power systems as one of the familiar benchmark models in the field of systems and control, thereby helping to promote power system reform through the technologies and knowledge in this field. This is an in-development project by the Ishizaki Laboratory at Tokyo Institute of Technology and Assistant Professor Kawaguchi of Gunma University. To learn more visit here .","title":"\u3010Description\u3011"},{"location":"index_python/#mathematical_model_of_guilda","text":"The mathematical models used in GUILDA are in line with the contents of the textbook mentioned above, and the series of execution processes necessary for analysis are organized as procedures based on the theory introduced here. The rough structure of an electric power system is also introduced in the following page [What does an electric power system consist of? Please also refer to the following page for a rough explanation of the composition of the power system. Detailed mathematical models and formulas for state-space models are also introduced here and there, but if you want a systematic understanding, please refer to the textbook.","title":"\u3010Mathematical Model of GUILDA\u3011"},{"location":"index_python/#power_system_configuration","text":"The following is a brief description of the power system configuration. ( Click on the Illustration \u2193 )","title":"\u3010Power System Configuration\u3011"},{"location":"index_python/#guilda_set_up","text":"This section explains how to download the public source code and set up the environment. ( Click on the Illustration\u2193 )","title":"\u3010GUILDA Set up\u3011"},{"location":"index_python/#a_series_of_examples_analysis_using_a_simple_model","text":"The three busbar system introduced in the text is used as the analysis target, and the model is implemented on this simulator to actually run the simulation and see the response. The flow from definition to analysis is designed to be a single story. If you are new to GUILDA, please refer to this page to get an idea of the overall flow. ( Click on the Illustration \u2193 )","title":"\u3010A Series of Examples: Analysis using a Simple Model\u3011"},{"location":"index_python/#reference","text":"Each step in the process of implementing a model and performing an analysis will be explained. Specifically, we will explain how to use the methods used to perform the analysis and how to define a new device/controller model as a class. (Click on the Illustration \u2193)","title":"\u3010Reference\u3011"},{"location":"index_python/#explanation_of_source_code","text":"(Click on the Illustration \u2193)","title":"\u3010Explanation of Source Code\u3011"},{"location":"index_python/#operation_using_ui","text":"(Click on the Illustration \u2193)","title":"\u3010Operation Using UI\u3011"},{"location":"index_python/#requirements","text":"Toolboxes necessary to run this simulator: Optimizaiton Toolbox. Control System Toolbox. Robus Control Toolbox.","title":"\u3010Requirements\u3011"},{"location":"Reference/0TopPage/","text":"GUILDA in Detail \u00b6 In this page a detailed description of the three main functions of GUILDA is provided. Contents: Power System Model (Detailed). Controllers. Numerical Simulations. Simulating Derivation of a Linearized Model These are depicted in the following image. Power System Model (Detailed) \u00b6 This section provides a detailed explanation on the power system models that can be used in GUILDA. In GUILDA there predefined power system models are already included (i.e., 3-bus and 68-bus models). However, it is possible to define and implement different models and run simulations on them. To use the predifed power system models use the following codes. %Predefined Power System Models. net = network_sample3bus ; %Load the predefined 3-bus system model. net = network_IEEE68bus ; %Load the predefined 68-bus system model. To define and implement a new power system model plese refer to the next explanation page (Click on the illustration \u2193). Controllers \u00b6 This section explains the most relevant information of the controller class. For example, the controller types, how to define a new controller, how to implement it, its functional requirements, etc. (Click on the illustration \u2193). Numerical Simulations \u00b6 This section explains how to perform numerical simulations with the selected power system model (predifined or newly defined, with or without controllers, etc.). Simulating \u00b6 This section explains how to perform the simulations. It explains how to set the simulation conditions and how to read the results (Click on the illustration \u2193). Derivation of a Linearized Model \u00b6 This section describes the derivation of the approximate linearized model of the created power system model (Click on the illustration \u2193).","title":"Guilda in Detail"},{"location":"Reference/0TopPage/#guilda_in_detail","text":"In this page a detailed description of the three main functions of GUILDA is provided. Contents: Power System Model (Detailed). Controllers. Numerical Simulations. Simulating Derivation of a Linearized Model These are depicted in the following image.","title":"GUILDA in Detail"},{"location":"Reference/0TopPage/#power_system_model_detailed","text":"This section provides a detailed explanation on the power system models that can be used in GUILDA. In GUILDA there predefined power system models are already included (i.e., 3-bus and 68-bus models). However, it is possible to define and implement different models and run simulations on them. To use the predifed power system models use the following codes. %Predefined Power System Models. net = network_sample3bus ; %Load the predefined 3-bus system model. net = network_IEEE68bus ; %Load the predefined 68-bus system model. To define and implement a new power system model plese refer to the next explanation page (Click on the illustration \u2193).","title":"Power System Model (Detailed)"},{"location":"Reference/0TopPage/#controllers","text":"This section explains the most relevant information of the controller class. For example, the controller types, how to define a new controller, how to implement it, its functional requirements, etc. (Click on the illustration \u2193).","title":"Controllers"},{"location":"Reference/0TopPage/#numerical_simulations","text":"This section explains how to perform numerical simulations with the selected power system model (predifined or newly defined, with or without controllers, etc.).","title":"Numerical Simulations"},{"location":"Reference/0TopPage/#simulating","text":"This section explains how to perform the simulations. It explains how to set the simulation conditions and how to read the results (Click on the illustration \u2193).","title":"Simulating"},{"location":"Reference/0TopPage/#derivation_of_a_linearized_model","text":"This section describes the derivation of the approximate linearized model of the created power system model (Click on the illustration \u2193).","title":"Derivation of a Linearized Model"},{"location":"Reference/Analysis/SampleCode/","text":"Simulation - Examples \u00b6 This page contains examples of handling the simulating function and examining its response under various settings. Contents: Example 1 - Initial Value Response. Example 2 - Disturbance Response. Example 3 - Input Response. Example 4 - Combination Response. Simulation Results Example 1 - Initial Value Response \u00b6 Scenario: IEEE 68-bus model. Simulation time: 0 - 20 seconds. Simulation conditions: Initial value of frequency deviation \\(\\small (\\Delta \\omega)\\) (second state) of the generator connected to busbar 3 is deviated by 0.01 from the equilibrium point. The second state of the generator connected to busbar 3 corresponds to the 16th state of the entire system. Remember that the state of the entire system is a vector composed of the states of all components (in the busbar ascending order). And since in the IEEE 68-bus model, the generators have 7 states each, the second state of the third generator is the 16th state of the entire system. In cases where the number of internal states per components isn't known, the method get_nx can be used. %Network Definition net = network_IEEE68bus (); %Define options for simulation option = struct (); option . x0_sys = net . x_equilibrium ; option . x0_sys ( 16 )= option . x0_sys ( 16 ) + 0.01 ; %Running the simulation out = net . simulate ([ 0 20 ], option ); Alternatively (without stating option as a structure). net = network_IEEE68bus (); x0 = net . x_equilibrium ; x0 ( 16 )= x0 ( 16 ) + 0.01 ; out = net . simulate ([ 0 20 ], 'x0_sys' , x0 ); Usage example of the method get_nx (obtain the number of internal state of a component). bus_idx = 3 ; %Third busbar. state_idx = 2 ; %Second state. %Adds up the number of states from Busbar 1 to Busbar. %Practically, skips the busbars previous to the one of interest. ( bus_idx - 1 ). idx = 0 ; for i = 1 : bus_idx - 1 idx = idx + net . a_bus { i }. component . get_nx ; end %To know the second state of the third busbar. %Practically, goes to the state of interest in the busbar of interest. idx = idx + state_idx ; %In the case of the IEEE68bus model it is\u3001idx = 7+7+2= 16. option . x0_sys ( idx )= option . x0sys ( idx ) + 0.1 ; \uff1a Example 2 - Disturbance Response \u00b6 Scenario: IEEE 68-bus model. Simulation time: 0 - 30 seconds. Simulation conditions: Ground fault on busbar 1 for 0-0.07 seconds and 15-15.05 seconds; on busbar 2, and busbars 5-7 for 10-10.01 seconds. %Network definition net = network_IEEE68bus (); %Define options for simulation option = struct (); option . fault = {{[ 0 0.07 ], 1 }, {[ 15 15.05 ], 1 }, {[ 10 , 10.01 ],[ 2 , 5 : 7 ]}}; %Running the simulation out = net . simulate ([ 0 30 ], option ); Alternatively (without stating option as a structure). net = network_IEEE68bus (); out = net . simulate ([ 0 30 ], ... 'fault' ,{{[ 0 0.07 ], 1 }, {[ 15 15.05 ], 1 }, {[ 10 , 10.01 ],[ 2 , 5 : 7 ]}}); Example 3 - Input Response \u00b6 Scenario: 3-bus model. Simulation time: 0 - 30 seconds. Simulation conditions: The impedance of the load connected to busbar 3 is increased. This corresponds to the same scenario as the one explained in the Guided Example . %Network definition net = network_sample3bus (); %Condition Setting time = [ 0 , 10 , 20 , 60 ]; u_idx = 3 ; u = [ 0 , 0.05 , 0.1 , 0.1 ; ... 0 , 0 , 0 , 0 ]; %Running the simulation out = net . simulate ( time , u , u_idx ); Example 4 - Combination Response \u00b6 Combining all the previous conditions up to this point (i.e., initial value response, disturbance response, input response), the following scenario is presented. Scenario: IEEE 68-bus model. Simulation time: 0 - 20 seconds. Simulation conditions: Initial Value: The initial state of busbar 1 is slightly shifted (0.01) from the equilibrium point. Disturbance: A ground fault is applied to bus 1 at 0-0.07 seconds and to bus 10 at 10-10.05 seconds. Input: Random inputs are applied to buses 1 and 10. { % raw %} %Network definition net = network_IEEE68bus (); %Define options for simulation option = struct (); option . x0_sys = net . x_equilibrium ; option . x0_sys ( 16 )= option . x0_sys ( 16 ) + 0.01 ; option . fault = {{[ 0 0.07 ], 1 }, {[ 15 15.05 ], 1 }, {[ 10 , 10.01 ],[ 2 , 5 : 7 ]}}; %Condition Setting time = [ 0 , 10 , 20 , 60 ]; u_idx = 20 ; u = [ 0 , 0.05 , 0.1 , 0.1 ; ... 0 , 0 , 0 , 0 ]; %Running the simulation out = net . simulate ( time , u , u_idx , option ); { % endraw %} Alternatively (without stating option as a structure). net = network_IEEE68bus (); x0 = net . x_equilibrium ; x0 ( 16 )= x0 ( 16 ) + 0.01 ; out = net . simulate ([ 0 20 ], u , u_idx , ... 'x0_sys' , x0 , ... 'fault' ,{{[ 0 0.07 ], 1 }, {[ 15 15.05 ], 1 }, {[ 10 , 10.01 ],[ 2 , 5 : 7 ]}}); Simulation Results \u00b6 In the IEEE 68-bus model, the generators are connected to the busbars 1 to 16. The generator model used is the 1-axis model (i.e., generator_1axis class). Remember that for this model, the first three entries are Rotor declination \\(\\small (\\delta)\\) . Frequency deviation \\(\\small (\\Delta \\omega)\\) Internal voltage \\(\\small (E)\\) . Thus, to visualize the frequency deviation \\(\\small (\\Delta \\omega)\\) of each generator bus, all you have to do is to look at the 2nd state of each device. It can be easily plotted with the following code. figure ; hold on arrayfun (@( idx ) plot ( out . t , out . X { idx }(:, 2 )), 1 : 16 ); xlabel ( 'Time [s]' , 'FontSize' , 15 ); ylabel ( 'Frequency Deviation' , 'FontSize' , 15 ); legend () title ( 'Frequency deviation of each synchronous generator' , 'FontSize' , 20 ) hold off However, when there is more than one device with a state, as in this model, it is necessary to consider the state of each device. The simulationResult class described below automatically classifies and plots each device using its state variable name in the internal method. Results Visualization \u00b6 As mentioned before, GUILDA implements a class called simulationResult , which is used to visualize the simulation results. Plot with command To use it, in the simulate function, set the option tools as true . For the case of example 4: { % raw %} net = network_IEEE68bus (); x0 = net . x_equilibrium ; x0 ( 16 )= x0 ( 16 ) + 0.1 ; out = net . simulate ([ 0 20 ], u , u_idx , ... 'x0_sys' , x0 , ... 'fault' ,{{[ 0 0.07 ], 1 }, {[ 15 15.05 ], 1 }, {[ 10 , 10.01 ],[ 2 , 5 : 7 ]}}, ... 'tools' , true ); { % endraw %} Plot with User Interface (UI) To plot with the UI use: out . UIplot The UI for plotting conditions will be displayed. Check the appropriate check boxes and press the \"plot\" button to display the plot. At this time, if you check the \"command output\" box, commands for plotting will be displayed.","title":"Simulation Examples"},{"location":"Reference/Analysis/SampleCode/#simulation_-_examples","text":"This page contains examples of handling the simulating function and examining its response under various settings. Contents: Example 1 - Initial Value Response. Example 2 - Disturbance Response. Example 3 - Input Response. Example 4 - Combination Response. Simulation Results","title":"Simulation - Examples"},{"location":"Reference/Analysis/SampleCode/#example_1_-_initial_value_response","text":"Scenario: IEEE 68-bus model. Simulation time: 0 - 20 seconds. Simulation conditions: Initial value of frequency deviation \\(\\small (\\Delta \\omega)\\) (second state) of the generator connected to busbar 3 is deviated by 0.01 from the equilibrium point. The second state of the generator connected to busbar 3 corresponds to the 16th state of the entire system. Remember that the state of the entire system is a vector composed of the states of all components (in the busbar ascending order). And since in the IEEE 68-bus model, the generators have 7 states each, the second state of the third generator is the 16th state of the entire system. In cases where the number of internal states per components isn't known, the method get_nx can be used. %Network Definition net = network_IEEE68bus (); %Define options for simulation option = struct (); option . x0_sys = net . x_equilibrium ; option . x0_sys ( 16 )= option . x0_sys ( 16 ) + 0.01 ; %Running the simulation out = net . simulate ([ 0 20 ], option ); Alternatively (without stating option as a structure). net = network_IEEE68bus (); x0 = net . x_equilibrium ; x0 ( 16 )= x0 ( 16 ) + 0.01 ; out = net . simulate ([ 0 20 ], 'x0_sys' , x0 ); Usage example of the method get_nx (obtain the number of internal state of a component). bus_idx = 3 ; %Third busbar. state_idx = 2 ; %Second state. %Adds up the number of states from Busbar 1 to Busbar. %Practically, skips the busbars previous to the one of interest. ( bus_idx - 1 ). idx = 0 ; for i = 1 : bus_idx - 1 idx = idx + net . a_bus { i }. component . get_nx ; end %To know the second state of the third busbar. %Practically, goes to the state of interest in the busbar of interest. idx = idx + state_idx ; %In the case of the IEEE68bus model it is\u3001idx = 7+7+2= 16. option . x0_sys ( idx )= option . x0sys ( idx ) + 0.1 ; \uff1a","title":"Example 1 - Initial Value Response"},{"location":"Reference/Analysis/SampleCode/#example_2_-_disturbance_response","text":"Scenario: IEEE 68-bus model. Simulation time: 0 - 30 seconds. Simulation conditions: Ground fault on busbar 1 for 0-0.07 seconds and 15-15.05 seconds; on busbar 2, and busbars 5-7 for 10-10.01 seconds. %Network definition net = network_IEEE68bus (); %Define options for simulation option = struct (); option . fault = {{[ 0 0.07 ], 1 }, {[ 15 15.05 ], 1 }, {[ 10 , 10.01 ],[ 2 , 5 : 7 ]}}; %Running the simulation out = net . simulate ([ 0 30 ], option ); Alternatively (without stating option as a structure). net = network_IEEE68bus (); out = net . simulate ([ 0 30 ], ... 'fault' ,{{[ 0 0.07 ], 1 }, {[ 15 15.05 ], 1 }, {[ 10 , 10.01 ],[ 2 , 5 : 7 ]}});","title":"Example 2 - Disturbance Response"},{"location":"Reference/Analysis/SampleCode/#example_3_-_input_response","text":"Scenario: 3-bus model. Simulation time: 0 - 30 seconds. Simulation conditions: The impedance of the load connected to busbar 3 is increased. This corresponds to the same scenario as the one explained in the Guided Example . %Network definition net = network_sample3bus (); %Condition Setting time = [ 0 , 10 , 20 , 60 ]; u_idx = 3 ; u = [ 0 , 0.05 , 0.1 , 0.1 ; ... 0 , 0 , 0 , 0 ]; %Running the simulation out = net . simulate ( time , u , u_idx );","title":"Example 3 - Input Response"},{"location":"Reference/Analysis/SampleCode/#example_4_-_combination_response","text":"Combining all the previous conditions up to this point (i.e., initial value response, disturbance response, input response), the following scenario is presented. Scenario: IEEE 68-bus model. Simulation time: 0 - 20 seconds. Simulation conditions: Initial Value: The initial state of busbar 1 is slightly shifted (0.01) from the equilibrium point. Disturbance: A ground fault is applied to bus 1 at 0-0.07 seconds and to bus 10 at 10-10.05 seconds. Input: Random inputs are applied to buses 1 and 10. { % raw %} %Network definition net = network_IEEE68bus (); %Define options for simulation option = struct (); option . x0_sys = net . x_equilibrium ; option . x0_sys ( 16 )= option . x0_sys ( 16 ) + 0.01 ; option . fault = {{[ 0 0.07 ], 1 }, {[ 15 15.05 ], 1 }, {[ 10 , 10.01 ],[ 2 , 5 : 7 ]}}; %Condition Setting time = [ 0 , 10 , 20 , 60 ]; u_idx = 20 ; u = [ 0 , 0.05 , 0.1 , 0.1 ; ... 0 , 0 , 0 , 0 ]; %Running the simulation out = net . simulate ( time , u , u_idx , option ); { % endraw %} Alternatively (without stating option as a structure). net = network_IEEE68bus (); x0 = net . x_equilibrium ; x0 ( 16 )= x0 ( 16 ) + 0.01 ; out = net . simulate ([ 0 20 ], u , u_idx , ... 'x0_sys' , x0 , ... 'fault' ,{{[ 0 0.07 ], 1 }, {[ 15 15.05 ], 1 }, {[ 10 , 10.01 ],[ 2 , 5 : 7 ]}});","title":"Example 4 - Combination Response"},{"location":"Reference/Analysis/SampleCode/#simulation_results","text":"In the IEEE 68-bus model, the generators are connected to the busbars 1 to 16. The generator model used is the 1-axis model (i.e., generator_1axis class). Remember that for this model, the first three entries are Rotor declination \\(\\small (\\delta)\\) . Frequency deviation \\(\\small (\\Delta \\omega)\\) Internal voltage \\(\\small (E)\\) . Thus, to visualize the frequency deviation \\(\\small (\\Delta \\omega)\\) of each generator bus, all you have to do is to look at the 2nd state of each device. It can be easily plotted with the following code. figure ; hold on arrayfun (@( idx ) plot ( out . t , out . X { idx }(:, 2 )), 1 : 16 ); xlabel ( 'Time [s]' , 'FontSize' , 15 ); ylabel ( 'Frequency Deviation' , 'FontSize' , 15 ); legend () title ( 'Frequency deviation of each synchronous generator' , 'FontSize' , 20 ) hold off However, when there is more than one device with a state, as in this model, it is necessary to consider the state of each device. The simulationResult class described below automatically classifies and plots each device using its state variable name in the internal method.","title":"Simulation Results"},{"location":"Reference/Analysis/SampleCode/#results_visualization","text":"As mentioned before, GUILDA implements a class called simulationResult , which is used to visualize the simulation results. Plot with command To use it, in the simulate function, set the option tools as true . For the case of example 4: { % raw %} net = network_IEEE68bus (); x0 = net . x_equilibrium ; x0 ( 16 )= x0 ( 16 ) + 0.1 ; out = net . simulate ([ 0 20 ], u , u_idx , ... 'x0_sys' , x0 , ... 'fault' ,{{[ 0 0.07 ], 1 }, {[ 15 15.05 ], 1 }, {[ 10 , 10.01 ],[ 2 , 5 : 7 ]}}, ... 'tools' , true ); { % endraw %} Plot with User Interface (UI) To plot with the UI use: out . UIplot The UI for plotting conditions will be displayed. Check the appropriate check boxes and press the \"plot\" button to display the plot. At this time, if you check the \"command output\" box, commands for plotting will be displayed.","title":"Results Visualization"},{"location":"Reference/Analysis/net_getsys/","text":"Derivation of a Linearized Model \u00b6 This section describes the derivation of the approximate linearized model of the created power system model. Contents: A Linearized Model. Obtaining a Linearized Model. Examples. Example 1 - Add a Controller. Example 2 - View the System from a Specific Input to Output. Example 3 - Linear Simulation Results. Example 4 - Linear and Nonlinear Simulation Results. A Linearized Model \u00b6 This is a description of what a linearized model is. To provide an example the IEEE 68-bus power system model is linearized. For it, it is necessary to define the power system model, and then linearize it. Note that the linearization takes part when simulating the system. %Define the power network as the IEEE 68-bus model. net = network_IEEE68bus (); Remember that the variable net includes all the information of the power_network , which includes buses, branches, generators, controllers, etc. The linearized system is simulated as follows %The system is linearized when it is simulated. out = net . simulate ([ 0 20 ], 'linear' , true ); If the option linear is immediately followed by true , the system is linearized and simulated. if false , the system is not linearized and simulated. For more information on the option arguments and the simulate method, please refer to Simulating under the \"Simulation Execution Method\" section. Obtaining a Linearized Model \u00b6 Linearized Model Method ( get_sys ) \u00b6 To obtain the linearized version of the power system model, the method get_sys is used. It allows to transform the power system model into a state-space representation of the following form \\begin{matrix} \\dot{x}=A(x-x^*)+B(u-u^*)\\\\ y=C(x-x^*)+D(u-u*)\\\\ \\end{matrix} Method Structure: sys = net.get_sys(with_controller); Note: The system obtained from get_sys takes as its state the deviation from the equilibrium point. Input Arguments with_controller : Determines if a controller is added to the system (i.e., true ) or not (i.e., false , default value). If a controller is added, it must be configured as well. Output Parameters sys : The following variables are stored in this output. Some of these variables are automatically generated by the function ss(A,B,C,D) used in the get_sys script. Of these, only the six variables listed below have substantial information. A,B,C,D : Coefficient matrices of the state-space representation. They contain information on each element of the State Matrix A , the Input Matrix B , the Output Matrix C , and the Directivity Matrix D of the linearized system. InputGroup : It stores the name of each channel in the input vector \\((u)\\) , and how many channels there are in the state-space representation. OutputGroup : It stores the name of each channel in the output vector \\((y)\\) , and how many channels there are in the state-space representation. Note: The return value of get_sys is assumed to be sys , which is the case in the examples of this page, but of course a different name can be assigned. Linearized Model Method in the 1-Axis Synchronous Generator Model \u00b6 This state-space representation can be applied to several components of the power system model. In this page the state-space representation is applied to a 1-Axis Synchronous Generator model as an example. Note that, of course, the meaning of the variables will change as the component analyzed changes. Now, the variables of the state-space representation of a 1-Axis Synchronous Generator Model are explained. State \\((x)\\) It is a vector that contains the information on the state of the generator. There are 7 entries in the state of the generator. Let \\(x_i\\) be the state of the i-th generator, then the vector entries are x_i =\\left( %\\begin{align} \\begin{array}{ccccccc} \\delta_i %&= Rotor angle \\\\ \\Delta\\omega_i %&= Frequency deviation \\\\ E_i %&= Internal voltage \\\\ V_{\\mathrm{fd}i} %&= AGC state variables \\\\ \\xi_{1i} %&= PSS state variable 1 \\\\ \\xi_{2i} %&= PSS state variable 2 \\\\ \\xi_{3i} %&= PSS state variable 3 \\\\ \\end{array} %\\end{align} \\right) From top to bottom, these correspond to \\(\\delta_i\\) : Rotor declination. \\(\\Delta\\omega_i\\) : Frequency deviation. \\(E_i\\) : Internal voltage of the generator. \\(V_{\\mathrm{fd}}\\) : Controller (AGC) state variable. \\(\\xi_{1i}\\) : Controller (PSS) state variable 1. \\(\\xi_{2i}\\) : Controller (PSS) state variable 2. \\(\\xi_{3i}\\) : Controller (PSS) state variable 3. Since, in most power system models, there are several generators, then to generalize the state of all the generators we denote \\(I_{G}\\) : Total number of generators. \\(x_{i}\\) : The \\(\\small i-th\\) generator. \\(x\\) : The entire set of generators. Then, \\(x\\) is defined as: x = \\left( \\begin{array}{} x_1\\\\ \\vdots\\\\ x_{I_G}\\\\ \\end{array} \\right) Input Signal \\((u)\\) It corresponds to the input signal that the component (i.e., generator or load) receives. Since the input signal depends on the target component, its details are explained for each component. To define this variable we denote \\(I_{G}\\) : Total number of generators. \\(I_{L}\\) : Total number of loads. \\(I_{GL}\\) : Total number of components (generators and loads). \\(u_i\\) : Input signal of the \\(\\small i-th\\) component. \\(d_i\\) : Disturbance of the \\(\\small i-th\\) component. Note: \\(u_i\\) and \\(d_i\\) depend on the component type (i.e., generator or load). Then, the input \\(u\\) is defined as: u=\\left( \\begin{array}{} u_1\\\\ \\vdots\\\\ u_{I_{GL}}\\\\ \\\\d_1\\\\ \\vdots\\\\ d_{I_G}\\\\ \\end{array} \\right) Input \\(\\small (u)\\) - Generator: There are 2 types of inputs, the Automatic Voltage Regulator (AVR) Input, and the Governor Input. u_i=\\left( \\begin{array}{} u^{(i)}_{\\mathrm{avr}}\\\\ u^{(i)}_{\\mathrm{governor}}\\\\ \\end{array} \\right) \\(u_{\\mathrm{avr}}\\) : AVR Input (\uff10 for generators with no AVR). \\(u_{\\mathrm{governor}}\\) : Governor Input. Input \\(\\small (u)\\) - Load: There are 2 types of inputs, the porcentual increase of the real part of the admittance, and the porcentual increase of the imaginary part of the admittance. u_i=\\left( \\begin{array}{} u^{(i)}_1\\\\ u^{(i)}_2\\\\ \\end{array} \\right) \\(u_1\\) : Porcentual Increase of the Real Part of the Admittance (i.e., Conductance \\(\\small (G)\\) ). \\(u_2\\) : Porcentual Increase of the Imaginary Part of the Admittance (i.e., Susceptance \\(\\small (B)\\) ). The way in which the inputs \\((u_1, u_2)\\) modify the original admittance \\(\\small (Y_{o})\\) is described in the following expression. Y = \\mathrm{Re}[Y_{\\mathrm{o}}](1+u_1) + j \\text{ } \\mathrm{Im}[Y_{\\mathrm{o}}] (1+u_2) Disturbance \\(\\small (d)\\) - Generator: Note that disturbances are treated as external inputs, as it is evidenced by the fact that they are elements of the input vector \\(u\\) . Also, consider that each generator \\((i)\\) can have multiple disturbances \\((n)\\) , then the set of disturbances of the \\(\\small i-th\\) generator is given by d_i=\\left( \\begin{array}{} d^{(i)}_{1}\\\\ \\vdots\\\\ d^{(i)}_{n}\\\\ \\end{array} \\right) Disturbance \\(\\small (d)\\) - Load: In GUILDA, the disturbances in loads are ignored, since they are considered too small compared to those of the generators. It is possible to add disturbances to the loads as well. However, since this changes the vector size, then it becomes necessary to redefine the processes that deal with this vector \\((u)\\) . Output Signal \\((y)\\) The output signal is composed from the following State of each generator \\((x)\\) . Evaluation function of each generator \\((z)\\) (i.e., evaluation criterion when designing the control system). Voltage of each bus \\((V)\\) . Current of each bus \\((I)\\) . y=\\left( \\begin{array}{} x_1\\\\ \\vdots\\\\ x_{I_G}\\\\ \\\\z_1\\\\ \\vdots\\\\ z_{I_G}\\\\ \\\\V_1\\\\ \\vdots\\\\ V_{I_{all}}\\\\ \\\\I_1\\\\ \\vdots\\\\ I_{I_{all}}\\\\ \\end{array} \\right) Note that each \\(V_i\\) and \\(I_i\\) are composed by a real part and imaginary part V_i=\\left( \\begin{array}{} V_{\\mathrm{real}}\\\\ V_{\\mathrm{image}}\\\\ \\end{array} \\right) \\quad,\\quad I_i=\\left( \\begin{array}{} I_{\\mathrm{real}}\\\\ I_{\\mathrm{image}}\\\\ \\end{array} \\right) Examples \u00b6 Example 1 - Add a Controller \u00b6 Objective: Derive the state-space representation of the linearized model of a power network with controllers. Requirements: The Power Network (i.e., net ) must already be defined. The Controllers (e.g., AGC ) must already be defined. %Derive the state-space representation of the linearized %model of a power network with controllers. sys = net . get_sys ( true ); Note that get_sys(false) means to derive the state-space representation of the system excluding the controller. Example 2 - View the System from a Specific Input to Output. \u00b6 The system matrices ( A, B, C, D ) stored in the returned sys vary in size depending on the number of buses. In cases where the state-space representation contains matrices with a great ammount of elements, this function is useful, as it allows to extract only a portion of the system, viewed from a specific input to a specific output. Objective: Extract a portion of the system, as it is viewed from the disturbance input \\((d_1)\\) to the evaluation output \\((z_1)\\) . Requirements: The Linearized System ( sys ) must already be defined. sys ( 'z1' , 'd1' ) Example 3 - Linear Simulation Results. \u00b6 Objective: Compare the results of two methods in the following scenario: Simulate the time response of the synchronous generators to a ground fault in busbar 1 during time 0 - 0.01 s. Method 1: Using the MATLAB Solver ODE15S with approximate linearization (i.e., the method simulate and option.linear = true ). Method 2: Using the linear state-space representation of the system (i.e., the method get_sys ). The time response is obtained as a response to initial value conditions by the MATLAB function initial() . Requirements: The code shown below. %Define the Power Network net = network_IEEE68bus (); %Define the settings of the linear simulation during %the ground fault segment t = [0, 0.01]. %This will be used as the initial conditions of the %Linearized State-Space Representation. option_fault = struct (); option_fault . fault = {{[ 0 , 0.01 ], 1 }}; option_fault . linear = true ; out_fault = net . simulate ([ 0 , 0.01 ], option_fault ); %ODE15S Solver %Define the linear ODE15S solver and simulate. option = struct (); option . x0_sys = horzcat ( out_fault . X {:}); option . x0_sys = option . x0_sys ( end ,:) ' ; option . linear = true ; tmax = 30 ; out_linear = net . simulate ([ 0 tmax ], option ); %Linearized State-Space Representation %Obtain the linear state-space representation and simulate. sys = net . get_sys (); x0 = horzcat ( out_fault . X {:}); x0 = x0 ( end , :) ' - net . x_equilibrium ; [ z , t , x ] = initial ( sys , x0 ); %Plot the results. numele = size ( find ( t < tmax ), 1 ); z = z ( 1 : numele , :); t = t ( 1 : numele , :); x = x + net . x_equilibrium ' ; x = x ( 1 : numele , :); for i = 1 : 16 figure p = plot ( out_linear . t , out_linear . X { i }(:, 2 ), '-' , t , x (:, 7 * ( i - 1 ) + 2 ), '--' ); p ( 1 ). LineWidth = 2 ; p ( 2 ). LineWidth = 2 ; title ( '\\Delta\\omega' , 'Interpreter' , 'tex' ); legend ( 'ODE Solver' , 'Initial function (linearized state-space)' ) xlabel ( 'Time [s]' ) ylabel ( 'Frequency Deviation' ) end Two examples of the result of this code are the following. The time response of the generator in busbar 7 (left). The time response of the generator in busbar 14 (right). Note that the blue solid line represents the time response of the frequency deviation obtained by the ODE15S solver, while the orange dashed line corresponds to the one obtained by the initial value conditions applied to the linearized state-space representation. It is noteworthy that both responses are well aligned. Lastly, the buses 7 and 14 were chosen randomly and not for any reason in particular. Example 4 - Linear and Nonlinear Simulation Results. \u00b6 Objective: Simulate the time response of the synchronous generators to a ground fault in busbar 1 during time 0 - 0.01 s, by using the MATLAB Solver ODE15S (i.e., simulate ) with approximate linearization (i.e., option.linear = true ) and without approximate linearization (i.e., option.linear = false ). Requirements: The code shown below. %Define the Power Network net = network_IEEE68bus (); %Define the settings for the nonlinear simulation. option = struct (); option . fault = {{[ 0 , 0.01 ], 1 }}; option . linear = false ; out_nonlinear = net . simulate ([ 0 , 30 ], option ); %Define the settings for the linear simulation. option . linear = true ; out_linear = net . simulate ([ 0 , 30 ], option ); %Plot the results. for i = 1 : 16 figure p = plot ( out_linear . t , out_linear . X { i }(:, 2 ), '-' , out_nonlinear . t , out_nonlinear . X { i }(:, 2 ), '--' ); p ( 1 ). LineWidth = 2 ; p ( 2 ). LineWidth = 2 ; title ( '\\Delta\\omega' , 'Interpreter' , 'tex' ); legend ( 'Linear' , 'Nonlinear' ) end Two examples of the result of this code are the following. The time response of the generator in busbar 7 (left). The time response of the generator in busbar 14 (right). Note that the blue solid line represents the time response of the frequency deviation obtained by the ODE15S solver of the linear system, while the orange dashed line corresponds to the one obtained for the nonlinear system.","title":"Derivation of a Linearized Model"},{"location":"Reference/Analysis/net_getsys/#derivation_of_a_linearized_model","text":"This section describes the derivation of the approximate linearized model of the created power system model. Contents: A Linearized Model. Obtaining a Linearized Model. Examples. Example 1 - Add a Controller. Example 2 - View the System from a Specific Input to Output. Example 3 - Linear Simulation Results. Example 4 - Linear and Nonlinear Simulation Results.","title":"Derivation of a Linearized Model"},{"location":"Reference/Analysis/net_getsys/#a_linearized_model","text":"This is a description of what a linearized model is. To provide an example the IEEE 68-bus power system model is linearized. For it, it is necessary to define the power system model, and then linearize it. Note that the linearization takes part when simulating the system. %Define the power network as the IEEE 68-bus model. net = network_IEEE68bus (); Remember that the variable net includes all the information of the power_network , which includes buses, branches, generators, controllers, etc. The linearized system is simulated as follows %The system is linearized when it is simulated. out = net . simulate ([ 0 20 ], 'linear' , true ); If the option linear is immediately followed by true , the system is linearized and simulated. if false , the system is not linearized and simulated. For more information on the option arguments and the simulate method, please refer to Simulating under the \"Simulation Execution Method\" section.","title":"A Linearized Model"},{"location":"Reference/Analysis/net_getsys/#obtaining_a_linearized_model","text":"","title":"Obtaining a Linearized Model"},{"location":"Reference/Analysis/net_getsys/#linearized_model_method_get_sys","text":"To obtain the linearized version of the power system model, the method get_sys is used. It allows to transform the power system model into a state-space representation of the following form \\begin{matrix} \\dot{x}=A(x-x^*)+B(u-u^*)\\\\ y=C(x-x^*)+D(u-u*)\\\\ \\end{matrix} Method Structure: sys = net.get_sys(with_controller); Note: The system obtained from get_sys takes as its state the deviation from the equilibrium point. Input Arguments with_controller : Determines if a controller is added to the system (i.e., true ) or not (i.e., false , default value). If a controller is added, it must be configured as well. Output Parameters sys : The following variables are stored in this output. Some of these variables are automatically generated by the function ss(A,B,C,D) used in the get_sys script. Of these, only the six variables listed below have substantial information. A,B,C,D : Coefficient matrices of the state-space representation. They contain information on each element of the State Matrix A , the Input Matrix B , the Output Matrix C , and the Directivity Matrix D of the linearized system. InputGroup : It stores the name of each channel in the input vector \\((u)\\) , and how many channels there are in the state-space representation. OutputGroup : It stores the name of each channel in the output vector \\((y)\\) , and how many channels there are in the state-space representation. Note: The return value of get_sys is assumed to be sys , which is the case in the examples of this page, but of course a different name can be assigned.","title":"Linearized Model Method (get_sys)"},{"location":"Reference/Analysis/net_getsys/#linearized_model_method_in_the_1-axis_synchronous_generator_model","text":"This state-space representation can be applied to several components of the power system model. In this page the state-space representation is applied to a 1-Axis Synchronous Generator model as an example. Note that, of course, the meaning of the variables will change as the component analyzed changes. Now, the variables of the state-space representation of a 1-Axis Synchronous Generator Model are explained. State \\((x)\\) It is a vector that contains the information on the state of the generator. There are 7 entries in the state of the generator. Let \\(x_i\\) be the state of the i-th generator, then the vector entries are x_i =\\left( %\\begin{align} \\begin{array}{ccccccc} \\delta_i %&= Rotor angle \\\\ \\Delta\\omega_i %&= Frequency deviation \\\\ E_i %&= Internal voltage \\\\ V_{\\mathrm{fd}i} %&= AGC state variables \\\\ \\xi_{1i} %&= PSS state variable 1 \\\\ \\xi_{2i} %&= PSS state variable 2 \\\\ \\xi_{3i} %&= PSS state variable 3 \\\\ \\end{array} %\\end{align} \\right) From top to bottom, these correspond to \\(\\delta_i\\) : Rotor declination. \\(\\Delta\\omega_i\\) : Frequency deviation. \\(E_i\\) : Internal voltage of the generator. \\(V_{\\mathrm{fd}}\\) : Controller (AGC) state variable. \\(\\xi_{1i}\\) : Controller (PSS) state variable 1. \\(\\xi_{2i}\\) : Controller (PSS) state variable 2. \\(\\xi_{3i}\\) : Controller (PSS) state variable 3. Since, in most power system models, there are several generators, then to generalize the state of all the generators we denote \\(I_{G}\\) : Total number of generators. \\(x_{i}\\) : The \\(\\small i-th\\) generator. \\(x\\) : The entire set of generators. Then, \\(x\\) is defined as: x = \\left( \\begin{array}{} x_1\\\\ \\vdots\\\\ x_{I_G}\\\\ \\end{array} \\right) Input Signal \\((u)\\) It corresponds to the input signal that the component (i.e., generator or load) receives. Since the input signal depends on the target component, its details are explained for each component. To define this variable we denote \\(I_{G}\\) : Total number of generators. \\(I_{L}\\) : Total number of loads. \\(I_{GL}\\) : Total number of components (generators and loads). \\(u_i\\) : Input signal of the \\(\\small i-th\\) component. \\(d_i\\) : Disturbance of the \\(\\small i-th\\) component. Note: \\(u_i\\) and \\(d_i\\) depend on the component type (i.e., generator or load). Then, the input \\(u\\) is defined as: u=\\left( \\begin{array}{} u_1\\\\ \\vdots\\\\ u_{I_{GL}}\\\\ \\\\d_1\\\\ \\vdots\\\\ d_{I_G}\\\\ \\end{array} \\right) Input \\(\\small (u)\\) - Generator: There are 2 types of inputs, the Automatic Voltage Regulator (AVR) Input, and the Governor Input. u_i=\\left( \\begin{array}{} u^{(i)}_{\\mathrm{avr}}\\\\ u^{(i)}_{\\mathrm{governor}}\\\\ \\end{array} \\right) \\(u_{\\mathrm{avr}}\\) : AVR Input (\uff10 for generators with no AVR). \\(u_{\\mathrm{governor}}\\) : Governor Input. Input \\(\\small (u)\\) - Load: There are 2 types of inputs, the porcentual increase of the real part of the admittance, and the porcentual increase of the imaginary part of the admittance. u_i=\\left( \\begin{array}{} u^{(i)}_1\\\\ u^{(i)}_2\\\\ \\end{array} \\right) \\(u_1\\) : Porcentual Increase of the Real Part of the Admittance (i.e., Conductance \\(\\small (G)\\) ). \\(u_2\\) : Porcentual Increase of the Imaginary Part of the Admittance (i.e., Susceptance \\(\\small (B)\\) ). The way in which the inputs \\((u_1, u_2)\\) modify the original admittance \\(\\small (Y_{o})\\) is described in the following expression. Y = \\mathrm{Re}[Y_{\\mathrm{o}}](1+u_1) + j \\text{ } \\mathrm{Im}[Y_{\\mathrm{o}}] (1+u_2) Disturbance \\(\\small (d)\\) - Generator: Note that disturbances are treated as external inputs, as it is evidenced by the fact that they are elements of the input vector \\(u\\) . Also, consider that each generator \\((i)\\) can have multiple disturbances \\((n)\\) , then the set of disturbances of the \\(\\small i-th\\) generator is given by d_i=\\left( \\begin{array}{} d^{(i)}_{1}\\\\ \\vdots\\\\ d^{(i)}_{n}\\\\ \\end{array} \\right) Disturbance \\(\\small (d)\\) - Load: In GUILDA, the disturbances in loads are ignored, since they are considered too small compared to those of the generators. It is possible to add disturbances to the loads as well. However, since this changes the vector size, then it becomes necessary to redefine the processes that deal with this vector \\((u)\\) . Output Signal \\((y)\\) The output signal is composed from the following State of each generator \\((x)\\) . Evaluation function of each generator \\((z)\\) (i.e., evaluation criterion when designing the control system). Voltage of each bus \\((V)\\) . Current of each bus \\((I)\\) . y=\\left( \\begin{array}{} x_1\\\\ \\vdots\\\\ x_{I_G}\\\\ \\\\z_1\\\\ \\vdots\\\\ z_{I_G}\\\\ \\\\V_1\\\\ \\vdots\\\\ V_{I_{all}}\\\\ \\\\I_1\\\\ \\vdots\\\\ I_{I_{all}}\\\\ \\end{array} \\right) Note that each \\(V_i\\) and \\(I_i\\) are composed by a real part and imaginary part V_i=\\left( \\begin{array}{} V_{\\mathrm{real}}\\\\ V_{\\mathrm{image}}\\\\ \\end{array} \\right) \\quad,\\quad I_i=\\left( \\begin{array}{} I_{\\mathrm{real}}\\\\ I_{\\mathrm{image}}\\\\ \\end{array} \\right)","title":"Linearized Model Method in the 1-Axis Synchronous Generator Model"},{"location":"Reference/Analysis/net_getsys/#examples","text":"","title":"Examples"},{"location":"Reference/Analysis/net_getsys/#example_1_-_add_a_controller","text":"Objective: Derive the state-space representation of the linearized model of a power network with controllers. Requirements: The Power Network (i.e., net ) must already be defined. The Controllers (e.g., AGC ) must already be defined. %Derive the state-space representation of the linearized %model of a power network with controllers. sys = net . get_sys ( true ); Note that get_sys(false) means to derive the state-space representation of the system excluding the controller.","title":"Example 1 - Add a Controller"},{"location":"Reference/Analysis/net_getsys/#example_2_-_view_the_system_from_a_specific_input_to_output","text":"The system matrices ( A, B, C, D ) stored in the returned sys vary in size depending on the number of buses. In cases where the state-space representation contains matrices with a great ammount of elements, this function is useful, as it allows to extract only a portion of the system, viewed from a specific input to a specific output. Objective: Extract a portion of the system, as it is viewed from the disturbance input \\((d_1)\\) to the evaluation output \\((z_1)\\) . Requirements: The Linearized System ( sys ) must already be defined. sys ( 'z1' , 'd1' )","title":"Example 2 - View the System from a Specific Input to Output."},{"location":"Reference/Analysis/net_getsys/#example_3_-_linear_simulation_results","text":"Objective: Compare the results of two methods in the following scenario: Simulate the time response of the synchronous generators to a ground fault in busbar 1 during time 0 - 0.01 s. Method 1: Using the MATLAB Solver ODE15S with approximate linearization (i.e., the method simulate and option.linear = true ). Method 2: Using the linear state-space representation of the system (i.e., the method get_sys ). The time response is obtained as a response to initial value conditions by the MATLAB function initial() . Requirements: The code shown below. %Define the Power Network net = network_IEEE68bus (); %Define the settings of the linear simulation during %the ground fault segment t = [0, 0.01]. %This will be used as the initial conditions of the %Linearized State-Space Representation. option_fault = struct (); option_fault . fault = {{[ 0 , 0.01 ], 1 }}; option_fault . linear = true ; out_fault = net . simulate ([ 0 , 0.01 ], option_fault ); %ODE15S Solver %Define the linear ODE15S solver and simulate. option = struct (); option . x0_sys = horzcat ( out_fault . X {:}); option . x0_sys = option . x0_sys ( end ,:) ' ; option . linear = true ; tmax = 30 ; out_linear = net . simulate ([ 0 tmax ], option ); %Linearized State-Space Representation %Obtain the linear state-space representation and simulate. sys = net . get_sys (); x0 = horzcat ( out_fault . X {:}); x0 = x0 ( end , :) ' - net . x_equilibrium ; [ z , t , x ] = initial ( sys , x0 ); %Plot the results. numele = size ( find ( t < tmax ), 1 ); z = z ( 1 : numele , :); t = t ( 1 : numele , :); x = x + net . x_equilibrium ' ; x = x ( 1 : numele , :); for i = 1 : 16 figure p = plot ( out_linear . t , out_linear . X { i }(:, 2 ), '-' , t , x (:, 7 * ( i - 1 ) + 2 ), '--' ); p ( 1 ). LineWidth = 2 ; p ( 2 ). LineWidth = 2 ; title ( '\\Delta\\omega' , 'Interpreter' , 'tex' ); legend ( 'ODE Solver' , 'Initial function (linearized state-space)' ) xlabel ( 'Time [s]' ) ylabel ( 'Frequency Deviation' ) end Two examples of the result of this code are the following. The time response of the generator in busbar 7 (left). The time response of the generator in busbar 14 (right). Note that the blue solid line represents the time response of the frequency deviation obtained by the ODE15S solver, while the orange dashed line corresponds to the one obtained by the initial value conditions applied to the linearized state-space representation. It is noteworthy that both responses are well aligned. Lastly, the buses 7 and 14 were chosen randomly and not for any reason in particular.","title":"Example 3 - Linear Simulation Results."},{"location":"Reference/Analysis/net_getsys/#example_4_-_linear_and_nonlinear_simulation_results","text":"Objective: Simulate the time response of the synchronous generators to a ground fault in busbar 1 during time 0 - 0.01 s, by using the MATLAB Solver ODE15S (i.e., simulate ) with approximate linearization (i.e., option.linear = true ) and without approximate linearization (i.e., option.linear = false ). Requirements: The code shown below. %Define the Power Network net = network_IEEE68bus (); %Define the settings for the nonlinear simulation. option = struct (); option . fault = {{[ 0 , 0.01 ], 1 }}; option . linear = false ; out_nonlinear = net . simulate ([ 0 , 30 ], option ); %Define the settings for the linear simulation. option . linear = true ; out_linear = net . simulate ([ 0 , 30 ], option ); %Plot the results. for i = 1 : 16 figure p = plot ( out_linear . t , out_linear . X { i }(:, 2 ), '-' , out_nonlinear . t , out_nonlinear . X { i }(:, 2 ), '--' ); p ( 1 ). LineWidth = 2 ; p ( 2 ). LineWidth = 2 ; title ( '\\Delta\\omega' , 'Interpreter' , 'tex' ); legend ( 'Linear' , 'Nonlinear' ) end Two examples of the result of this code are the following. The time response of the generator in busbar 7 (left). The time response of the generator in busbar 14 (right). Note that the blue solid line represents the time response of the frequency deviation obtained by the ODE15S solver of the linear system, while the orange dashed line corresponds to the one obtained for the nonlinear system.","title":"Example 4 - Linear and Nonlinear Simulation Results."},{"location":"Reference/Analysis/net_simulate/","text":"Simulating \u00b6 This section explains how to perform the simulations. It explains how to set the simulation conditions and how to read the results. Contents: Simulation Execution Method. Time Argument. Input Argument. Time-Input Relationship. Option Argument. Results. Time Variable. State Variable. Voltage and Current Variable. Global Controller State Response Variable. Global Controller Input Variable. Linear Controller State Response Variable. Linear Controller Input Variable. Busbar Variable. Fault Busbar Variable. Admittance Matrix Variable. Solver Variable. Auxiliary Tools for Results. Simulation Examples Simulation Execution Method \u00b6 This section explains the function that simulates the power system model, which is defined as a method of the power_network class under the name simulate . The execution method is as follows %To set the options setting. out = net . simulate ( time , option ); %To set the inputs to the system. out = net . simulate ( time , u , u_idx ); %To set both the option setting, and the inputs to the system. out = net . simulate ( time , u , u_idx , option ); Note: For the data structure of the output result out , please refer to the section Results in the latter half of this page. From this point on, the arguments of the function simulate are explained. Time Argument \u00b6 time = [start, end] It specifies the time to run the simulation. For example, if you want to simulate 0-60 seconds, you can specify time=[0,60] . Input Argument \u00b6 The Input Argument is composed by the arguments u and u_idx , where u is the input to the system, and u_idx is the device number to which the input is applied. By specifying the value of these arguments, a simulation can be performed with inputs to the system. Now u_idx is explained, while u is explained afterwards. u_idx = [device number] It specifies the device number to which the input is applied. The device number is the number of the busbar connected to the device. As an example here, we consider applying inputs to the devices numbered \"1,16,20\". u_idx = [ 1 , 16 , 20 ]; To set the input values, it is necessary to know the number of ports of the target device and the port number to which the input is given. As for the number of ports, it is obligatory to define a function get_nu in the component class to get the number of input ports, which can be found as follows. >> for idx = [ 1 , 16 , 20 ] nu = net . a_bus { idx }. component . get_nu ; disp ([ 'bus' , num2str ( idx , '%.2d' ), ':nu=' , num2str ( nu ), 'port' ]) end The port number to which the input is applied must be determined by understanding the respective device model and considering the port number corresponding to the parameter to which you wish to add the input. For example, in the IEEE 68-bus model, the component 1 and 16 are assigned the generator_1axis class, so the first input port is set to be an input to the field voltage command value and the second input port to the machine torque command value. On the other hand, the component 20 is of the load_impedance class, so the first input port is set to the command value of the multiplier of the real part of the impedance, and the second to the command value of the multiplier of the imaginary part. Time-Input Relationship \u00b6 Now, the input to the system ( u ) is defined. The dimension of u is \"the sum of the number of ports of the device to which the input is added \"\u2715\" (times) the number of time indices\". In the previous section the argument time was defined as 1\u27152 array of the simulation start and end times, but if an input signal is specified, then the argument time becomes the index of the time of the input signal. In the following image the time-input relationship is depicted by using a zero-order hold. %Define the arguments time, u, and u_idx as shown above and assign them to the simulate function. out = net . simulate ( time , u , u_idx ); Option Argument \u00b6 In this section, the possible values of the option argument are explained. Input Waveform (zero-order hold or first-order hold) ( method ). Zero-Order Hold Input Signal: option . method = 'zoh' ; First-Order Hold Input Signal: option . method = 'foh' ; Code Example %Define time, u, and u_idx as shown above and assign them to the simulate function. %Define the options as 'method' and 'zoh' (zero order hold). out = net . simulate ( time , u , u_idx , 'method' , 'zoh' ); %Define the options as 'method' and 'foh' (first order hold). out = net . simulate ( time , u , u_idx , 'method' , 'foh' ); The image below shows an example of a first order hold. Simulation Linearity ( linear ). Nonlinear Model. option . linear = false ; Approximate Linearized Model. option . linear = true ; Ground Fault ( fault ). No Ground Fault. option . fault = {}; Ground Fault - Example 1. A ground fault occurs on busbar 1 within 1-1.01 sec. option . fault = {{[ 1 , 1.01 ], 1 }}; Ground Fault - Example 2. In addition to the ground fault in Example 1, another ground fault occurs between 5-5.01 seconds on busbars 2 and 3. option . fault = {{[ 1 , 1.01 ], 1 },{[ 5 , 5.01 ],[ 2 , 3 ]}}; Ground Fault - Example 3. In addition to the Example 2, a ground fault occurs between 10-10.01 seconds on busbars 4-10. option . fault = {{[ 1 , 1.01 ], 1 },{[ 5 , 5.01 ],[ 2 , 3 ]},{[ 10 , 10.01 ], 4 : 10 }}; Initial System State Condition ( x0_sys ). Initial value of the system state for the equilibrium point. option . x0_sys = net . x_equilibrium ; Initial Busbar Voltage ( V0 ). Initial value of each busbar voltage for power flow calculation. option . V0 = net . V_equilibrium ; Example: Only the voltage magnitude of busbar 1 is set to be zero \\(\\small (\\lvert V \\rvert = 0)\\) . option . V0 = net . V_equilibrium ; option . V0 ( 1 ) = 0 ; Initial Busbar Current ( I0 ). Initial value of each busbar current for power flow calculation. option . I0 = net . I_equilibrium ; Example: The current phase of busbar 16 is shifted by \\(\\small \\pi/30\\) . option . I0 = net . I_equilibrium ; option . I0 ( 16 ) = option . I0 ( 16 ) * ( cos ( pi / 30 ) + 1 j * sin ( pi / 30 )); Initial Local Controller State ( x0_con_local ). The initial value of the state of each local controller remains at the equilibrium point. option . x0_con_local = tools . vcellfun (@( c ) c . get_x0 (), obj . a_controller_local ) Initial Global Controller State ( x0_con_global ). The initial value of the state of each global controller remains at the equilibrium point. option . x0_con_global = tools . vcellfun (@( c ) c . get_x0 (), obj . a_controller_local ) Error thresholds for Numerical Integration ( AbsTol , RelTol ). Minimal required value: \\(10^{-8}\\) option . AbsTol = 1e-8 ; option . RelTol = 1e-8 ; Note: Since GUILDA uses the Solver \"ode15s\" for numerical integration, please refer to the ODE15S - official documentation for tolerance adjustment. Simulation Report Output Settings ( do_report ). Generate Simulation Report. option . do_report = true ; Don't Generate Simulation Report. option . do_report = false ; Forced Termination Time ( reset_time ). No Forced Termination Time (default value). option . reset_time = inf ; Forced Termination Time - Example: If numerical analysis is not completed within 60 seconds, the analysis is terminated at that point. option . reset_time = 60 ; option . do_retry = false ; Retry Numerical Integration ( do_retry ). Once the forced termination time is reached, retry or not the numerical integration. Retry (default value). option . do_retry = true ; Don't Retry - Example: Please refer to the reset_time condition setting example. Analysis Results Format ( tools ). Output the Results with Format (default value). option . tools = false ; Output the Results without Format. option . tools = true ; The default is to output the analysis results with format. If this option is set to true , the result will be outputted without format, and just as an instance of the class simulationResult . Note: If the simulation is planned to be executed several times, it is recommended to use the default value and output the results with format. Define the Option Argument as a Structure The function simulate allows you to set detailed simulation conditions by assigning various parameters to the argument option in the form of a structure. The procedure for setting simulation conditions and its example code are as follows. Define the variable option as a structure for setting conditions. Select one of the arguments of option corresponding to the condition you want to set and assign a value to it. Assign the defined option variable to the function simulate . %1. Define the variable option as a structure for setting conditions. option = struct (); %2. Set initial values for system status. option . x0_sys = net . x_equilibrium ; %If the frequency deviation (\u0394\u03c9) of the generator in busbar 1 is off by 0.01. option . x0_sys ( 2 ) = option . x0_sys ( 2 ) + 0.01 ; %3.Simulation Execution. time = [ 0 , 60 ]; out = net . simulate ( time , option ); Note: Refer to Network Parameters to see why x0_sys(2) corresponds to the frequency deviation of busbar 1. While the above explains how to define the variable option as a structure, the function simulate also allows to specify individual conditions directly as arguments. For example, suppose you write the following code Define the option Argument as a Structure. option = struct (); %Initial value of frequency deviation (\u0394\u03c9) of the generator of busbar 1 is deviated %from the equilibrium point by 0.01. option . x0_sys = net . x_equilibrium ; option . x0_sys ( 2 ) = option . x0_sys ( 2 ) + 0.01 ; %Ground fault occurs on busbar 5 at 5-5.01s. option . fault = {{[ 5 , 5.01 ], 5 }}; %Simulation time of 0-10 s. out = net . simulate ([ 0 , 10 ], option ); Define the option Argument directly in the simulate Function. Alternatively, the above simulation conditions can also be written as follows option = struct (); %Initial value of frequency deviation (\u0394\u03c9) of the generator of busbar 1 is deviated %from the equilibrium point by 0.01. x0 = net . x_equilibrium ; x0 ( 2 ) = x0 ( 2 ) + 0.01 ; %Simulation time of 0-10 s with a ground fault that occurs on busbar 5 at 5-5.01s. out = net . simulate ([ 0 , 10 ], 'x0_sys' , x0 , 'fault' ,{{[ 5 , 5.01 ], 5 }}); Note: When assigning the option argument directly in the simulate function, the arguments are included in the order net.simulate(...'option', 'value',...) . Results \u00b6 This section explains how to read the data in the output result ( out ). In the following image an example is presented with the intention to explain its results ( out ). Simulation Example %The IEEE 68-bus model is defined as the power network. net = network_IEEE68bus ; %The time-input relationship is stablished time = [ 0 , 5 , 20 ]; u_idx = [ 20 , 30 ]; u = ones ( 4 , 1 ) * [ 0 , 0.1 , 0.1 ] %The fault on busbar 10 at 10-10.01 is set. fault = {{[ 10 , 10.01 ], 10 }}; %An AGC global controller is added to all busbars. con = controller_broadcast_PI_AGC ( net , 1 : 16 , 1 : 16 , - 10 , - 500 ); net . add_controller_global ( con ); %The simulation run is stablished. out = net . simulate ( time , u , u_idx , 'fault' , fault ) Time Field ( t ) \u00b6 This field represents the sampling time of the simulation. It contains an array of \"number of samplings\", which is used in all the other fields ( X,V,I,Xk_global,U_global,U ). Current Example: There are 1455 samplings State Field ( X ) \u00b6 This field contains the response data of the status of the devices connected to each bus bar. out.X is a cell array in which each cell corresponds to one device at a time. The dimension of the numeric array is \"number of samplings\" \u2715 \"number of device states\". Current Example: Since the IEEE 68-bus model is used, the busbars 1-16 have a synchronous generator ( generator_1axis ) with 7 states. Thus, the dimension of the numeric array is 1455 \u2715 7. From the busbar 17th only loads are attachd ( load_impedance ), which don't have states. It is possible to call the data of an specific state of a device, for example, the second state of the device connected to busbar 4. plot ( out . t , out . X { 4 }(:, 2 )) Voltage and Current Fields ( V, I ) \u00b6 These fields contain the responses of the voltage and current of the busbars, respectively. Just like the state field ( out.X ), the voltage and current fields also are a cell array of the same size as the number of busbars in the system model. Each cell contains a numeric array with \"number of samplings\" \u2715 2 (Real Part, Imaginary Part). Current Example: Each field (i.e., Voltage and Current), have 68 cells (busbars), and each cell has the time response (1455 samplings) of the real part and imaginary part. It is possible to call the data of an busbar, for example, to plot the magnitude of the voltage and current on busbar 10 during time 10-10.1s (a fault occurs during this time in this bus, thus the expected behaviour is \\(\\small \\lvert V \\rvert \\to 0; \\lvert I \\rvert \\to \\infty\\) ). %Read the voltage of busbar 10. V10 = out . V { 10 }(:, 1 ) + 1 j * out . V { 10 }(:, 2 ); %Read the current of busbar 10. I10 = out . I { 10 }(:, 1 ) + 1 j * out . I { 10 }(:, 2 ); %Plot the absolute value of the voltage and current of busbar 10. plot ( out . t , abs ( V10 ), out . t , abs ( I10 ), 'LineWidth' , 2 ) legend ({ '$|V|$' , '$|I|$' }, 'Interpreter' , 'latex' ) xlabel ( 'Time [s]' ) ylabel ( 'Magnitude [p.u.]' ) Global Controller State Response Field ( Xk_global ) \u00b6 This field contains the global controller state response. Current Example: In this case, the power system with one global controller added was used in the analysis. Thus Xk_global is a 1\u27151 array of cells. The controller class controller_broadcast_PI_AGC has only one state, so the data stored in out.Xk_global{1} is a numeric array with \"number of samples\". Global Controller Input Field ( U_global ) \u00b6 This field contains the response of the input value from the global controller. Like out.Xk_global , this field is also a cell array with the same dimension as the number of controllers attached to the power system under analysis. Current Example: The controller added in this example is an AGC controller (reads the frequency deviation of the devices in busbars 1 through 16 and gives a command value to the Mechanical Power ( Pmech ) port of component (added to busbars 1 through 16) to balance the supply and demand of the entire system). In this case, the controller adds inputs to 16 Generators ( generator_1axis ) with 2 input ports each; thus, it has 2*16 = 32 outputs. Therefore, the data in out.U_gloobal{1} shows \"1455 \u2715 32 double\". The correspondence between the input ports and the response data for each device is shown in the figure below, since the devices are specified in ascending order, 1:16 , as shown in the code below. con = controller_broadcast_PI_AGC ( net , 1 : 16 , 1 : 16 , - 10 , - 500 ); Each cell is a 2-dimensional array of numbers. The row direction is the chronological order (samples). The column direction follows the input port order. Current Example: Although the image is small, the first column is all 0 for each cell (i.e., each busbar with a generator). This is because the first input port of the Generators ( generator_1axis ) is the Field Voltage ( Vfield ) and the second port is the Mechanical Power ( Pmech ). The AGC controlle only gives command values to the Mechanical Power ( Pmech ). Linear Controller State Response Field ( U ) \u00b6 This field contains the local controller state response. The data is read in the same way as in the global controller state response field ( U_global ). Current Example: No local controller is added, so the cell array is empty. Linear Controller Input Field ( linear ) \u00b6 This field is an index indicating whether the simulation was nonlinear or with an approximate linearization. Nonlinear: out.linear = 0 . Approximate Linearization: out.linear = 1 Internal Processes to Consinder \u00b6 Before describing the data the four remaining fields, a brief description of the processing taking place inside the function simulate is pertinent. During the numerical analysis, there is usually a point where it becomes discontinuous. For example, when a discontinuous input is given, or when the conditions are discontinuous (e.g., ground fault: the voltage suddenly drops to zero). In these cases, the solver separates the analysis in two segments, divided by the discontinous point. This means that one solver is dedicated to the first segment of the problem (before the discontuinity), and a new solver is dedicated for the second segment (after the discontinuity). The solver for the second segment starts with the value to which the discontinuity element is applied. Current Example: The input signal of the current example is shown in the following figure. Furthermore, an ground fault occurs between 10 and 10.01 seconds. Thus, in total there are three discontinuous parts: 1. \"The 5-second mark where the input value changes,\". 2. \"The 10-second mark where the ground fault occurs\". 3.\"The 10.01-second mark where the ground fault ends\". Therefore, the numerical analysis is divided into four segments : [0s to 5s], [5s to 10s], [10s to 10.01s], [10.01s to 20s]. With this in mind, the explanation of the remaining fields can be retaken. Busbar Field \u00b6 For each segment of the analysis: This field stores the index of the components being analyzed. Note: The busbars with component_empty connected are effectively treated as busbars to which no devices are connected (i.e., non-unit busbars). Fault Busbar Field \u00b6 For each segment of the analysis: This field stores the cell array classification of the index of the busbar where the ground fault occurs. Admittance Matrix Variable \u00b6 For each segment of the analysis: This field stores in a cell array the generated Admittance Matrix for each segment. Solver Field \u00b6 For each segment of the analysis: This field stores in a cell array the solvers running in each segment. Auxiliary Tools for Results ( tools ) \u00b6 Finally, this section corresponds to the case when option.tools = true; is used to set simulation conditions. In addition to the fields described above, the following fields will be newly generated. Vabs : Voltage Magnitude \\(\\small (\\lvert V \\rvert)\\) . Vangle : Voltage Phase Angle \\(\\small (\\angle V)\\) . Iabs : Current Magnitude \\(\\small (\\lvert I \\rvert)\\) . Iangle : Current Phase Angle \\(\\small (\\angle I)\\) . P : Active Power \\(\\small (P)\\) . Q : Reactive Power \\(\\small (Q)\\) . These fields can be obtained from the data in out.V and out.I , so they are redundant. Therefore, from the standpoint of capacity, these fields may be considered unnecessary. However, this simulationResult class is implemented to serve as an aid in understanding the contents of the output results. When executed, the following display will appear. Show \"how to use?\" (y/n): %Type `y` and \"enter\" to display. Example - Command Input >> out = net . simulate ([ 0 , 10 ], 'fault' ,{{[ 1 , 1.01 ], 3 }}, 'tools' , true ) 0 | | 10 | = >=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>| ================================== Auxiliary tools for outputting simulation results SimulationResult Class ================================== Show usage?(y/n)\uff1a Note that this class can be executed in two ways: 1. By command input (previous example), and 2. By UI Operation. Example - UI Operation >> out . UIplot Simulation - Examples \u00b6 The following page contains examples of handling the simulating functions explained in this page. Simulation - Examples","title":"Simulating"},{"location":"Reference/Analysis/net_simulate/#simulating","text":"This section explains how to perform the simulations. It explains how to set the simulation conditions and how to read the results. Contents: Simulation Execution Method. Time Argument. Input Argument. Time-Input Relationship. Option Argument. Results. Time Variable. State Variable. Voltage and Current Variable. Global Controller State Response Variable. Global Controller Input Variable. Linear Controller State Response Variable. Linear Controller Input Variable. Busbar Variable. Fault Busbar Variable. Admittance Matrix Variable. Solver Variable. Auxiliary Tools for Results. Simulation Examples","title":"Simulating"},{"location":"Reference/Analysis/net_simulate/#simulation_execution_method","text":"This section explains the function that simulates the power system model, which is defined as a method of the power_network class under the name simulate . The execution method is as follows %To set the options setting. out = net . simulate ( time , option ); %To set the inputs to the system. out = net . simulate ( time , u , u_idx ); %To set both the option setting, and the inputs to the system. out = net . simulate ( time , u , u_idx , option ); Note: For the data structure of the output result out , please refer to the section Results in the latter half of this page. From this point on, the arguments of the function simulate are explained.","title":"Simulation Execution Method"},{"location":"Reference/Analysis/net_simulate/#time_argument","text":"time = [start, end] It specifies the time to run the simulation. For example, if you want to simulate 0-60 seconds, you can specify time=[0,60] .","title":"Time Argument"},{"location":"Reference/Analysis/net_simulate/#input_argument","text":"The Input Argument is composed by the arguments u and u_idx , where u is the input to the system, and u_idx is the device number to which the input is applied. By specifying the value of these arguments, a simulation can be performed with inputs to the system. Now u_idx is explained, while u is explained afterwards. u_idx = [device number] It specifies the device number to which the input is applied. The device number is the number of the busbar connected to the device. As an example here, we consider applying inputs to the devices numbered \"1,16,20\". u_idx = [ 1 , 16 , 20 ]; To set the input values, it is necessary to know the number of ports of the target device and the port number to which the input is given. As for the number of ports, it is obligatory to define a function get_nu in the component class to get the number of input ports, which can be found as follows. >> for idx = [ 1 , 16 , 20 ] nu = net . a_bus { idx }. component . get_nu ; disp ([ 'bus' , num2str ( idx , '%.2d' ), ':nu=' , num2str ( nu ), 'port' ]) end The port number to which the input is applied must be determined by understanding the respective device model and considering the port number corresponding to the parameter to which you wish to add the input. For example, in the IEEE 68-bus model, the component 1 and 16 are assigned the generator_1axis class, so the first input port is set to be an input to the field voltage command value and the second input port to the machine torque command value. On the other hand, the component 20 is of the load_impedance class, so the first input port is set to the command value of the multiplier of the real part of the impedance, and the second to the command value of the multiplier of the imaginary part.","title":"Input Argument"},{"location":"Reference/Analysis/net_simulate/#time-input_relationship","text":"Now, the input to the system ( u ) is defined. The dimension of u is \"the sum of the number of ports of the device to which the input is added \"\u2715\" (times) the number of time indices\". In the previous section the argument time was defined as 1\u27152 array of the simulation start and end times, but if an input signal is specified, then the argument time becomes the index of the time of the input signal. In the following image the time-input relationship is depicted by using a zero-order hold. %Define the arguments time, u, and u_idx as shown above and assign them to the simulate function. out = net . simulate ( time , u , u_idx );","title":"Time-Input Relationship"},{"location":"Reference/Analysis/net_simulate/#option_argument","text":"In this section, the possible values of the option argument are explained. Input Waveform (zero-order hold or first-order hold) ( method ). Zero-Order Hold Input Signal: option . method = 'zoh' ; First-Order Hold Input Signal: option . method = 'foh' ; Code Example %Define time, u, and u_idx as shown above and assign them to the simulate function. %Define the options as 'method' and 'zoh' (zero order hold). out = net . simulate ( time , u , u_idx , 'method' , 'zoh' ); %Define the options as 'method' and 'foh' (first order hold). out = net . simulate ( time , u , u_idx , 'method' , 'foh' ); The image below shows an example of a first order hold. Simulation Linearity ( linear ). Nonlinear Model. option . linear = false ; Approximate Linearized Model. option . linear = true ; Ground Fault ( fault ). No Ground Fault. option . fault = {}; Ground Fault - Example 1. A ground fault occurs on busbar 1 within 1-1.01 sec. option . fault = {{[ 1 , 1.01 ], 1 }}; Ground Fault - Example 2. In addition to the ground fault in Example 1, another ground fault occurs between 5-5.01 seconds on busbars 2 and 3. option . fault = {{[ 1 , 1.01 ], 1 },{[ 5 , 5.01 ],[ 2 , 3 ]}}; Ground Fault - Example 3. In addition to the Example 2, a ground fault occurs between 10-10.01 seconds on busbars 4-10. option . fault = {{[ 1 , 1.01 ], 1 },{[ 5 , 5.01 ],[ 2 , 3 ]},{[ 10 , 10.01 ], 4 : 10 }}; Initial System State Condition ( x0_sys ). Initial value of the system state for the equilibrium point. option . x0_sys = net . x_equilibrium ; Initial Busbar Voltage ( V0 ). Initial value of each busbar voltage for power flow calculation. option . V0 = net . V_equilibrium ; Example: Only the voltage magnitude of busbar 1 is set to be zero \\(\\small (\\lvert V \\rvert = 0)\\) . option . V0 = net . V_equilibrium ; option . V0 ( 1 ) = 0 ; Initial Busbar Current ( I0 ). Initial value of each busbar current for power flow calculation. option . I0 = net . I_equilibrium ; Example: The current phase of busbar 16 is shifted by \\(\\small \\pi/30\\) . option . I0 = net . I_equilibrium ; option . I0 ( 16 ) = option . I0 ( 16 ) * ( cos ( pi / 30 ) + 1 j * sin ( pi / 30 )); Initial Local Controller State ( x0_con_local ). The initial value of the state of each local controller remains at the equilibrium point. option . x0_con_local = tools . vcellfun (@( c ) c . get_x0 (), obj . a_controller_local ) Initial Global Controller State ( x0_con_global ). The initial value of the state of each global controller remains at the equilibrium point. option . x0_con_global = tools . vcellfun (@( c ) c . get_x0 (), obj . a_controller_local ) Error thresholds for Numerical Integration ( AbsTol , RelTol ). Minimal required value: \\(10^{-8}\\) option . AbsTol = 1e-8 ; option . RelTol = 1e-8 ; Note: Since GUILDA uses the Solver \"ode15s\" for numerical integration, please refer to the ODE15S - official documentation for tolerance adjustment. Simulation Report Output Settings ( do_report ). Generate Simulation Report. option . do_report = true ; Don't Generate Simulation Report. option . do_report = false ; Forced Termination Time ( reset_time ). No Forced Termination Time (default value). option . reset_time = inf ; Forced Termination Time - Example: If numerical analysis is not completed within 60 seconds, the analysis is terminated at that point. option . reset_time = 60 ; option . do_retry = false ; Retry Numerical Integration ( do_retry ). Once the forced termination time is reached, retry or not the numerical integration. Retry (default value). option . do_retry = true ; Don't Retry - Example: Please refer to the reset_time condition setting example. Analysis Results Format ( tools ). Output the Results with Format (default value). option . tools = false ; Output the Results without Format. option . tools = true ; The default is to output the analysis results with format. If this option is set to true , the result will be outputted without format, and just as an instance of the class simulationResult . Note: If the simulation is planned to be executed several times, it is recommended to use the default value and output the results with format. Define the Option Argument as a Structure The function simulate allows you to set detailed simulation conditions by assigning various parameters to the argument option in the form of a structure. The procedure for setting simulation conditions and its example code are as follows. Define the variable option as a structure for setting conditions. Select one of the arguments of option corresponding to the condition you want to set and assign a value to it. Assign the defined option variable to the function simulate . %1. Define the variable option as a structure for setting conditions. option = struct (); %2. Set initial values for system status. option . x0_sys = net . x_equilibrium ; %If the frequency deviation (\u0394\u03c9) of the generator in busbar 1 is off by 0.01. option . x0_sys ( 2 ) = option . x0_sys ( 2 ) + 0.01 ; %3.Simulation Execution. time = [ 0 , 60 ]; out = net . simulate ( time , option ); Note: Refer to Network Parameters to see why x0_sys(2) corresponds to the frequency deviation of busbar 1. While the above explains how to define the variable option as a structure, the function simulate also allows to specify individual conditions directly as arguments. For example, suppose you write the following code Define the option Argument as a Structure. option = struct (); %Initial value of frequency deviation (\u0394\u03c9) of the generator of busbar 1 is deviated %from the equilibrium point by 0.01. option . x0_sys = net . x_equilibrium ; option . x0_sys ( 2 ) = option . x0_sys ( 2 ) + 0.01 ; %Ground fault occurs on busbar 5 at 5-5.01s. option . fault = {{[ 5 , 5.01 ], 5 }}; %Simulation time of 0-10 s. out = net . simulate ([ 0 , 10 ], option ); Define the option Argument directly in the simulate Function. Alternatively, the above simulation conditions can also be written as follows option = struct (); %Initial value of frequency deviation (\u0394\u03c9) of the generator of busbar 1 is deviated %from the equilibrium point by 0.01. x0 = net . x_equilibrium ; x0 ( 2 ) = x0 ( 2 ) + 0.01 ; %Simulation time of 0-10 s with a ground fault that occurs on busbar 5 at 5-5.01s. out = net . simulate ([ 0 , 10 ], 'x0_sys' , x0 , 'fault' ,{{[ 5 , 5.01 ], 5 }}); Note: When assigning the option argument directly in the simulate function, the arguments are included in the order net.simulate(...'option', 'value',...) .","title":"Option Argument"},{"location":"Reference/Analysis/net_simulate/#results","text":"This section explains how to read the data in the output result ( out ). In the following image an example is presented with the intention to explain its results ( out ). Simulation Example %The IEEE 68-bus model is defined as the power network. net = network_IEEE68bus ; %The time-input relationship is stablished time = [ 0 , 5 , 20 ]; u_idx = [ 20 , 30 ]; u = ones ( 4 , 1 ) * [ 0 , 0.1 , 0.1 ] %The fault on busbar 10 at 10-10.01 is set. fault = {{[ 10 , 10.01 ], 10 }}; %An AGC global controller is added to all busbars. con = controller_broadcast_PI_AGC ( net , 1 : 16 , 1 : 16 , - 10 , - 500 ); net . add_controller_global ( con ); %The simulation run is stablished. out = net . simulate ( time , u , u_idx , 'fault' , fault )","title":"Results"},{"location":"Reference/Analysis/net_simulate/#time_field_t","text":"This field represents the sampling time of the simulation. It contains an array of \"number of samplings\", which is used in all the other fields ( X,V,I,Xk_global,U_global,U ). Current Example: There are 1455 samplings","title":"Time Field (t)"},{"location":"Reference/Analysis/net_simulate/#state_field_x","text":"This field contains the response data of the status of the devices connected to each bus bar. out.X is a cell array in which each cell corresponds to one device at a time. The dimension of the numeric array is \"number of samplings\" \u2715 \"number of device states\". Current Example: Since the IEEE 68-bus model is used, the busbars 1-16 have a synchronous generator ( generator_1axis ) with 7 states. Thus, the dimension of the numeric array is 1455 \u2715 7. From the busbar 17th only loads are attachd ( load_impedance ), which don't have states. It is possible to call the data of an specific state of a device, for example, the second state of the device connected to busbar 4. plot ( out . t , out . X { 4 }(:, 2 ))","title":"State Field (X)"},{"location":"Reference/Analysis/net_simulate/#voltage_and_current_fields_v_i","text":"These fields contain the responses of the voltage and current of the busbars, respectively. Just like the state field ( out.X ), the voltage and current fields also are a cell array of the same size as the number of busbars in the system model. Each cell contains a numeric array with \"number of samplings\" \u2715 2 (Real Part, Imaginary Part). Current Example: Each field (i.e., Voltage and Current), have 68 cells (busbars), and each cell has the time response (1455 samplings) of the real part and imaginary part. It is possible to call the data of an busbar, for example, to plot the magnitude of the voltage and current on busbar 10 during time 10-10.1s (a fault occurs during this time in this bus, thus the expected behaviour is \\(\\small \\lvert V \\rvert \\to 0; \\lvert I \\rvert \\to \\infty\\) ). %Read the voltage of busbar 10. V10 = out . V { 10 }(:, 1 ) + 1 j * out . V { 10 }(:, 2 ); %Read the current of busbar 10. I10 = out . I { 10 }(:, 1 ) + 1 j * out . I { 10 }(:, 2 ); %Plot the absolute value of the voltage and current of busbar 10. plot ( out . t , abs ( V10 ), out . t , abs ( I10 ), 'LineWidth' , 2 ) legend ({ '$|V|$' , '$|I|$' }, 'Interpreter' , 'latex' ) xlabel ( 'Time [s]' ) ylabel ( 'Magnitude [p.u.]' )","title":"Voltage and Current Fields (V, I)"},{"location":"Reference/Analysis/net_simulate/#global_controller_state_response_field_xk_global","text":"This field contains the global controller state response. Current Example: In this case, the power system with one global controller added was used in the analysis. Thus Xk_global is a 1\u27151 array of cells. The controller class controller_broadcast_PI_AGC has only one state, so the data stored in out.Xk_global{1} is a numeric array with \"number of samples\".","title":"Global Controller State Response Field (Xk_global)"},{"location":"Reference/Analysis/net_simulate/#global_controller_input_field_u_global","text":"This field contains the response of the input value from the global controller. Like out.Xk_global , this field is also a cell array with the same dimension as the number of controllers attached to the power system under analysis. Current Example: The controller added in this example is an AGC controller (reads the frequency deviation of the devices in busbars 1 through 16 and gives a command value to the Mechanical Power ( Pmech ) port of component (added to busbars 1 through 16) to balance the supply and demand of the entire system). In this case, the controller adds inputs to 16 Generators ( generator_1axis ) with 2 input ports each; thus, it has 2*16 = 32 outputs. Therefore, the data in out.U_gloobal{1} shows \"1455 \u2715 32 double\". The correspondence between the input ports and the response data for each device is shown in the figure below, since the devices are specified in ascending order, 1:16 , as shown in the code below. con = controller_broadcast_PI_AGC ( net , 1 : 16 , 1 : 16 , - 10 , - 500 ); Each cell is a 2-dimensional array of numbers. The row direction is the chronological order (samples). The column direction follows the input port order. Current Example: Although the image is small, the first column is all 0 for each cell (i.e., each busbar with a generator). This is because the first input port of the Generators ( generator_1axis ) is the Field Voltage ( Vfield ) and the second port is the Mechanical Power ( Pmech ). The AGC controlle only gives command values to the Mechanical Power ( Pmech ).","title":"Global Controller Input Field (U_global)"},{"location":"Reference/Analysis/net_simulate/#linear_controller_state_response_field_u","text":"This field contains the local controller state response. The data is read in the same way as in the global controller state response field ( U_global ). Current Example: No local controller is added, so the cell array is empty.","title":"Linear Controller State Response Field (U)"},{"location":"Reference/Analysis/net_simulate/#linear_controller_input_field_linear","text":"This field is an index indicating whether the simulation was nonlinear or with an approximate linearization. Nonlinear: out.linear = 0 . Approximate Linearization: out.linear = 1","title":"Linear Controller Input Field (linear)"},{"location":"Reference/Analysis/net_simulate/#internal_processes_to_consinder","text":"Before describing the data the four remaining fields, a brief description of the processing taking place inside the function simulate is pertinent. During the numerical analysis, there is usually a point where it becomes discontinuous. For example, when a discontinuous input is given, or when the conditions are discontinuous (e.g., ground fault: the voltage suddenly drops to zero). In these cases, the solver separates the analysis in two segments, divided by the discontinous point. This means that one solver is dedicated to the first segment of the problem (before the discontuinity), and a new solver is dedicated for the second segment (after the discontinuity). The solver for the second segment starts with the value to which the discontinuity element is applied. Current Example: The input signal of the current example is shown in the following figure. Furthermore, an ground fault occurs between 10 and 10.01 seconds. Thus, in total there are three discontinuous parts: 1. \"The 5-second mark where the input value changes,\". 2. \"The 10-second mark where the ground fault occurs\". 3.\"The 10.01-second mark where the ground fault ends\". Therefore, the numerical analysis is divided into four segments : [0s to 5s], [5s to 10s], [10s to 10.01s], [10.01s to 20s]. With this in mind, the explanation of the remaining fields can be retaken.","title":"Internal Processes to Consinder"},{"location":"Reference/Analysis/net_simulate/#busbar_field","text":"For each segment of the analysis: This field stores the index of the components being analyzed. Note: The busbars with component_empty connected are effectively treated as busbars to which no devices are connected (i.e., non-unit busbars).","title":"Busbar Field"},{"location":"Reference/Analysis/net_simulate/#fault_busbar_field","text":"For each segment of the analysis: This field stores the cell array classification of the index of the busbar where the ground fault occurs.","title":"Fault Busbar Field"},{"location":"Reference/Analysis/net_simulate/#admittance_matrix_variable","text":"For each segment of the analysis: This field stores in a cell array the generated Admittance Matrix for each segment.","title":"Admittance Matrix Variable"},{"location":"Reference/Analysis/net_simulate/#solver_field","text":"For each segment of the analysis: This field stores in a cell array the solvers running in each segment.","title":"Solver Field"},{"location":"Reference/Analysis/net_simulate/#auxiliary_tools_for_results_tools","text":"Finally, this section corresponds to the case when option.tools = true; is used to set simulation conditions. In addition to the fields described above, the following fields will be newly generated. Vabs : Voltage Magnitude \\(\\small (\\lvert V \\rvert)\\) . Vangle : Voltage Phase Angle \\(\\small (\\angle V)\\) . Iabs : Current Magnitude \\(\\small (\\lvert I \\rvert)\\) . Iangle : Current Phase Angle \\(\\small (\\angle I)\\) . P : Active Power \\(\\small (P)\\) . Q : Reactive Power \\(\\small (Q)\\) . These fields can be obtained from the data in out.V and out.I , so they are redundant. Therefore, from the standpoint of capacity, these fields may be considered unnecessary. However, this simulationResult class is implemented to serve as an aid in understanding the contents of the output results. When executed, the following display will appear. Show \"how to use?\" (y/n): %Type `y` and \"enter\" to display. Example - Command Input >> out = net . simulate ([ 0 , 10 ], 'fault' ,{{[ 1 , 1.01 ], 3 }}, 'tools' , true ) 0 | | 10 | = >=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>=>| ================================== Auxiliary tools for outputting simulation results SimulationResult Class ================================== Show usage?(y/n)\uff1a Note that this class can be executed in two ways: 1. By command input (previous example), and 2. By UI Operation. Example - UI Operation >> out . UIplot","title":"Auxiliary Tools for Results (tools)"},{"location":"Reference/Analysis/net_simulate/#simulation_-_examples","text":"The following page contains examples of handling the simulating functions explained in this page. Simulation - Examples","title":" Simulation - Examples"},{"location":"Reference/addController/0TopPage/","text":"Controllers \u00b6 This section explains the most relevant information of the controller class. Since the purpose of GUILDA is \"to provide a numerical simulation environment for students and researchers in the field of Systems and Control Engineering, it is assumed that the main users are those who aim to design controllers. Contents: Add a Controller to the Power Network. Controller Types. Implement the Controller. Example - Automatic Generation Control (AGC). New Controller. Add a Controller to the Power Network \u00b6 Controller Types \u00b6 In GUILDA, the controllers are classified into two categories: local controllers and global controllers. Local Controller: A controller that is added locally to each device. Example: Retrofit controller. Global Controller: A controller for multiple devices. Example: Automatic Generation Control (AGC). Both of these controllers are defined as objects of the controller class. The difference is that the local controller includes the input value of the global controller as an argument. This can be seen in the code, for example with the method \"Controller State Derivative\" ( get_dx_u ), which is defined in the controller class, but it is called differently, depending on the controller type, as follows. Controller State Derivative - Local Controller [ dx , u ] = get_dx_u ( obj , t , x , X , V , I , u_global ) Controller State Derivative - Global Controller [ dx , u ] = get_dx_u ( obj , t , x , X , V , I , []) Implement the Controller \u00b6 Suppose that a local controller is defined as an instance in a variable named con . Note: The way to define the controller class depends on how each function is implemented, so please refer to the documentation of the controller class you intend to use. To add the defined local controller ( con ) to the power network ( net ) use the following net . add_controller_local ( con ); Then a cell array is created in the a_controller_local property of the power_network class, and the controller class variables are listed in the order in which they were added. For the case of a global controller. Suppose that a global controller is defined as an instance in a variable named con . To add the defined global controller ( con ) to the power network ( net ) use the following net . add_controller_global ( con ); Similarly to the local controller case, a cell array is created in the a_controller_global property of the power_network class, and the controller class variables are listed in the order in which they were added. To remove the controllers use the following %Remove the first controller in the cell array of a_controller_local net . remove_controller_local ( 1 ); %Remove the third controller in the cell array of a_controller_global net . remove_controller_global ( 3 ); Example - Automatic Generation Control (AGC) \u00b6 This is an example on how to add the Automatic Generation Control (AGC) ( controller_broadcast_PI_AGC ) to a power network. The AGC controller model observes the frequency deviation of generators \\(\\small (\\Delta \\omega)\\) and gives input to each generator to set the deviation to 0. The usage of this controller class is %Define a AGC controller named \"con\" con = controller_broadcast_PI_AGC_normal ( net , y_idx , u_idx , Kp , Ki ); Input Arguments net : The created power network instance to which the controller is to be added. y_idx : The number of the busbar whose output is to be observed. u_idx : Number of the busbar to which the input is applied. Kp : Proportional gain of the controller. Ki : Integrative gain of the controller. Now, let's implement this controller in the IEEE 68-bus power system model, where generators are added from busbar 1 to busbar 16. For this example, the controller is set to observe the frequency deviations of all 16 generators and provide input to all 16 generators. The steps are: net = network_IEEE68bus Add a controller to an instance of the power_network class that implements the IEEE 68-bus model. y_idx = 1:16 Observe the frequency deviation of the synchronous generators connected from busbars 1 to 16. u_idx = 1:16 Apply input to the synchronous generators connected from busbars 1 to 16. Kp = -10 Ki = -500 Define the Proportional ( Kp ) and Integrative ( Ki ) gains of the controller. %Define a power network instance named \"net\" of the IEEE 68-bus model class. net = network_IEEE68bus ; %Define the AGC controller instance named \"con\" indicating that it will be applied to the \"net\" power network, %will observe from bus 1 to 16, will apply input from bus 1 to 16, with P gain -10, and with I gain -500. con = controller_broadcast_PI_AGC_normal ( net , 1 : 16 , 1 : 16 , - 10 , - 500 ); %Add the defined controller instance to the power network. net . add_controller_global ( con ); This concludes the explanation to add a controller to the power system. New Controller \u00b6 This section explains how to define a new controller model in GUILDA. The methods and properties that should be implemented are summarized in this section (Click on the illustration \u2193). If you want to use a controller model already implemented on GUILDA, you can skip this section.","title":"Controllers"},{"location":"Reference/addController/0TopPage/#controllers","text":"This section explains the most relevant information of the controller class. Since the purpose of GUILDA is \"to provide a numerical simulation environment for students and researchers in the field of Systems and Control Engineering, it is assumed that the main users are those who aim to design controllers. Contents: Add a Controller to the Power Network. Controller Types. Implement the Controller. Example - Automatic Generation Control (AGC). New Controller.","title":"Controllers"},{"location":"Reference/addController/0TopPage/#add_a_controller_to_the_power_network","text":"","title":"Add a Controller to the Power Network"},{"location":"Reference/addController/0TopPage/#controller_types","text":"In GUILDA, the controllers are classified into two categories: local controllers and global controllers. Local Controller: A controller that is added locally to each device. Example: Retrofit controller. Global Controller: A controller for multiple devices. Example: Automatic Generation Control (AGC). Both of these controllers are defined as objects of the controller class. The difference is that the local controller includes the input value of the global controller as an argument. This can be seen in the code, for example with the method \"Controller State Derivative\" ( get_dx_u ), which is defined in the controller class, but it is called differently, depending on the controller type, as follows. Controller State Derivative - Local Controller [ dx , u ] = get_dx_u ( obj , t , x , X , V , I , u_global ) Controller State Derivative - Global Controller [ dx , u ] = get_dx_u ( obj , t , x , X , V , I , [])","title":"Controller Types"},{"location":"Reference/addController/0TopPage/#implement_the_controller","text":"Suppose that a local controller is defined as an instance in a variable named con . Note: The way to define the controller class depends on how each function is implemented, so please refer to the documentation of the controller class you intend to use. To add the defined local controller ( con ) to the power network ( net ) use the following net . add_controller_local ( con ); Then a cell array is created in the a_controller_local property of the power_network class, and the controller class variables are listed in the order in which they were added. For the case of a global controller. Suppose that a global controller is defined as an instance in a variable named con . To add the defined global controller ( con ) to the power network ( net ) use the following net . add_controller_global ( con ); Similarly to the local controller case, a cell array is created in the a_controller_global property of the power_network class, and the controller class variables are listed in the order in which they were added. To remove the controllers use the following %Remove the first controller in the cell array of a_controller_local net . remove_controller_local ( 1 ); %Remove the third controller in the cell array of a_controller_global net . remove_controller_global ( 3 );","title":"Implement the Controller"},{"location":"Reference/addController/0TopPage/#example_-_automatic_generation_control_agc","text":"This is an example on how to add the Automatic Generation Control (AGC) ( controller_broadcast_PI_AGC ) to a power network. The AGC controller model observes the frequency deviation of generators \\(\\small (\\Delta \\omega)\\) and gives input to each generator to set the deviation to 0. The usage of this controller class is %Define a AGC controller named \"con\" con = controller_broadcast_PI_AGC_normal ( net , y_idx , u_idx , Kp , Ki ); Input Arguments net : The created power network instance to which the controller is to be added. y_idx : The number of the busbar whose output is to be observed. u_idx : Number of the busbar to which the input is applied. Kp : Proportional gain of the controller. Ki : Integrative gain of the controller. Now, let's implement this controller in the IEEE 68-bus power system model, where generators are added from busbar 1 to busbar 16. For this example, the controller is set to observe the frequency deviations of all 16 generators and provide input to all 16 generators. The steps are: net = network_IEEE68bus Add a controller to an instance of the power_network class that implements the IEEE 68-bus model. y_idx = 1:16 Observe the frequency deviation of the synchronous generators connected from busbars 1 to 16. u_idx = 1:16 Apply input to the synchronous generators connected from busbars 1 to 16. Kp = -10 Ki = -500 Define the Proportional ( Kp ) and Integrative ( Ki ) gains of the controller. %Define a power network instance named \"net\" of the IEEE 68-bus model class. net = network_IEEE68bus ; %Define the AGC controller instance named \"con\" indicating that it will be applied to the \"net\" power network, %will observe from bus 1 to 16, will apply input from bus 1 to 16, with P gain -10, and with I gain -500. con = controller_broadcast_PI_AGC_normal ( net , 1 : 16 , 1 : 16 , - 10 , - 500 ); %Add the defined controller instance to the power network. net . add_controller_global ( con ); This concludes the explanation to add a controller to the power system.","title":"Example - Automatic Generation Control (AGC)"},{"location":"Reference/addController/0TopPage/#new_controller","text":"This section explains how to define a new controller model in GUILDA. The methods and properties that should be implemented are summarized in this section (Click on the illustration \u2193). If you want to use a controller model already implemented on GUILDA, you can skip this section.","title":"New Controller"},{"location":"Reference/addController/NewController/","text":"New Controller \u00b6 This section explains how to define a new controller model in GUILDA. The methods and properties that should be implemented are summarized in this section. Creating a new controller model in GUILDA means creating an \"m-file\" that defines a new child class from the controller class. This page explains how to define this child class file. Contents: The Controller Class. Define a New Controller. Abstract Methods. Required Arguments Required Abstract Methods. Recommended Abstract Methods. The Controller Class \u00b6 The controller class defines several functions that should be provided in a controller model for analysis. By inheriting the properties from the already defined controller class in GUILDA, newly created controllers will automatically have these functions. However, even though several functions are inherited from the controller class, still other functions are required to define the controller's algorithm. Such functions should be added to the controller instance as abstract methods. Fore more information on the source code of the controller class, please refer to Source Code Explanation . Define a New Controller \u00b6 In this page, a new controller named \"myController.m\" will be created and used as an example of the process of defining a new controller. Note: When creating a new controller, it is recommended that a description and how to execute the newly defined controller is included as a comment at the beginning. The general process to create a new controller class is Inherit the functions from the already defined controller class. To do this use the code myController < controller. Define the required arguments of the new controller as variables of properties (usually, target bus, and observable bus). For more information go to \"required arguments\". Define the required functions as methods that define the control algorithm of the new controller. The following code block shows the general structure of these 3 requirements as sections. myController.m %Definition of new controller class as a child class. classdef myController < controller %Description of the controller to be implemented. %Explanation of state variables, inputs, and outputs. %Description on how to execute the constructor of this class and set its arguments. properties %Define the necessary parameters here. end methods %Define the methods here. function obj = myController ( arg1,arg2,... ) %Write the code. end %Required method: Controller State Derivative. function [dx, u] = get_dx_u ( obj, x, X, V, I, U_global ) %Write the code. end %Required method: Controller State Order. function nx = get_nx ( obj ) %Write the code. end %Recommended method: Approximate Linearization. function [A, BX, BV, BI, Bu, C, DX, DV, DI, Du] = get_linear_matrix ( obj ) %Write the code. end %Recommended method: Linear Controller State Derivation. function [dx, u] = get_dx_u_linear ( obj, t, x, X, V, U_global ) %Write code here. end end end Abstract Methods \u00b6 The abstract methods are the set of required functions to define the behaviour of the controller. In this section the two required arguments, one required method, along with three recommended methods to be included are explained. Required Arguments \u00b6 idx_input : Busbar number to which the output signal of the controller (i.e., the input signal to the system) are applied. idx_observe : Busbar number observed by the controller. Required Abstract Methods \u00b6 Controller State Derivative This method is used to obtain the derivative of the controller state \\(\\small (x)\\) ; and the output signal \\((\\small u)\\) (i.e., the input signal to the system). Class Structure: [dx, u] = get_dx_u(obj, x, X, V, I, U_global) Note: The following notation is different to the ones used in other classes, e.g., Component class. Input Arguments x \uff1aController state \\(\\small (x)\\) . X \uff1aState of the Device connected to each bus \\(\\small (X)\\) . V \uff1aBusbar Voltage \\(\\small (V)\\) ([real part; imaginarty part]). I \uff1aBusbar Current \\(\\small (I)\\) ([real part; imaginarty part]). U_global \uff1a Input signals applied to each bus by the global controller \\(\\small (U)\\) . The controller model can only observe the above parameters. Therefore, even if there are other physical quantities required, they will have to be calculated on their own from the values of the arguments. Output Parameters dx \uff1aDertivative of the controller state \\(\\small (\\dot{x})\\) . u \uff1aOutput signal of the controller (i.e., input signal to the system) \\(\\small (u)\\) . Note: The controller class is commonly inherited by the global controller, retrofit controller, and other controllers. Therefore, when creating a distributed controller, it is necessary to explicitly write which signals may be referenced and which signals may not be referenced, in the derived class. It is not possible to reference the state of other controllers. If communication between controllers is required, they must be implemented as a single controller. Controller State Order This method is used to obtain the order (dimension) of the controller state. Class Structure: nx = get_nx(obj) Input Arguments None Output Parameters nx : Oder of the controller state. Recommended Abstract Methods \u00b6 The newly defined controller can be implemented without the following methods; however, these are necessary for performing analysis with an approximate linearization of the power system model. Linearized Controller This method is used to obtained a linearized controller that complies with the following expressions \\[ \\dot{x}=Ax+B_X (X-X^*)+B_V (V-V^*)+B_I (I-I^*)+B_u U_{global} \\] \\[ u=Cx+D_X (X-X^*)+D_V (V-V^*)+D_I (I-I^*)+D_u U_{global} \\] Note: The terms marked with \" \\(*\\) \" (e.g., \\(X^*\\) ), correspond to the equilibrium point of such property. Class Structure: [A, BX, BV, BI, Bu, C, DX, DV, DI, DU] = get_linear_matrix(obj) Input Arguments obj : The nonlinear controller. Output Arguments A \uff1aA matrix of controllers. BX \uff1aB matrix of the controller (regarding the stacked vector of bus states to be observed). BV \uff1aB matrix of the controller (regarding the stacked vector of voltages on all buses). BI \uff1aB matrix of the controller (regarding the stacked vector of currents on all buses). Bu \uff1aB matrix of the controller (regarding the stacked vector of input signals to all buses generated by the global controller). C \uff1aC matrix of controller. DX \uff1aD matrix of the controller (with respect to the bus state vector to be observed). DV \uff1aD matrix of the controller (regarding the stacked vector of voltages on all buses). DI \uff1aD matrix of the controller (regarding the stacked vector of currents on all buses). Du \uff1aD matrix of the controller (regarding the stacked vector of input signals to all buses generated by the global controller). Linear Controller State Derivation This method is used to obtain the derivative of the state \\(\\small (\\dot{x})\\) of the linearized controller, as well as its input \\(\\small (u)\\) . Class Structure: [dx, u] = get_dx_u_linear(obj, t, x, X, V, U_global) Input Arguments t : Time \\(\\small (t)\\) . x \uff1aController state \\(\\small (x)\\) . X \uff1aState of the Device connected to each bus \\(\\small (X)\\) . V \uff1aBusbar Voltage \\(\\small (V)\\) ([real part; imaginarty part]). I \uff1aBusbar Current \\(\\small (I)\\) ([real part; imaginarty part]). U_global \uff1a Input signals applied to each bus by the global controller \\(\\small (U)\\) . The controller model can only observe the above parameters. Therefore, even if there are other physical quantities required, they will have to be calculated on their own from the values of the arguments. Output Parameters dx \uff1aDertivative of the controller state \\(\\small (\\dot{x})\\) . u \uff1aOutput signal of the controller (i.e., input signal to the system) \\(\\small (u)\\) .","title":"New Controller"},{"location":"Reference/addController/NewController/#new_controller","text":"This section explains how to define a new controller model in GUILDA. The methods and properties that should be implemented are summarized in this section. Creating a new controller model in GUILDA means creating an \"m-file\" that defines a new child class from the controller class. This page explains how to define this child class file. Contents: The Controller Class. Define a New Controller. Abstract Methods. Required Arguments Required Abstract Methods. Recommended Abstract Methods.","title":"New Controller"},{"location":"Reference/addController/NewController/#the_controller_class","text":"The controller class defines several functions that should be provided in a controller model for analysis. By inheriting the properties from the already defined controller class in GUILDA, newly created controllers will automatically have these functions. However, even though several functions are inherited from the controller class, still other functions are required to define the controller's algorithm. Such functions should be added to the controller instance as abstract methods. Fore more information on the source code of the controller class, please refer to Source Code Explanation .","title":"The Controller Class"},{"location":"Reference/addController/NewController/#define_a_new_controller","text":"In this page, a new controller named \"myController.m\" will be created and used as an example of the process of defining a new controller. Note: When creating a new controller, it is recommended that a description and how to execute the newly defined controller is included as a comment at the beginning. The general process to create a new controller class is Inherit the functions from the already defined controller class. To do this use the code myController < controller. Define the required arguments of the new controller as variables of properties (usually, target bus, and observable bus). For more information go to \"required arguments\". Define the required functions as methods that define the control algorithm of the new controller. The following code block shows the general structure of these 3 requirements as sections. myController.m %Definition of new controller class as a child class. classdef myController < controller %Description of the controller to be implemented. %Explanation of state variables, inputs, and outputs. %Description on how to execute the constructor of this class and set its arguments. properties %Define the necessary parameters here. end methods %Define the methods here. function obj = myController ( arg1,arg2,... ) %Write the code. end %Required method: Controller State Derivative. function [dx, u] = get_dx_u ( obj, x, X, V, I, U_global ) %Write the code. end %Required method: Controller State Order. function nx = get_nx ( obj ) %Write the code. end %Recommended method: Approximate Linearization. function [A, BX, BV, BI, Bu, C, DX, DV, DI, Du] = get_linear_matrix ( obj ) %Write the code. end %Recommended method: Linear Controller State Derivation. function [dx, u] = get_dx_u_linear ( obj, t, x, X, V, U_global ) %Write code here. end end end","title":"Define a New Controller"},{"location":"Reference/addController/NewController/#abstract_methods","text":"The abstract methods are the set of required functions to define the behaviour of the controller. In this section the two required arguments, one required method, along with three recommended methods to be included are explained.","title":"Abstract Methods"},{"location":"Reference/addController/NewController/#required_arguments","text":"idx_input : Busbar number to which the output signal of the controller (i.e., the input signal to the system) are applied. idx_observe : Busbar number observed by the controller.","title":"Required Arguments"},{"location":"Reference/addController/NewController/#required_abstract_methods","text":"Controller State Derivative This method is used to obtain the derivative of the controller state \\(\\small (x)\\) ; and the output signal \\((\\small u)\\) (i.e., the input signal to the system). Class Structure: [dx, u] = get_dx_u(obj, x, X, V, I, U_global) Note: The following notation is different to the ones used in other classes, e.g., Component class. Input Arguments x \uff1aController state \\(\\small (x)\\) . X \uff1aState of the Device connected to each bus \\(\\small (X)\\) . V \uff1aBusbar Voltage \\(\\small (V)\\) ([real part; imaginarty part]). I \uff1aBusbar Current \\(\\small (I)\\) ([real part; imaginarty part]). U_global \uff1a Input signals applied to each bus by the global controller \\(\\small (U)\\) . The controller model can only observe the above parameters. Therefore, even if there are other physical quantities required, they will have to be calculated on their own from the values of the arguments. Output Parameters dx \uff1aDertivative of the controller state \\(\\small (\\dot{x})\\) . u \uff1aOutput signal of the controller (i.e., input signal to the system) \\(\\small (u)\\) . Note: The controller class is commonly inherited by the global controller, retrofit controller, and other controllers. Therefore, when creating a distributed controller, it is necessary to explicitly write which signals may be referenced and which signals may not be referenced, in the derived class. It is not possible to reference the state of other controllers. If communication between controllers is required, they must be implemented as a single controller. Controller State Order This method is used to obtain the order (dimension) of the controller state. Class Structure: nx = get_nx(obj) Input Arguments None Output Parameters nx : Oder of the controller state.","title":"Required Abstract Methods"},{"location":"Reference/addController/NewController/#recommended_abstract_methods","text":"The newly defined controller can be implemented without the following methods; however, these are necessary for performing analysis with an approximate linearization of the power system model. Linearized Controller This method is used to obtained a linearized controller that complies with the following expressions \\[ \\dot{x}=Ax+B_X (X-X^*)+B_V (V-V^*)+B_I (I-I^*)+B_u U_{global} \\] \\[ u=Cx+D_X (X-X^*)+D_V (V-V^*)+D_I (I-I^*)+D_u U_{global} \\] Note: The terms marked with \" \\(*\\) \" (e.g., \\(X^*\\) ), correspond to the equilibrium point of such property. Class Structure: [A, BX, BV, BI, Bu, C, DX, DV, DI, DU] = get_linear_matrix(obj) Input Arguments obj : The nonlinear controller. Output Arguments A \uff1aA matrix of controllers. BX \uff1aB matrix of the controller (regarding the stacked vector of bus states to be observed). BV \uff1aB matrix of the controller (regarding the stacked vector of voltages on all buses). BI \uff1aB matrix of the controller (regarding the stacked vector of currents on all buses). Bu \uff1aB matrix of the controller (regarding the stacked vector of input signals to all buses generated by the global controller). C \uff1aC matrix of controller. DX \uff1aD matrix of the controller (with respect to the bus state vector to be observed). DV \uff1aD matrix of the controller (regarding the stacked vector of voltages on all buses). DI \uff1aD matrix of the controller (regarding the stacked vector of currents on all buses). Du \uff1aD matrix of the controller (regarding the stacked vector of input signals to all buses generated by the global controller). Linear Controller State Derivation This method is used to obtain the derivative of the state \\(\\small (\\dot{x})\\) of the linearized controller, as well as its input \\(\\small (u)\\) . Class Structure: [dx, u] = get_dx_u_linear(obj, t, x, X, V, U_global) Input Arguments t : Time \\(\\small (t)\\) . x \uff1aController state \\(\\small (x)\\) . X \uff1aState of the Device connected to each bus \\(\\small (X)\\) . V \uff1aBusbar Voltage \\(\\small (V)\\) ([real part; imaginarty part]). I \uff1aBusbar Current \\(\\small (I)\\) ([real part; imaginarty part]). U_global \uff1a Input signals applied to each bus by the global controller \\(\\small (U)\\) . The controller model can only observe the above parameters. Therefore, even if there are other physical quantities required, they will have to be calculated on their own from the values of the arguments. Output Parameters dx \uff1aDertivative of the controller state \\(\\small (\\dot{x})\\) . u \uff1aOutput signal of the controller (i.e., input signal to the system) \\(\\small (u)\\) .","title":"Recommended Abstract Methods"},{"location":"Reference/defineNet/0TopPage/","text":"Power System Model (Detailed) \u00b6 This section provides a detailed explanation on how to define the power system models in GUILDA. As mentioned in the previous page, GUILDA can use the two predefined networks (i.e., 3-bus and 68-bus), as well as new defined ones. The objective of this section is to define a new network. In GUILDA, the power system model is handled in the following manner: Stored in properties by using classes. Analyzed by modularized process as methods. The class that implements this power system model is defined in GUILDA with the class name power_network . In the following explanations, the variable that stores this power_network class will be refered to as net in the code explanations. For further information on the details of the power_network class, please refer to the Source Code Explanation page. Contents: Predefined Power System Models. New Power System Model. New Components. Predefined Power System Models \u00b6 To define the power system model to be used as one of the predefined in GUILDA use the following codes. %Predefined Power System Models. net = network_sample3bus ; %Load the predefined 3-bus system model. net = network_IEEE68bus ; %Load the predefined 68-bus system model. The way it works is that these commands call a function file that contains a series of instructions to define an already defined power system model (i.e., 3-bus or 68-bus). New Power System Model \u00b6 In this section it is explained how to create a new power system model and define it as the power_network class. In GUILDA, a power system model is composed of Buses (Interconnection points) Branches (Transmission Lines) Components Generators Loads Currently, GUILDA implements the classes generator_1axis for Generators and load_impedance for Loads. These classes are the ones used to define the new power system model in this explanation (Click on the illustration \u2193). New Components \u00b6 In the previous section, a new power system model was defined using only the already implemented components in GUILDA (i.e., generator_1axis and load_impedance ). In this section it is explained how to implement a new equipment model with new dynamic characteristics (Click on the illustration \u2193).","title":"Power System Model (Detailed)"},{"location":"Reference/defineNet/0TopPage/#power_system_model_detailed","text":"This section provides a detailed explanation on how to define the power system models in GUILDA. As mentioned in the previous page, GUILDA can use the two predefined networks (i.e., 3-bus and 68-bus), as well as new defined ones. The objective of this section is to define a new network. In GUILDA, the power system model is handled in the following manner: Stored in properties by using classes. Analyzed by modularized process as methods. The class that implements this power system model is defined in GUILDA with the class name power_network . In the following explanations, the variable that stores this power_network class will be refered to as net in the code explanations. For further information on the details of the power_network class, please refer to the Source Code Explanation page. Contents: Predefined Power System Models. New Power System Model. New Components.","title":"Power System Model (Detailed)"},{"location":"Reference/defineNet/0TopPage/#predefined_power_system_models","text":"To define the power system model to be used as one of the predefined in GUILDA use the following codes. %Predefined Power System Models. net = network_sample3bus ; %Load the predefined 3-bus system model. net = network_IEEE68bus ; %Load the predefined 68-bus system model. The way it works is that these commands call a function file that contains a series of instructions to define an already defined power system model (i.e., 3-bus or 68-bus).","title":"Predefined Power System Models"},{"location":"Reference/defineNet/0TopPage/#new_power_system_model","text":"In this section it is explained how to create a new power system model and define it as the power_network class. In GUILDA, a power system model is composed of Buses (Interconnection points) Branches (Transmission Lines) Components Generators Loads Currently, GUILDA implements the classes generator_1axis for Generators and load_impedance for Loads. These classes are the ones used to define the new power system model in this explanation (Click on the illustration \u2193).","title":"New Power System Model"},{"location":"Reference/defineNet/0TopPage/#new_components","text":"In the previous section, a new power system model was defined using only the already implemented components in GUILDA (i.e., generator_1axis and load_impedance ). In this section it is explained how to implement a new equipment model with new dynamic characteristics (Click on the illustration \u2193).","title":"New Components"},{"location":"Reference/defineNet/NewComponent/","text":"New Components \u00b6 This page provides a detailed explanation on how to define a component class. Creating a new equipment model in GUILDA means creating an \"m-file\" that defines a new child class from the component class. This page explains how to define this child class file. Contents : The Component Class. Define a New Component. Abstract Methods. Required Abstract Methods Recommended Abstract Methods. The Component Class \u00b6 The component class defines several functions that should be provided in a device model (e.g., a synchronous generator) for analysis. By inheriting the properties from the already defined component class, newly created equipment models will automatically have these functions. However, even though several functions are inherited from the component class, still other functions are required to define the dynamic characteristics of the new component. Such functions are added to the component class as abstract methods. Fore more information on the source code of the component class, please refer to Source Code Explanation . Define a New Component \u00b6 In this page, a new component named \"myMachine.m\" will be created and used as an example of the process of defining a new component. Note: When creating a new component, it is recommended that a description and how to execute the newly define component is included as a comment at the beginning. The general process to create a new component class is Inherit the functions from the already defined component class. To do this use the code myMachine < component . Define the required parameters of the new component as variables of properties . Note: When defining the required parameters of the new component, it is recommended to name it as \"parameter\" Define the required functions as methods that define the dynamics characteristics of the new component. The following code block shows the general structure of these 3 requirements as sections. myMachine.m %Definition of new component class as a child class. classdef myMachine < component %Description of the model to be implemented. %Explanation of state variables, inputs, and outputs. %Description on how to execute the constructor of this class and set its arguments. properties %Define the necessary parameters here. x_equilibrium \u3000 %etc.. end methods %Define the methods here function obj = myMachine ( arg1,arg2,... ) %Write the code. end %Required method: Set Equilibrium. function x = set_equilibrium ( obj,Veq, Ieq ) %Write the code. end %Required method: Input State Order. function nu = get_nu ( obj ) %Write the code. end %Required method: State Derivative. function [dx,constraint] = get_dx_constraint ( obj,t,x,V,I,u ) %Write the code. end %Recommended method: Approximate Linearization. function [A,B,C,D,BV,DV,BI,DI,R,S] = get_linear_matrix ( obj,x_st,Vst ) %Write the code. end %Recommended method: Linear State Derivation. function [dx,con] = get_dx_constraint_linear ( obj,t,x,V,I,u ) %Write the code. end %Recommended method: Name Tag. function name_tag = get_x_name ( obj ) %Write the code. end end end Abstract Methods \u00b6 The abstract methods are the set of required functions to define the dynamics of a component. In this section three required methods, along with three recommended methods to be included are explained. Required Abstract Methods \u00b6 Set Equilibrium This method performs the initialization processing, determines the equilibrium points via power flow calculation (equilibrium voltage \\(\\small (V_{eq})\\) and equilibrium current \\(\\small (I_{eq})\\) ), and derives the equilibrium state. Class Structure: x = set_equilibrium(obj,Veq,Ieq) Input Arguments Veq : Equilibrium point of the voltage (complex number) \\(-\\) obtained from the power flow calculation. Ieq : Equilibrium point of the current (complex number) \\(-\\) obtained from the power flow calculation. Output Parameters x \uff1aEquilibrium state corresponding to the specified equilibrium point. Input State Order This method is used to determine the order of the input state ( u ). Class Structure nu = get_nu(obj) Input Arguments None Output Parameters nu \uff1aOrder of input state ( u ). State Derivative This method is used to obtain the derivative of the state \\(\\small (x)\\) ; when an input is applied it also provides the current \\(\\small (I)\\) to obtain the constraints (see below). Class Structure: [dx,constraint] = get_dx_constraint(obj,t, x, V, I, u) Input Arguments t : Time \\(\\small (t)\\) . x : State \\(\\small (x)\\) . V : Busbar Voltage \\(\\small (V)\\) ([real part; imaginary part]). I : Busbar Current \\(\\small (I)\\) ([real part; imaginary part]). u : Input Signal \\(\\small (u)\\) . Output Variables dx \uff1aDerivative of the State \\(\\small (\\dot{x})\\) . constraint \uff1aThe difference between the actual busbar's current \\(\\small (I)\\) and the derived one from the provided arguments \"state\" \\(\\small (x)\\) and \"voltage\" \\(\\small (V)\\) . The constraint condition is that the difference between both currents \\(\\small (I)\\) should be zero. Recommended Abstract Methods \u00b6 The newly defined component can be implemented without the following methods; however, these are necessary for performing analysis with an approximate linearization of the power system model. Approximate Linearization This method, as the name states, allows to linearize the power system model. It returns the system matrices \\(\\small [A, B, C, D, BV, DV, BI, DI, R, S]\\) of the linearized state-space representation as in the following equation. \\begin{align*} \\dot{x} &= A(x-x^*)+B(u-u^*)+B_V(V-V^*)+B_I(I-I^*)\uff0bRd\\\\ 0 &= C(x-x^*)+D(u-u^*)+D_V(V-V^*)+D_I(I-I^*)\\\\ z &= S(x^*-x) \\end{align*} Class Structure: [A, B, C, D, BV, DV, BI, DI, R, S] = get_linear_matrix(obj,x_st, Vst) Input Arguments x_st \uff1aEquilibrium point of the state variable. Vst \uff1aEquilibrium point of the voltage \\(-\\) obtained from the power flow calculation. Output Arguments [A, B, C, D, BV, DV, BI, DI, R, S] \uff1aSystem matrix of the state-space model shown above. R : Disturbance matrix. S : Output of the evaluation function. Note: Both R and S are needed when designing a control system; however, they are different from the properties of the device. Therefore, when simply performing a simulation without controller, it is safe to use R and S as zero matrices. Linear State Derivation This method is the linearized version of the \"State Derivate\" ( get_dx_constraint ) method. Note: To implement this method a linearized state-space model is needed. For it the method \"Approximate Linearization\" ( get_linear_matrix ) is available. Class Structure: [dx, con] = get_dx_constraint_linear(obj,t, x, V, I, u) . Input Arguments t : Time \\(\\small (t)\\) . x : State \\(\\small (x)\\) . V : Busbar Voltage \\(\\small (V)\\) ([real part; imaginary part]). I : Busbar Current \\(\\small (I)\\) ([real part; imaginary part]). u : Input Signal \\(\\small (u)\\) . Output arguments dx \uff1aDerivative of the State \\(\\small (\\dot{x})\\) . con \uff1aThe difference between the actual busbar's current \\(\\small (I)\\) and the derived one from the provided arguments \"state\" \\(\\small (x)\\) and \"voltage\" \\(\\small (V)\\) . The constraint condition is that the difference between both currents \\(\\small (I)\\) should be zero. Name Tag This method allows to assign names to each entry of the state vector \\(\\small (x)\\) of the component. Class Structure: name_tag = get_x_name(obj) Input Arguments None Output Parameters Cell array of strings indicating each state name. Example: name_tag = {'x1','x2','x3'}; >> out = net . simulate ( t , varargin , 'tools' , true ); This is useful for automatically classifying and plotting the states based on the given names, instead of just having \"state1, state2, ...\". For more information on how to use this function, please refer to Simulating , as it is mainly presented and used there. This concludes the explanation of defining new components.","title":"New Components"},{"location":"Reference/defineNet/NewComponent/#new_components","text":"This page provides a detailed explanation on how to define a component class. Creating a new equipment model in GUILDA means creating an \"m-file\" that defines a new child class from the component class. This page explains how to define this child class file. Contents : The Component Class. Define a New Component. Abstract Methods. Required Abstract Methods Recommended Abstract Methods.","title":"New Components"},{"location":"Reference/defineNet/NewComponent/#the_component_class","text":"The component class defines several functions that should be provided in a device model (e.g., a synchronous generator) for analysis. By inheriting the properties from the already defined component class, newly created equipment models will automatically have these functions. However, even though several functions are inherited from the component class, still other functions are required to define the dynamic characteristics of the new component. Such functions are added to the component class as abstract methods. Fore more information on the source code of the component class, please refer to Source Code Explanation .","title":"The Component Class"},{"location":"Reference/defineNet/NewComponent/#define_a_new_component","text":"In this page, a new component named \"myMachine.m\" will be created and used as an example of the process of defining a new component. Note: When creating a new component, it is recommended that a description and how to execute the newly define component is included as a comment at the beginning. The general process to create a new component class is Inherit the functions from the already defined component class. To do this use the code myMachine < component . Define the required parameters of the new component as variables of properties . Note: When defining the required parameters of the new component, it is recommended to name it as \"parameter\" Define the required functions as methods that define the dynamics characteristics of the new component. The following code block shows the general structure of these 3 requirements as sections. myMachine.m %Definition of new component class as a child class. classdef myMachine < component %Description of the model to be implemented. %Explanation of state variables, inputs, and outputs. %Description on how to execute the constructor of this class and set its arguments. properties %Define the necessary parameters here. x_equilibrium \u3000 %etc.. end methods %Define the methods here function obj = myMachine ( arg1,arg2,... ) %Write the code. end %Required method: Set Equilibrium. function x = set_equilibrium ( obj,Veq, Ieq ) %Write the code. end %Required method: Input State Order. function nu = get_nu ( obj ) %Write the code. end %Required method: State Derivative. function [dx,constraint] = get_dx_constraint ( obj,t,x,V,I,u ) %Write the code. end %Recommended method: Approximate Linearization. function [A,B,C,D,BV,DV,BI,DI,R,S] = get_linear_matrix ( obj,x_st,Vst ) %Write the code. end %Recommended method: Linear State Derivation. function [dx,con] = get_dx_constraint_linear ( obj,t,x,V,I,u ) %Write the code. end %Recommended method: Name Tag. function name_tag = get_x_name ( obj ) %Write the code. end end end","title":"Define a New Component"},{"location":"Reference/defineNet/NewComponent/#abstract_methods","text":"The abstract methods are the set of required functions to define the dynamics of a component. In this section three required methods, along with three recommended methods to be included are explained.","title":"Abstract Methods"},{"location":"Reference/defineNet/NewComponent/#required_abstract_methods","text":"Set Equilibrium This method performs the initialization processing, determines the equilibrium points via power flow calculation (equilibrium voltage \\(\\small (V_{eq})\\) and equilibrium current \\(\\small (I_{eq})\\) ), and derives the equilibrium state. Class Structure: x = set_equilibrium(obj,Veq,Ieq) Input Arguments Veq : Equilibrium point of the voltage (complex number) \\(-\\) obtained from the power flow calculation. Ieq : Equilibrium point of the current (complex number) \\(-\\) obtained from the power flow calculation. Output Parameters x \uff1aEquilibrium state corresponding to the specified equilibrium point. Input State Order This method is used to determine the order of the input state ( u ). Class Structure nu = get_nu(obj) Input Arguments None Output Parameters nu \uff1aOrder of input state ( u ). State Derivative This method is used to obtain the derivative of the state \\(\\small (x)\\) ; when an input is applied it also provides the current \\(\\small (I)\\) to obtain the constraints (see below). Class Structure: [dx,constraint] = get_dx_constraint(obj,t, x, V, I, u) Input Arguments t : Time \\(\\small (t)\\) . x : State \\(\\small (x)\\) . V : Busbar Voltage \\(\\small (V)\\) ([real part; imaginary part]). I : Busbar Current \\(\\small (I)\\) ([real part; imaginary part]). u : Input Signal \\(\\small (u)\\) . Output Variables dx \uff1aDerivative of the State \\(\\small (\\dot{x})\\) . constraint \uff1aThe difference between the actual busbar's current \\(\\small (I)\\) and the derived one from the provided arguments \"state\" \\(\\small (x)\\) and \"voltage\" \\(\\small (V)\\) . The constraint condition is that the difference between both currents \\(\\small (I)\\) should be zero.","title":"Required Abstract Methods"},{"location":"Reference/defineNet/NewComponent/#recommended_abstract_methods","text":"The newly defined component can be implemented without the following methods; however, these are necessary for performing analysis with an approximate linearization of the power system model. Approximate Linearization This method, as the name states, allows to linearize the power system model. It returns the system matrices \\(\\small [A, B, C, D, BV, DV, BI, DI, R, S]\\) of the linearized state-space representation as in the following equation. \\begin{align*} \\dot{x} &= A(x-x^*)+B(u-u^*)+B_V(V-V^*)+B_I(I-I^*)\uff0bRd\\\\ 0 &= C(x-x^*)+D(u-u^*)+D_V(V-V^*)+D_I(I-I^*)\\\\ z &= S(x^*-x) \\end{align*} Class Structure: [A, B, C, D, BV, DV, BI, DI, R, S] = get_linear_matrix(obj,x_st, Vst) Input Arguments x_st \uff1aEquilibrium point of the state variable. Vst \uff1aEquilibrium point of the voltage \\(-\\) obtained from the power flow calculation. Output Arguments [A, B, C, D, BV, DV, BI, DI, R, S] \uff1aSystem matrix of the state-space model shown above. R : Disturbance matrix. S : Output of the evaluation function. Note: Both R and S are needed when designing a control system; however, they are different from the properties of the device. Therefore, when simply performing a simulation without controller, it is safe to use R and S as zero matrices. Linear State Derivation This method is the linearized version of the \"State Derivate\" ( get_dx_constraint ) method. Note: To implement this method a linearized state-space model is needed. For it the method \"Approximate Linearization\" ( get_linear_matrix ) is available. Class Structure: [dx, con] = get_dx_constraint_linear(obj,t, x, V, I, u) . Input Arguments t : Time \\(\\small (t)\\) . x : State \\(\\small (x)\\) . V : Busbar Voltage \\(\\small (V)\\) ([real part; imaginary part]). I : Busbar Current \\(\\small (I)\\) ([real part; imaginary part]). u : Input Signal \\(\\small (u)\\) . Output arguments dx \uff1aDerivative of the State \\(\\small (\\dot{x})\\) . con \uff1aThe difference between the actual busbar's current \\(\\small (I)\\) and the derived one from the provided arguments \"state\" \\(\\small (x)\\) and \"voltage\" \\(\\small (V)\\) . The constraint condition is that the difference between both currents \\(\\small (I)\\) should be zero. Name Tag This method allows to assign names to each entry of the state vector \\(\\small (x)\\) of the component. Class Structure: name_tag = get_x_name(obj) Input Arguments None Output Parameters Cell array of strings indicating each state name. Example: name_tag = {'x1','x2','x3'}; >> out = net . simulate ( t , varargin , 'tools' , true ); This is useful for automatically classifying and plotting the states based on the given names, instead of just having \"state1, state2, ...\". For more information on how to use this function, please refer to Simulating , as it is mainly presented and used there. This concludes the explanation of defining new components.","title":"Recommended Abstract Methods"},{"location":"Reference/defineNet/NewPowerNetwork/","text":"New Power System Model \u00b6 This page provides a detailed explanation on how to define a power system model. For a simpler explanation please refer to Power System Models . In this section it is explained how to create a new 3-bus power system model and define it as the power_network class. This explanation uses the already defined components for Generators ( generator_1axis ) and for Loads ( load_impedance ). Contents: Network Definition. Branch Definition. Network Parameters. Busbar Definition. Slack Bus. PV Bus. PQ Bus. Component Definition. Generator. Load. Complete Code. Power System Model Definition \u00b6 To define a network, the power_network class must be assigned to a variable. For this example a variable named net is used. The class is assigned to the variable in the following manner net = power_network (); %Class assigned to the variable; however, no network is yet defined. The power_network class has now been assigned to the variable net and is ready to be used. Note that at this point no component has been assigned, thus the network is still empty. In the following sections various elements will be added to the power network ( net ). Such elements are branches, busbars, and components (generators and loads). Branch Definition \u00b6 Branches in GUILDA represent power transmission lines between busbars. The information of these transmission lines is stored as a table . The parameters of interest are bus_from , bus_to : Busbar number that the transmission line connects from and to, respectively. x_real , x_imag : Real and imaginary part of the transmission line's impedance \\(\\small (Z)\\) , respectively. The reciprocal of this value is the admittance \\(\\small (Y)\\) . y : Ground capacitance. tap , phase : Phase Adjustment Transformer Parameters. For example, in the 3-bus model, there are two transmission lines: one connecting \"busbar 1 and busbar 2\" and the other connecting \"busbar 2 and busbar 3\"; its table is the following 9 \u00d7 7 table bus_from bus_to x_real x_imag y tap phase ________ ______ ______ ______ ______ ___ _____ 1 2 0 0.0576 0 1 0 3 2 0 0.0625 0 1 0 Sample code for defining a branch \u00b6 In the following section, values are obtained for each row from the table type data defining the branch information, and stored in a class variable named a_branch in the power_network class defined earlier. %Inser the branch table information in the following array. branch_array = [ Inser the table information here ]; %Add variable names to convert the `branch_array` to a `table` type variable. branch = array2table ( branch_array , 'VariableNames' , ... { 'bus_from' , 'bus_to' , 'x_real' , 'x_imag' , 'y' , 'tap' , 'phase' } ... ); %Define Branches. for i = 1 : size ( branch , 1 ) %Define PI Branches if branch{i, 'tap'} == 0 br = branch_pi ( branch { i , 'bus_from' }, branch { i , 'bus_to' }, ... branch { i , { 'x_real' , 'x_imag' }}, branch { i , 'y' }); %Define PI-Transformer Branches else br = branch_pi_transformer ( branch { i , 'bus_from' }, branch { i , 'bus_to' }, ... branch { i , { 'x_real' , 'x_imag' }}, branch { i , 'y' }, ... branch { i , 'tap' }, branch { i , 'phase' }); end %Add the defined Branches to the Network. net . add_branch ( br ); %This line assumes the network's variable name \"net\". end Note that the code above is for the case where the power_network class is assigned to a variable named net . Thus, in case another variable name is used (for example, netbus3 ), change the second line from the end to net3bus . ad_branch ( br ) %This line assumes the network's variable name \"netbus3\". Network Parameters \u00b6 In GUILDA, the busbars have six possible parameters. Active Power \\((P)\\) . Reactive Power \\((Q)\\) . Voltage Magnitude \\((\\lvert V \\rvert)\\) . Voltage Phase Angle \\((\\angle V)\\) . Shunt Resistor Admittance [Shunt Resistor Conductance, Shunt Resistor Susceptance] \\((Y_{\\mathrm{shunt}} = [G_{\\mathrm{shunt}}, B_{\\mathrm{shunt}}])\\) . For more information on it, please refer to Power System Models . The busbars, depending on its type, always specify the shunt resistor admittance \\((Y_{\\mathrm{shunt}})\\) , and two of the rest of parameters \\((\\) i.e., \\(P, Q, \\lvert V \\rvert, \\angle V)\\) . Busbar Definition \u00b6 In GUILDA, the busbars are classified in three groups: PV busbar, PQ busbar, and Slack busbar. For each busbar type a class is defined ( bus_slack , bus_PV , bus_PQ ). Thus, to use it, it is necessary to define an instance of the corresponding class and store it as a cell array ( a_bus ) in the created power network ( net ). %Slack bus b = bus_slack ( ... )\uff1b %PV bus b = bus_PV ( ... ); %PQ bus b = bus_PQ ( ... ); In the previous code block the buses' arguments have been omitted (written as ... ). To properly run the code those must be included. The explanation of each argument can be found in the following sections. Slack Bus \u00b6 All Generator Buses in a power network are basically classified as PV buses, but there is one special bus that specifies the voltage phase angle \\(\\small (\\angle V)\\) and serves as a reference. This is the Slack Bus. Thus, the Slack Bus is specified by voltage magnitude \\(\\small (\\lvert V \\rvert)\\) and voltage phase angle \\(\\small (\\angle V)\\) . Therefore, the slack bus takes those parameters, as well as the shunt admittance, as arguments ( V_abs , V_angle , [G_shunt, B_shunt] ) in the following manner. %Define a Slack Bus named \"b\" b = bus_slack ( V_abs , V_angle , [ G_shunt , B_shunt ]); Input Arguments: V_abs : Voltage Magnitude \\(\\small (\\lvert V \\rvert)\\) . V_angle : Voltage Phase Angle \\(\\small (\\angle V)\\) \\(-\\) Normally 0. [G_shunt, B_shunt] : Real and imaginary part of the impedance of a shunt resistor connected to the ground \\(\\small ([G_{\\mathrm{shunt}}, B_{\\mathrm{shunt}}])\\) . PV Bus \u00b6 As mentioned before, all Generator Buses are classified as PV buses, except for the Slack Bus. As the name implies, this bus type is specified by the active power \\(\\small (P)\\) and the voltage magnitude \\(\\small (\\lvert V \\rvert)\\) , as well as the shunt admittance, and taking them as arguments ( P_gen , V_abs , [G_shunt, B_shunt] ) in the following manner. %Define a PV Bus named \"b\" b = bus_PV ( P_gen , V_abs , [ G_shunt , B_shunt ]); Input Arguments: P_gen : Active Power \\(\\small (P)\\) . V_abs : Voltage Magnitude \\(\\small (\\lvert V \\rvert)\\) [G_shunt, B_shunt] : Real and imaginary part of the impedance of a shunt resistor connected to the ground \\(\\small ([G_{\\mathrm{shunt}}, B_{\\mathrm{shunt}}])\\) . PQ Bus \u00b6 The PQ bus type is selected when loads are connected to the busbar or when nothing is connected to it (i.e., non-unit busbar). This bus type is specified by the active power \\(\\small (P)\\) , reactive power \\(\\small (Q)\\) , as well as the shunt admittance, and taking them as arguments ( -Pload , -Qload , [G_shunt, B_shunt] ). %Define a PQ Bus named \"b\" b = bus_PQ ( - Pload , - Qload , [ G_shunt , B_shunt ]); Input Arguments: -Pload : Negative of Active Power \\(\\small (P)\\) . -Qload : Negative of Reactive Power \\(\\small (Q)\\) . [G_shunt, B_shunt] : Real and imaginary part of the impedance of a shunt resistor connected to the ground \\(\\small ([G_{\\mathrm{shunt}}, B_{\\mathrm{shunt}}])\\) . This completes the process up to creating instances of the busbar class. Note: Before storing the defined busbars ( b ), in the defined power network ( net ); first, define the components (i.e., generators and loads) that are connected to each busbar. For it please refer to the following section. Component Definition \u00b6 The process to define a component is Create a variable (e.g., component ) and make it an instance of one of the component classes (i.e., generator_1axis , load_impedance ). Assign the newly created component variable ( component ) to the bus to which it is connected (e.g., b ), by ussing the function set_component . Generator Definition \u00b6 To define a synchronous generator (1-axis model), the function generator_1axis is used. To define a new variable with the generator_1axis class, please use the following code component = generator_1axis ( omega0 , mac ); Input Arguments: omega0 : Grid's frequency \\(\\small (\\omega_0)\\) . mac : Parameters of the Generator (Table with 8 fields) No_machine : Generator number. No_bus : Busbar to which the the generator is connected. Xd : Synchronous Reactance around the d-axis \\(\\small (X_d)\\) . Xd_prime : Transient Synchronous Reactance around the d-axis \\(\\small (X'_d)\\) . Xq : Synchronous Reactance around the q-axis \\(\\small (X_q)\\) . T : Time constant of the field current aroudn the d-axis \\(\\small (\\tau_d)\\) . M : Inertia Coefficient \\(\\small (M)\\) . D : Damping Factor \\(\\small (D)\\) . For example, defining the table ( mac ) for a synchronous generator with arbitrary parameters is like the following mac = 1 \u00d7 8 table No_machine No_bus Xd Xd_prime Xq T M D ____________ _________ _________ __________ _______ ______ ___ ___ 1 3 1.569 0.324 1.548 5.14 100 2 This is an example of a 1-axis synchronous generator with arbitrary parameters. However, it is common for real generators to have controllers, like Automatic Voltage Regulator (AVR) or Power System Stabilizer (PSS), to make their response favorable. Thus, it is possible to add AVR and PSS information to the created generator instance as follows component . set_avr ( avr_sadamoto2019 ( exc )); %Adds AVR to the created generator instance named \"component\". component . set_pss ( pss ( p )) %Adds PSS to the created generator instance named \"component\". Automatic Voltage Regulator (AVR): In GUILDA, the AVR model is under the class avr_sadamoto2019(exc) . Argument exc : Table that includes the required AVR parameters. exc = 1 \u00d7 3 table No_bus Ka Te ________ _____ ______ 1 2 0.05 Power System Stabilizer (PSS): In GUILDA, the PSS model is under the class pss(p) . Argument p : Table that includes the required PSS parameters. p = 1 \u00d7 6 table No_bus Kpss Tpss TL1p TL1 TL2p TL2 _________ ____ ____ ____ _____ ____ ___ 1 0 10 0.05 0.015 0.08 0.01 Load Definition \u00b6 To define a load, the function load_impedance is used. To define a new variable with the load_impedance class, please use the following code. component = load_impedance (); As you can see from the code, when connecting loads, the bus parameters that have already been defined are used, so there are no new parameters that need to be defined. Add Components to a Busbar \u00b6 To add a created component (e.g., component ) to an already defined busbar (e.g., b ), use the method set_component . Finally, add the busbar with the assigned component to the power network (e.g., net ) with the method add_bus . The following is an example using the variable names of this paragraph. %Adds the generator or load named \"component\" to the busbar named \"b\" b . set_component ( component ); %Adds the busbar named \"b\" to the power network named \"net\" net . add_bus ( b ); Add a component to a bus that already is in the power network : As mentioned before, it is recommended to add the busbars to the power network along with its components. However, in case a component is to be added to a busbar that is already assigned to the power network use the following code. %Add the busbar named \"b\" to the power network named \"net\". net . add_bus ( b ); %Add the component named \"component\" to the \"i-th\" busbar added to the power network named \"net\". net . a_bus { i }. set_component ( component ); The method add_bus (used when adding a busbar to the power network) stores the specified busbar in the variable a_bus . The key point to note is that the busbars are defined in the order in which they are assigned to the field a_bus . In other words, the first busbar class that is net.add_bus(b) is treated as \"bus 1\". Therefore, in the code line net . a_bus { i }. set_component ( component ); the i corresponds to the i-th busbar that was added to the power network by using the method add_bus . Therefore, if this procedure is to be used, it is important to keep a record of the assignment order of the busbars to the power network. This method is useful for situtation like modifying the equipment model (i.e., component) of an existing busbar. Complete Code \u00b6 This completes the definition of the power system. The code up to this point is summarized at the end of this section. In this case, a 3 busbar power network is implemented as an example. However, any network geometry can be implemented. %Function: define a 3-bus network function net = network_3bus_1axis () %Definition of gird frequency omega0 = 60 * 2 * pi ; %Define an empty network named \"net\". net = power_network (); %Define the parameters of the 3 buses to add. bus_array = [ 1 1.00 0 0.60 0 0 0 0 0 2 ; 2 1.00 0 5.45 0 1.0 1.0 0 0 3 ; 3 1.00 0 1.00 2 0 0 0 0 1] ; %Add variable names to the buses' parameters. bus = array2table ( bus_array , 'VariableNames' , ... { 'No' , 'V_abs' , 'V_angle' , 'P_gen' , 'Q_gen' , 'P_load' , 'Q_load' , 'G_shunt' , 'B_shunt' , 'type' } ... ); %Define the parameters of the 2 branches to add. branch_array = [ ... 1 2 0 1/12.56041 0 1 0 ; ... 3 2 0 1/13.65107 0 1 0 ;]; %Add variable names to the branches' parameters. branch = array2table ( branch_array , 'VariableNames' , ... { 'bus_from' , 'bus_to' , 'x_real' , 'x_imag' , 'y' , 'tap' , 'phase' } ... ); %Define the parameters of the 2 generators to add. mac_array = [ 1 , 1 , 0.1 , 0.031 , 0.069 , 10.2 , 84 , 4 ; 2 , 3 , 0.295 , 0.0697 , 0.282 , 6.56 , 60.4 , 9.75 ]; %Add variable names to the generators' parameters. mac_data = array2table ( mac_array , 'VariableNames' , ... { 'No_machine' , 'No_bus' , 'Xd' , 'Xd_prime' , 'Xq' , 'T' , 'M' , 'D' } ... ); %Define Automatic Voltage Regulator (AVR Controller) parameters. exc_array = [ 1 0 0.05 ; 3 0 0.05] ; %Add variable names to the AVR Controller's parameters. exc_data = array2table ( exc_array , 'VariableNames' , ... { 'No_bus' , 'Ka' , 'Te' } ... ); %Define Power System Stabilizer (PSS Controller) parameters. pss_array = [ 1 0 10 0.05 0.015 0.08 0.01 ; 3 0 10 0.05 0.015 0.08 0.01] ; %Add variable names to the PSS Controller's parameters. pss_data = array2table ( pss_array , 'VariableNames' , ... { 'No_bus' , 'Kpss' , 'Tpss' , 'TL1p' , 'TL1' , 'TL2p' , 'TL2' } ... ); %Define Buses. for i = 1 : size ( bus , 1 ) shunt = bus { i , { 'G_shunt' , 'B_shunt' }}; switch bus{i, 'type'} %Define Slack Bus. case 1 V_abs = bus { i , 'V_abs' }; V_angle = bus { i , 'V_angle' }; b = bus_slack ( V_abs , V_angle , shunt ); b . set_component ( get_generator ( i , machinery , excitation , pss_data , omega0 )); %Define PV Bus. case 2 V_abs = bus { i , 'V_abs' }; P = bus { i , 'P_gen' }; b = bus_PV ( P , V_abs , shunt ); b . set_component ( get_generator ( i , machinery , excitation , pss_data , omega0 )); %Define PQ Bus. case 3 P = bus { i , 'P_load' }; Q = bus { i , 'Q_load' }; b = bus_PQ ( - P , - Q , shunt ); if P~=0 || Q ~= 0 load = load_impedance (); b . set_component ( load ); end end %Add buses to the power network. net . add_bus ( b ); end %Define Branches. for i = 1 : size ( branch , 1 ) %Define PI Branches. if branch{i, 'tap'} == 0 br = branch_pi ( branch { i , 'bus_from' }, branch { i , 'bus_to' }, ... branch { i , { 'x_real' , 'x_imag' }}, branch { i , 'y' }); %Define PI-Transformer Branches. else br = branch_pi_transformer ( branch { i , 'bus_from' }, branch { i , 'bus_to' }, ... branch { i , { 'x_real' , 'x_imag' }}, branch { i , 'y' }, ... branch { i , 'tap' }, branch { i , 'phase' }); end %Add branches to the power network. net . add_branch ( br ); end %Finilize: Calculate the power flow, the equilibrium point of the entire system, and store each value. net . initialize (); end %Function to obtain the generator information and define it. function g = get_generator ( i, mac_data, exc_data, pss_data, omega0 ) idx = mac_data {:, 'No_bus' } == i ; if sum(idx) ~= 0 g = generator_1axis ( omega0 , mac_data ( idx , :)); exc = exc_data ( exc_data {:, 'No_bus' } == i , :); g . set_avr ( avr_sadamoto2019 ( exc )); p = pss_data ( pss_data {:, 'No_bus' } == i , :); g . set_pss ( pss ( p )); end end This completes the definition of the power network. To learn more about Calculation of the equations of state, please refer to Derivation of a Linearized Model . More details on the process of simulation, please refer to Simulating . Controller design, please refer to Adding a Controller .","title":"New Power System Model"},{"location":"Reference/defineNet/NewPowerNetwork/#new_power_system_model","text":"This page provides a detailed explanation on how to define a power system model. For a simpler explanation please refer to Power System Models . In this section it is explained how to create a new 3-bus power system model and define it as the power_network class. This explanation uses the already defined components for Generators ( generator_1axis ) and for Loads ( load_impedance ). Contents: Network Definition. Branch Definition. Network Parameters. Busbar Definition. Slack Bus. PV Bus. PQ Bus. Component Definition. Generator. Load. Complete Code.","title":"New Power System Model"},{"location":"Reference/defineNet/NewPowerNetwork/#power_system_model_definition","text":"To define a network, the power_network class must be assigned to a variable. For this example a variable named net is used. The class is assigned to the variable in the following manner net = power_network (); %Class assigned to the variable; however, no network is yet defined. The power_network class has now been assigned to the variable net and is ready to be used. Note that at this point no component has been assigned, thus the network is still empty. In the following sections various elements will be added to the power network ( net ). Such elements are branches, busbars, and components (generators and loads).","title":"Power System Model Definition"},{"location":"Reference/defineNet/NewPowerNetwork/#branch_definition","text":"Branches in GUILDA represent power transmission lines between busbars. The information of these transmission lines is stored as a table . The parameters of interest are bus_from , bus_to : Busbar number that the transmission line connects from and to, respectively. x_real , x_imag : Real and imaginary part of the transmission line's impedance \\(\\small (Z)\\) , respectively. The reciprocal of this value is the admittance \\(\\small (Y)\\) . y : Ground capacitance. tap , phase : Phase Adjustment Transformer Parameters. For example, in the 3-bus model, there are two transmission lines: one connecting \"busbar 1 and busbar 2\" and the other connecting \"busbar 2 and busbar 3\"; its table is the following 9 \u00d7 7 table bus_from bus_to x_real x_imag y tap phase ________ ______ ______ ______ ______ ___ _____ 1 2 0 0.0576 0 1 0 3 2 0 0.0625 0 1 0","title":"Branch Definition"},{"location":"Reference/defineNet/NewPowerNetwork/#sample_code_for_defining_a_branch","text":"In the following section, values are obtained for each row from the table type data defining the branch information, and stored in a class variable named a_branch in the power_network class defined earlier. %Inser the branch table information in the following array. branch_array = [ Inser the table information here ]; %Add variable names to convert the `branch_array` to a `table` type variable. branch = array2table ( branch_array , 'VariableNames' , ... { 'bus_from' , 'bus_to' , 'x_real' , 'x_imag' , 'y' , 'tap' , 'phase' } ... ); %Define Branches. for i = 1 : size ( branch , 1 ) %Define PI Branches if branch{i, 'tap'} == 0 br = branch_pi ( branch { i , 'bus_from' }, branch { i , 'bus_to' }, ... branch { i , { 'x_real' , 'x_imag' }}, branch { i , 'y' }); %Define PI-Transformer Branches else br = branch_pi_transformer ( branch { i , 'bus_from' }, branch { i , 'bus_to' }, ... branch { i , { 'x_real' , 'x_imag' }}, branch { i , 'y' }, ... branch { i , 'tap' }, branch { i , 'phase' }); end %Add the defined Branches to the Network. net . add_branch ( br ); %This line assumes the network's variable name \"net\". end Note that the code above is for the case where the power_network class is assigned to a variable named net . Thus, in case another variable name is used (for example, netbus3 ), change the second line from the end to net3bus . ad_branch ( br ) %This line assumes the network's variable name \"netbus3\".","title":"Sample code for defining a branch"},{"location":"Reference/defineNet/NewPowerNetwork/#network_parameters","text":"In GUILDA, the busbars have six possible parameters. Active Power \\((P)\\) . Reactive Power \\((Q)\\) . Voltage Magnitude \\((\\lvert V \\rvert)\\) . Voltage Phase Angle \\((\\angle V)\\) . Shunt Resistor Admittance [Shunt Resistor Conductance, Shunt Resistor Susceptance] \\((Y_{\\mathrm{shunt}} = [G_{\\mathrm{shunt}}, B_{\\mathrm{shunt}}])\\) . For more information on it, please refer to Power System Models . The busbars, depending on its type, always specify the shunt resistor admittance \\((Y_{\\mathrm{shunt}})\\) , and two of the rest of parameters \\((\\) i.e., \\(P, Q, \\lvert V \\rvert, \\angle V)\\) .","title":"Network Parameters"},{"location":"Reference/defineNet/NewPowerNetwork/#busbar_definition","text":"In GUILDA, the busbars are classified in three groups: PV busbar, PQ busbar, and Slack busbar. For each busbar type a class is defined ( bus_slack , bus_PV , bus_PQ ). Thus, to use it, it is necessary to define an instance of the corresponding class and store it as a cell array ( a_bus ) in the created power network ( net ). %Slack bus b = bus_slack ( ... )\uff1b %PV bus b = bus_PV ( ... ); %PQ bus b = bus_PQ ( ... ); In the previous code block the buses' arguments have been omitted (written as ... ). To properly run the code those must be included. The explanation of each argument can be found in the following sections.","title":"Busbar Definition"},{"location":"Reference/defineNet/NewPowerNetwork/#slack_bus","text":"All Generator Buses in a power network are basically classified as PV buses, but there is one special bus that specifies the voltage phase angle \\(\\small (\\angle V)\\) and serves as a reference. This is the Slack Bus. Thus, the Slack Bus is specified by voltage magnitude \\(\\small (\\lvert V \\rvert)\\) and voltage phase angle \\(\\small (\\angle V)\\) . Therefore, the slack bus takes those parameters, as well as the shunt admittance, as arguments ( V_abs , V_angle , [G_shunt, B_shunt] ) in the following manner. %Define a Slack Bus named \"b\" b = bus_slack ( V_abs , V_angle , [ G_shunt , B_shunt ]); Input Arguments: V_abs : Voltage Magnitude \\(\\small (\\lvert V \\rvert)\\) . V_angle : Voltage Phase Angle \\(\\small (\\angle V)\\) \\(-\\) Normally 0. [G_shunt, B_shunt] : Real and imaginary part of the impedance of a shunt resistor connected to the ground \\(\\small ([G_{\\mathrm{shunt}}, B_{\\mathrm{shunt}}])\\) .","title":"Slack Bus"},{"location":"Reference/defineNet/NewPowerNetwork/#pv_bus","text":"As mentioned before, all Generator Buses are classified as PV buses, except for the Slack Bus. As the name implies, this bus type is specified by the active power \\(\\small (P)\\) and the voltage magnitude \\(\\small (\\lvert V \\rvert)\\) , as well as the shunt admittance, and taking them as arguments ( P_gen , V_abs , [G_shunt, B_shunt] ) in the following manner. %Define a PV Bus named \"b\" b = bus_PV ( P_gen , V_abs , [ G_shunt , B_shunt ]); Input Arguments: P_gen : Active Power \\(\\small (P)\\) . V_abs : Voltage Magnitude \\(\\small (\\lvert V \\rvert)\\) [G_shunt, B_shunt] : Real and imaginary part of the impedance of a shunt resistor connected to the ground \\(\\small ([G_{\\mathrm{shunt}}, B_{\\mathrm{shunt}}])\\) .","title":"PV Bus"},{"location":"Reference/defineNet/NewPowerNetwork/#pq_bus","text":"The PQ bus type is selected when loads are connected to the busbar or when nothing is connected to it (i.e., non-unit busbar). This bus type is specified by the active power \\(\\small (P)\\) , reactive power \\(\\small (Q)\\) , as well as the shunt admittance, and taking them as arguments ( -Pload , -Qload , [G_shunt, B_shunt] ). %Define a PQ Bus named \"b\" b = bus_PQ ( - Pload , - Qload , [ G_shunt , B_shunt ]); Input Arguments: -Pload : Negative of Active Power \\(\\small (P)\\) . -Qload : Negative of Reactive Power \\(\\small (Q)\\) . [G_shunt, B_shunt] : Real and imaginary part of the impedance of a shunt resistor connected to the ground \\(\\small ([G_{\\mathrm{shunt}}, B_{\\mathrm{shunt}}])\\) . This completes the process up to creating instances of the busbar class. Note: Before storing the defined busbars ( b ), in the defined power network ( net ); first, define the components (i.e., generators and loads) that are connected to each busbar. For it please refer to the following section.","title":"PQ Bus"},{"location":"Reference/defineNet/NewPowerNetwork/#component_definition","text":"The process to define a component is Create a variable (e.g., component ) and make it an instance of one of the component classes (i.e., generator_1axis , load_impedance ). Assign the newly created component variable ( component ) to the bus to which it is connected (e.g., b ), by ussing the function set_component .","title":"Component Definition"},{"location":"Reference/defineNet/NewPowerNetwork/#generator_definition","text":"To define a synchronous generator (1-axis model), the function generator_1axis is used. To define a new variable with the generator_1axis class, please use the following code component = generator_1axis ( omega0 , mac ); Input Arguments: omega0 : Grid's frequency \\(\\small (\\omega_0)\\) . mac : Parameters of the Generator (Table with 8 fields) No_machine : Generator number. No_bus : Busbar to which the the generator is connected. Xd : Synchronous Reactance around the d-axis \\(\\small (X_d)\\) . Xd_prime : Transient Synchronous Reactance around the d-axis \\(\\small (X'_d)\\) . Xq : Synchronous Reactance around the q-axis \\(\\small (X_q)\\) . T : Time constant of the field current aroudn the d-axis \\(\\small (\\tau_d)\\) . M : Inertia Coefficient \\(\\small (M)\\) . D : Damping Factor \\(\\small (D)\\) . For example, defining the table ( mac ) for a synchronous generator with arbitrary parameters is like the following mac = 1 \u00d7 8 table No_machine No_bus Xd Xd_prime Xq T M D ____________ _________ _________ __________ _______ ______ ___ ___ 1 3 1.569 0.324 1.548 5.14 100 2 This is an example of a 1-axis synchronous generator with arbitrary parameters. However, it is common for real generators to have controllers, like Automatic Voltage Regulator (AVR) or Power System Stabilizer (PSS), to make their response favorable. Thus, it is possible to add AVR and PSS information to the created generator instance as follows component . set_avr ( avr_sadamoto2019 ( exc )); %Adds AVR to the created generator instance named \"component\". component . set_pss ( pss ( p )) %Adds PSS to the created generator instance named \"component\". Automatic Voltage Regulator (AVR): In GUILDA, the AVR model is under the class avr_sadamoto2019(exc) . Argument exc : Table that includes the required AVR parameters. exc = 1 \u00d7 3 table No_bus Ka Te ________ _____ ______ 1 2 0.05 Power System Stabilizer (PSS): In GUILDA, the PSS model is under the class pss(p) . Argument p : Table that includes the required PSS parameters. p = 1 \u00d7 6 table No_bus Kpss Tpss TL1p TL1 TL2p TL2 _________ ____ ____ ____ _____ ____ ___ 1 0 10 0.05 0.015 0.08 0.01","title":"Generator Definition"},{"location":"Reference/defineNet/NewPowerNetwork/#load_definition","text":"To define a load, the function load_impedance is used. To define a new variable with the load_impedance class, please use the following code. component = load_impedance (); As you can see from the code, when connecting loads, the bus parameters that have already been defined are used, so there are no new parameters that need to be defined.","title":"Load Definition"},{"location":"Reference/defineNet/NewPowerNetwork/#add_components_to_a_busbar","text":"To add a created component (e.g., component ) to an already defined busbar (e.g., b ), use the method set_component . Finally, add the busbar with the assigned component to the power network (e.g., net ) with the method add_bus . The following is an example using the variable names of this paragraph. %Adds the generator or load named \"component\" to the busbar named \"b\" b . set_component ( component ); %Adds the busbar named \"b\" to the power network named \"net\" net . add_bus ( b ); Add a component to a bus that already is in the power network : As mentioned before, it is recommended to add the busbars to the power network along with its components. However, in case a component is to be added to a busbar that is already assigned to the power network use the following code. %Add the busbar named \"b\" to the power network named \"net\". net . add_bus ( b ); %Add the component named \"component\" to the \"i-th\" busbar added to the power network named \"net\". net . a_bus { i }. set_component ( component ); The method add_bus (used when adding a busbar to the power network) stores the specified busbar in the variable a_bus . The key point to note is that the busbars are defined in the order in which they are assigned to the field a_bus . In other words, the first busbar class that is net.add_bus(b) is treated as \"bus 1\". Therefore, in the code line net . a_bus { i }. set_component ( component ); the i corresponds to the i-th busbar that was added to the power network by using the method add_bus . Therefore, if this procedure is to be used, it is important to keep a record of the assignment order of the busbars to the power network. This method is useful for situtation like modifying the equipment model (i.e., component) of an existing busbar.","title":"Add Components to a Busbar"},{"location":"Reference/defineNet/NewPowerNetwork/#complete_code","text":"This completes the definition of the power system. The code up to this point is summarized at the end of this section. In this case, a 3 busbar power network is implemented as an example. However, any network geometry can be implemented. %Function: define a 3-bus network function net = network_3bus_1axis () %Definition of gird frequency omega0 = 60 * 2 * pi ; %Define an empty network named \"net\". net = power_network (); %Define the parameters of the 3 buses to add. bus_array = [ 1 1.00 0 0.60 0 0 0 0 0 2 ; 2 1.00 0 5.45 0 1.0 1.0 0 0 3 ; 3 1.00 0 1.00 2 0 0 0 0 1] ; %Add variable names to the buses' parameters. bus = array2table ( bus_array , 'VariableNames' , ... { 'No' , 'V_abs' , 'V_angle' , 'P_gen' , 'Q_gen' , 'P_load' , 'Q_load' , 'G_shunt' , 'B_shunt' , 'type' } ... ); %Define the parameters of the 2 branches to add. branch_array = [ ... 1 2 0 1/12.56041 0 1 0 ; ... 3 2 0 1/13.65107 0 1 0 ;]; %Add variable names to the branches' parameters. branch = array2table ( branch_array , 'VariableNames' , ... { 'bus_from' , 'bus_to' , 'x_real' , 'x_imag' , 'y' , 'tap' , 'phase' } ... ); %Define the parameters of the 2 generators to add. mac_array = [ 1 , 1 , 0.1 , 0.031 , 0.069 , 10.2 , 84 , 4 ; 2 , 3 , 0.295 , 0.0697 , 0.282 , 6.56 , 60.4 , 9.75 ]; %Add variable names to the generators' parameters. mac_data = array2table ( mac_array , 'VariableNames' , ... { 'No_machine' , 'No_bus' , 'Xd' , 'Xd_prime' , 'Xq' , 'T' , 'M' , 'D' } ... ); %Define Automatic Voltage Regulator (AVR Controller) parameters. exc_array = [ 1 0 0.05 ; 3 0 0.05] ; %Add variable names to the AVR Controller's parameters. exc_data = array2table ( exc_array , 'VariableNames' , ... { 'No_bus' , 'Ka' , 'Te' } ... ); %Define Power System Stabilizer (PSS Controller) parameters. pss_array = [ 1 0 10 0.05 0.015 0.08 0.01 ; 3 0 10 0.05 0.015 0.08 0.01] ; %Add variable names to the PSS Controller's parameters. pss_data = array2table ( pss_array , 'VariableNames' , ... { 'No_bus' , 'Kpss' , 'Tpss' , 'TL1p' , 'TL1' , 'TL2p' , 'TL2' } ... ); %Define Buses. for i = 1 : size ( bus , 1 ) shunt = bus { i , { 'G_shunt' , 'B_shunt' }}; switch bus{i, 'type'} %Define Slack Bus. case 1 V_abs = bus { i , 'V_abs' }; V_angle = bus { i , 'V_angle' }; b = bus_slack ( V_abs , V_angle , shunt ); b . set_component ( get_generator ( i , machinery , excitation , pss_data , omega0 )); %Define PV Bus. case 2 V_abs = bus { i , 'V_abs' }; P = bus { i , 'P_gen' }; b = bus_PV ( P , V_abs , shunt ); b . set_component ( get_generator ( i , machinery , excitation , pss_data , omega0 )); %Define PQ Bus. case 3 P = bus { i , 'P_load' }; Q = bus { i , 'Q_load' }; b = bus_PQ ( - P , - Q , shunt ); if P~=0 || Q ~= 0 load = load_impedance (); b . set_component ( load ); end end %Add buses to the power network. net . add_bus ( b ); end %Define Branches. for i = 1 : size ( branch , 1 ) %Define PI Branches. if branch{i, 'tap'} == 0 br = branch_pi ( branch { i , 'bus_from' }, branch { i , 'bus_to' }, ... branch { i , { 'x_real' , 'x_imag' }}, branch { i , 'y' }); %Define PI-Transformer Branches. else br = branch_pi_transformer ( branch { i , 'bus_from' }, branch { i , 'bus_to' }, ... branch { i , { 'x_real' , 'x_imag' }}, branch { i , 'y' }, ... branch { i , 'tap' }, branch { i , 'phase' }); end %Add branches to the power network. net . add_branch ( br ); end %Finilize: Calculate the power flow, the equilibrium point of the entire system, and store each value. net . initialize (); end %Function to obtain the generator information and define it. function g = get_generator ( i, mac_data, exc_data, pss_data, omega0 ) idx = mac_data {:, 'No_bus' } == i ; if sum(idx) ~= 0 g = generator_1axis ( omega0 , mac_data ( idx , :)); exc = exc_data ( exc_data {:, 'No_bus' } == i , :); g . set_avr ( avr_sadamoto2019 ( exc )); p = pss_data ( pss_data {:, 'No_bus' } == i , :); g . set_pss ( pss ( p )); end end This completes the definition of the power network. To learn more about Calculation of the equations of state, please refer to Derivation of a Linearized Model . More details on the process of simulation, please refer to Simulating . Controller design, please refer to Adding a Controller .","title":"Complete Code"},{"location":"SeriesAnalysis/0TopPage/","text":"Guided Example \u00b6 This page provides a guided example in which the most important functionalities of GUILDA are shown: Define a Power System, Simulate the System's Response, Add a Controller, Simulate the System's Response with a Controller. For this example, a 3-bus system is implemented from scratch in GUILDA, which is covered in the reference text . The process flow from network definition to its analysis is structured to be a single story, so you can deepen your understanding by reading through the pages in order and running the simulations on your own. Contents: Power System Model Construction. Power Network Class. Branch Class. Bus Class. Component Class. Derivation of Admittance Matrix. Simulating. Simulation Conditions. Running the Simulation. Plotting Results. Adding Controllers. Definition of Controller Class. Simulating with Controller. Results Analysis. Comparison of Results. Complete Sample Code. Power System Model Construction \u00b6 In this example a 3-bus system, as the one in the figure below is implemented. Power Network Class \u00b6 The power_network class is the general framework of the power system model. This class defines properties and methods . The properties organize and store information of each busbar, branch, components, etc. The methods perform the simulation and other analysis using this data. The definition of the power_network class is simple and can be executed as follows. net = power_network (); Branch Class \u00b6 To define the branch class is important to have the network's power line information organized. For it, consider that GUILDA implements two types of power lines: branch_pi and branch_pi_transfer . branch_pi class: Is a power line with a pi-type circuit model. branch_pi_tranfer class: Is a power line that includes a phase adjustment transformer. In this example, there are two transmission lines (branches): From \"busbar 1\" to \"busbar 2\". From \"busbar 2\" to busbar 3\". For this example, it is assumed that the transmission lines do not include phase adjusting transformers. The impedance and ground capacitance values on each transmission line are assumed to be Branch (busbar connection) Branch Impedance Branch Ground Capacitance Busbar 1 - Busbar 2 x12 = 0.010 + 0.085j b12 = 0 Busbar 2 - Busbar 3 x23 = 0.017 + 0.092j b23 = 0 Implementing in GUILDA To define the tranmission lines, use the branch class for each one with its information. Class Structure\uff1a branch_pi(from,to,[xreal,ximag],b); from , to : Busbar number that the transmission line connects from and to, respectively. xreal , x_imag : Real and imaginary part of the transmission line's impedance. b : Transmission line's ground capacitance. Lastly, assign the created branches to the power network by using the method add_branch . The code for the example is %Definition of a transmission line connecting busbar 1 and busbar 2. branch12 = branch_pi ( 1 , 2 ,[ 0.010 , 0.085 ], 0 ); %Adding the created transmission line (branch12) to the power network. net . add_branch ( branch12 ); %Definition of a transmission line connecting busbar 2 and busbar 3. branch23 = branch_pi ( 2 , 3 ,[ 0.017 , 0.092 ], 0 ); %Adding the created transmission line (branch23) to the power network. net . add_branch ( branch23 ); For a more advanced tutorial on defining a power grid model please refer to the Creating a Power System Model page. Bus Class \u00b6 To define the bus class, the busbar type (i.e., PV, PQ, slack) and the value of the power flow in each busbar must be determined. For this example, the following are set Busbar Power Flow Busbar Type Busbar \uff11 \\(\\lvert V \\rvert = 2.0,\\) \\(\\angle V \uff1d 0.0\\) Slack Bus Busbar \uff12 \\(P = 0.5,\\) \\(\\lvert V \\rvert = 2.0\\) PV Bus Busbar \uff13 \\(P = -3.0,\\) \\(Q = 0.0\\) PQ Bus \\(\\small P, Q, |V|,\\) and \\(\\small \\angle V\\) in the table refer to \"active power\", \"reactive power\", \"bus bar voltage magnitude\", and \"voltage phase angle\" respectively. For more information on busbar types and the meaning of each parameter in the power flow calculation, please refer to \"Power System Model (Simple)\" . Implementing in GUILDA The first step is to define the bus with its required variables (according to the bus type). Then the created busses are added to the power_network class via the add_bus method. There are 3 types of busses: bus_PV , bus_PQ , and bus_slack classes, which are used separately for each bus bar type. Slack Bus: bus_i = bus_slack(Vabs,Vangle,shunt); PV Bus: bus_i = bus_PV(P,Vabs,shunt); PQ Bus: bus_i = bus_PQ(P,Q,shunt); Note: The shunt argument is a 2 column vector wich refers to the real part (Conductance \\(\\small G\\) ) and imaginary part (susceptance \\(\\small S\\) ) of the admittance \\(\\small{(Y)}\\) of a shunt resistor connected to the ground (i.e., \\(\\small{[G_{shunt}, B_{shunt}]}\\) ). For more information on the arguments of each function, please refer to Creating a Power System Model page. %Definition of shunt admittance. shunt = [ 0 , 0 ]; %Definition of busses 1 to 3. bus_1 = bus_slack ( 2 , 0 , shunt ); bus_2 = bus_PV ( 0.5 , 2 , shunt ); bus_3 = bus_PQ ( - 3 , 0 , shunt ); %Adding the created busses to the power network. net . add_bus ( bus_1 ); net . add_bus ( bus_2 ); net . add_bus ( bus_3 ); Note that the power_network class manages the busses in the order in which they were defined by add_bus . When defining busbars, please assign them in the order of the busbar number. Component Class \u00b6 To define the component class, the devices to be added to each busbar of the 3-bus model must be determined. In this example, busbar 1 (slack bus) and busbar 2 (PV bus) are generator busbars, while busbar 3 (PQ bus) is a load busbar. In this example, the generator busbars are connected to a single axis model of a synchronous generator, and the load busbars are connected to a constant-impedance model load. The single axis model of the synchronous generator is shown in the equation below. When adapting the synchronous generator model, each parameter in the above equation must be determined. The above information for this example is summarized in the following table. Busbar Component Synchronous reactance \\((X_i)\\) (q-axis, d-axis) Transient synchronous reactance \\((X'_i)\\) (d-axis) Time constant of the field current \\((\\tau_i)\\) (d-axis) Inertia Coefficient \\((M_i)\\) Damping Factor \\((D_i)\\) Busbar \uff11 Synchronous Generator (1 Axis Model) Xd = 1.569 Xq = 0.963 Xd_prime = 0.963 T = 5.14 M = 100 D = 2 Busbar\uff12 Synchronous Generator (1 Axis Model) Xd = 1.220 Xq = 0.667 Xd_prime = 0.667 T = 8.97 M = 12 D = 10 Busbar 3 Constant-load model N/A N/A N/A N/A N/A Note: Due to restrictions on variable names that can be implemented in MATLAB the following are rewritten as follows \\(X'_i \u2192\\) Xd_prime \\(\\tau_i \u2192\\) T Implementing in GUILDA In contrast to the definition of the branch and bus classes, which are added to the power_network one, the component class is added to the bus class. This is because the components are connected to each busbar separately. The single axis model of a synchronous generator is defined in the class generator_1axis . The constant impedance model is defined in the class load_impedance . The component implementation code is as follows %Definition of the power system's frequency. omega0 = 60 * 2 * pi ; %Adds the 1-axis model of a synchronous generator to busbar 1. Xd = 1.569 ; Xd_prime = 0.963 ; Xq = 0.963 ; T = 5.14 ; M = 100 ; D = 10 ; mac_data = table ( Xd , Xd_prime , Xq , T , M , D ); component1 = generator_1axis ( omega0 , mac_data ); net . a_bus { 1 }. set_component ( component1 ); %Adds the 1-axis model of a synchronous generator to busbar 2. Xd = 1.220 ; Xd_prime = 0.667 ; Xq = 0.667 ; T = 8.97 ; M = 12 ; D = 10 ; mac_data = table ( Xd , Xd_prime , Xq , T , M , D ); component2 = generator_1axis ( omega0 , mac_data ); net . a_bus { 2 }. set_component ( component2 ); %Adds the constant impedance load model to busbar 3. component3 = load_impedance (); net . a_bus { 3 }. set_component ( component3 ); Note on mac_data : Since the generator_1axis() method takes mac_data as an argument, it means that it reads the variable names for each parameter from it; thus, the defined variables names should be consistent. All of the power system model compenents have now been added. To finilize the power system model denifinition use net . initialize ; This method called initialize is defined in the power_network class. It calculates the power flow, the equilibrium point of the entire system, and stores each value. These values can be viewed from the workspace. For more information on these parameters, please refer to the Network Parameters page. Derivation of Admittance Matrix \u00b6 In the reference text , the admittance matrix was obtained based on the branch parameters. This can be done by the simulator by running the following code >> net . get_admittance_matrix ans = ( 1 , 1 ) 1.3652 - 11 . 6041 i ( 2 , 1 ) - 1.3652 + 11 . 6041 i ( 1 , 2 ) - 1.3652 + 11 . 6041 i ( 2 , 2 ) 3.3074 - 22 . 1148 i ( 3 , 2 ) - 1.9422 + 10 . 5107 i ( 2 , 3 ) - 1.9422 + 10 . 5107 i ( 3 , 3 ) 1.9422 - 10 . 5107 i This should be the output for this example. Admittance matrices are generally sparse matrices, and are outputted as a table in the form of (entry index, value). If you want to display it as a matrix, run the following code >> full ( net . get_admittance_matrix ) ans = 1.3652 - 11 . 6041 i - 1.3652 + 11 . 6041 i 0.0000 + 0 . 0000 i - 1.3652 + 11 . 6041 i 3.3074 - 22 . 1148 i - 1.9422 + 10 . 5107 i 0.0000 + 0 . 0000 i - 1.9422 + 10 . 5107 i 1.9422 - 10 . 5107 i Incidentally, this function get_admittance_matrix is also used inside the calculation of the function initialize described earlier, as you can see from the fact that the admittance matrix is needed for the power flow calculation. Simulating \u00b6 Simulation Conditions \u00b6 For this example the load in busbar 3 will be increased in two steps: 5% increase in the real part of the impedance value. 10% increase in the real part of the impedance value. The objective is to observe the \"frequency deviation of the synchronous generators\" in busbars 1 and 2. The following is a summary of the simulation setup conditions. Total Analysis Time Time of Condition Change Condition Change 0-60 seconds 10 seconds 20 seconds 5% increase in the real part of the impedance value. 10% increase in the real part of the impedance value. The following shows the simulation conditions graphically. Running the Simulation \u00b6 In this page only the execution code is presented. For a more detailed explanation on the variables and how to set the simulating conditions, please refer to the dedicated page Simulating . %Define the important time steps. time = [ 0 , 10 , 20 , 60 ]; %Define the affected busbar. u_idx = 3 ; %Define the input value for each busbar. u = [ 0 , 0.05 , 0.1 , 0.1 ; ... 0 , 0 , 0 , 0 ]; %Store the simulation results. out1 = net . simulate ( time , u , u_idx ); Plotting Results \u00b6 Running the above code will perform the simulation, the progress will be displayed in the command window. When the simulation is finished, take a look at the output results. For this example, the objective is to observe the frequency deviation between busbars 1 and 2, thus the focus is on the variable X (generator state) of the output ( out1 ). In the case of the 1-axis generator model, the entries of the state x are: Rotor declination \\((\\delta)\\) . Frequency deviation \\((\\Delta \\omega)\\) . Internal voltage \\((E)\\) . Thus, for this example, only the second entry of the state is needed. For more information on how to read the data in the output results, please refer to Simulating . %Data extraction. sampling_time = out1 . t ; omega1 = out1 . X { 1 }(:, 2 ); omega2 = out1 . X { 2 }(:, 2 ); %Plot the results. figure ; hold on ; plot ( sampling_time , omega2 , 'LineWidth' , 2 ) plot ( sampling_time , omega1 , 'LineWidth' , 2 ) xlabel ( 'Time [s]' , 'FontSize' , 15 ); ylabel ( 'Frequency Deviation' , 'FontSize' , 15 ); legend ({ 'Frequency deviation of Generator 2' , 'Frequency deviation of Generator 1' }) title ( 'Frequency Deviation Synchronous Generator' , 'FontSize' , 20 ) hold off The results show that the frequency deviation changes significantly at the 10-second and 20-second mark, which is when the impedance value of the load is increased. This is because the supply-demand balance is no longer achieved, due to the increase in load power consumption. Continuous power supply with a non-zero frequency deviation is not good for power quality, and is a major problem for factories and other facilities that handle precision equipment. Therefore, in actual power system operation, a controller is incorporated to restore the frequency deviation to zero. In the next section, a standard controller called Automatic Generation Control (AGC) is incorporated into the power system model. Code Sumary until now %Define a new Power Network net = power_network (); %Definition of a transmission line connecting busbar 1 and busbar 2. branch12 = branch_pi ( 1 , 2 ,[ 0.010 , 0.085 ], 0 ); %Adding the created transmission line (branch12) to the power network. net . add_branch ( branch12 ); %Definition of a transmission line connecting busbar 2 and busbar 3. branch23 = branch_pi ( 2 , 3 ,[ 0.017 , 0.092 ], 0 ); %Adding the created transmission line (branch23) to the power network. net . add_branch ( branch23 ); %Definition of shunt admittance. shunt = [ 0 , 0 ]; %Definition of busses 1 to 3. bus_1 = bus_slack ( 2 , 0 , shunt ); bus_2 = bus_PV ( 0.5 , 2 , shunt ); bus_3 = bus_PQ ( - 3 , 0 , shunt ); %Adding the created busses to the power network. net . add_bus ( bus_1 ); net . add_bus ( bus_2 ); net . add_bus ( bus_3 ); %Definition of the power system's frequency. omega0 = 60 * 2 * pi ; %Adds the 1-axis model of a synchronous generator to busbar 1. Xd = 1.569 ; Xd_prime = 0.963 ; Xq = 0.963 ; T = 5.14 ; M = 100 ; D = 10 ; mac_data = table ( Xd , Xd_prime , Xq , T , M , D ); component1 = generator_1axis ( omega0 , mac_data ); net . a_bus { 1 }. set_component ( component1 ) %Adds the 1-axis model of a synchronous generator to busbar 2. Xd = 1.220 ; Xd_prime = 0.667 ; Xq = 0.667 ; T = 8.97 ; M = 12 ; D = 10 ; mac_data = table ( Xd , Xd_prime , Xq , T , M , D ); component2 = generator_1axis ( omega0 , mac_data ); net . a_bus { 2 }. set_component ( component2 ); %Adds the constant impedance load model to busbar 3. component3 = load_impedance (); net . a_bus { 3 }. set_component ( component3 ); %Initilize the Power Network net . initialize ; %Define the important time steps. time = [ 0 , 10 , 20 , 60 ]; %Define the affected busbar. u_idx = 3 ; %Define the input value for each busbar. u = [ 0 , 0.05 , 0.1 , 0.1 ; ... 0 , 0 , 0 , 0 ]; %Store the simulation results. out1 = net . simulate ( time , u , u_idx ); %Data extraction. sampling_time = out1 . t ; omega1 = out1 . X { 1 }(:, 2 ); omega2 = out1 . X { 2 }(:, 2 ); %Plot the results. figure ; hold on ; plot ( sampling_time , omega2 , 'LineWidth' , 2 ) plot ( sampling_time , omega1 , 'LineWidth' , 2 ) xlabel ( 'Time [s]' , 'FontSize' , 15 ); ylabel ( 'Frequency Deviation' , 'FontSize' , 15 ); legend ({ 'Frequency deviation of Generator 2' , 'Frequency deviation of Generator 1' }) title ( 'Frequency Deviation Synchronous Generator' , 'FontSize' , 20 ) hold off Adding Controllers \u00b6 For this example, the standard controller AGC is added to the power system model. It is a Proportional-Ingetral (PI) controller that observes the frequency deviation values from the all or some of the synchronous generators in the network, and transmits the required mechanical input \\((P_{mech})\\) value to each generator to balance the supply and demand of the entire system. Definition of controller class \u00b6 GUILDA defines AGC with the class name controller_broadcast_PI_AGC . Class Structure: controller_broadcast_PI_AGC(net,y_idx,u_idx,Kp,Ki); net : Power system network to which the controller is added. y_idx : Index of the generator to observe. u_idx : Index of the generators to control. Kp, Ki : P and I controller gains, respectively. For a more detailed explanation, please refer to the dedicated page Simulating . In this example, the synchronous generators connected to busbars 1 and 2 are the observation, as well as the input targets. Therefore, y_idx=1:2 and u_idx=1:2 . For it use the following code %Define AGC controller con = controller_broadcast_PI_AGC ( net , 1 : 2 , 1 : 2 , - 10 , - 500 ); %Assign controller class to power system net . add_controller_global ( con ); Simulating with Controller \u00b6 Results Analysis \u00b6 Now, let's run the same simulation as before using the system model with the controller added. %Analysis Execution out2 = net . simulate ( time , u , u_idx ); %data extraction sampling_time = out2 . t ; omega1 = out2 . X { 1 }(:, 2 ); omega2 = out2 . X { 2 }(:, 2 ); %Plot figure ; hold on ; plot ( sampling_time , omega2 , 'LineWidth' , 2 ) plot ( sampling_time , omega1 , 'LineWidth' , 2 ) xlabel ( 'Time [s]' , 'FontSize' , 15 ); ylabel ( 'Frequency Deviation' , 'FontSize' , 15 ); legend ({ 'Frequency deviation of Generator 2' , 'Frequency deviation of Generator 1' }) title ( 'Frequency Deviation Synchronous Generator ' , 'FontSize' , 20 ) hold off The results show that the frequency deviations of each generator converge to 0 after the controller is added. Although, there are still oscillations at the time marks when the load was increased (10 second and 20 second mark). Comparison of Results \u00b6 This is the comparison of responses of the system with and without the controller. The figure below plots the two results above on the same scale. It can be clearly seen that for the same load variation, the frequency deviation is significantly more without the AGC controller. In other words, the AGC controller is able to balance the supply and demand of the entire system and suppress the frequency deviation. This concludes this example. As a final note, we emphasize that the simulator has been designed to be scalable so that it can be used to implement various power system models. This is just one example, but if you would like to know more about the different usage of each class, please refer to pages such as GUILDA in Detail , for more detailed information on each class and its usage. Complete Sample Code \u00b6 %Create a framework for the power system net = power_network ; %Branch Definition %Definition of a transmission line connecting busbar 1 and busbar 2 branch12 = branch_pi ( 1 , 2 ,[ 0.010 , 0.085 ], 0 ); net . add_branch ( branch12 ); %Definition of a transmission line connecting busbar 2 and busbar 3 branch23 = branch_pi ( 2 , 3 ,[ 0.017 , 0.092 ], 0 ); net . add_branch ( branch23 ); %Definition of busbar (bus) shunt = [ 0 , 0 ]; %Definition of busbar 1 bus_1 = bus_slack ( 2 , 0 , shunt ); net . add_bus ( bus_1 ); %Definition of busbar 2 bus_2 = bus_PV ( 0.5 , 2 , shunt ); net . add_bus ( bus_2 ); %Definition of busbar 3 bus_3 = bus_PQ ( - 3 , 0 , shunt ); net . add_bus ( bus_3 ); %Definition of component %Definition of grid frequency omega0 = 60 * 2 * pi ; %1-axis model of synchronous generator added to bus-bar 1 Xd = 1.569 ; Xd_prime = 0.963 ; Xq = 0.963 ; T = 5.14 ; M = 100 ; D = 10 ; mac_data = table ( Xd , Xd_prime , Xq , T , M , D ); component1 = generator_1axis ( omega0 , mac_data ); net . a_bus { 1 }. set_component ( component1 ); %A single axis model of a synchronous generator is also added to busbar 2. Xd = 1.220 ; Xd_prime = 0.667 ; Xq = 0.667 ; T = 8.97 ; M = 12 ; D = 10 ; mac_data = table ( Xd , Xd_prime , Xq , T , M , D ); comp2 = generator_1axis ( omega0 , mac_data ); net . a_bus { 2 }. set_component ( comp2 ); %A constant impedance model is added to bus-bar 3 comp3 = load_impedance (); net . a_bus { 3 }. set_component ( comp3 ); %Running tidal current calculations net . initialize %Aside ~Derivation of admittance matrix~. full ( net . get_admittance_matrix ) %Simulation run (without controller) %Condition Setting time = [ 0 , 10 , 20 , 60 ]; u_idx = 3 ; u = [ 0 , 0.05 , 0.1 , 0.1 ; ... 0 , 0 , 0 , 0 ]; %Input signal waveform plot figure ; hold on ; u_percent = u * 100 ; stairs ( time , u_percent ( 1 ,:), 'LineWidth' , 2 ) stairs ( time , u_percent ( 2 ,:), '--' , 'LineWidth' , 2 ) xlabel ( 'Time (s)' , 'FontSize' , 15 ); ylabel ( 'Percentage change from steady-state value(%)' , 'FontSize' , 15 ); ylim ([ - 20 , 20 ]) legend ({ 'Real part of impedance' , 'Imaginary part of impedance' }, 'Location' , 'southeast' ) title ( 'Change in the value of the impedance of bus-bar 3' , 'FontSize' , 20 ) hold off ; %Analysis Execution out1 = net . simulate ( time , u , u_idx ); %data extraction sampling_time = out1 . t ; omega1 = out1 . X { 1 }(:, 2 ); omega2 = out1 . X { 2 }(:, 2 ); %plot figure ; hold on ; plot ( sampling_time , omega2 , 'LineWidth' , 2 ) plot ( sampling_time , omega1 , 'LineWidth' , 2 ) xlabel ( 'Time (s)' , 'FontSize' , 15 ); ylabel ( 'Frequency Deviation' , 'FontSize' , 15 ); legend ({ 'Frequency deviation of Generator 2' , 'Frequency deviation of Generator 1' }) title ( 'Frequency Deviation Synchronous Generator' , 'FontSize' , 20 ) hold off %Adding a controller to the power system %Define AGC controller con = controller_broadcast_PI_AGC ( net , 1 : 2 , 1 : 2 , - 10 , - 500 ); %Assign controller class to power system net . add_controller_global ( con ); %Simulation run (with controller) %Analysis Execution out2 = net . simulate ( time , u , u_idx ); %data extraction sampling_time = out2 . t ; omega1 = out2 . X { 1 }(:, 2 ); omega2 = out2 . X { 2 }(:, 2 ); %Plot figure ; hold on ; plot ( sampling_time , omega2 , 'LineWidth' , 2 ) plot ( sampling_time , omega1 , 'LineWidth' , 2 ) xlabel ( 'Time (s)' , 'FontSize' , 15 ); ylabel ( 'Frequency Deviation' , 'FontSize' , 15 ); legend ({ 'Frequency deviation of Generator 2' , 'Frequency deviation of Generator 1' }) title ( 'Frequency Deviation Synchronous Generator' , 'FontSize' , 20 ) hold off %Comparison plots before and after adding the controller figure ; hold on ; plot ( out1 . t , out1 . X { 2 }(:, 2 ), 'Color' , '#A2142F' , 'LineWidth' , 1.5 ) plot ( out1 . t , out1 . X { 1 }(:, 2 ), 'Color' , '#EDB120' , 'LineWidth' , 1.5 ) plot ( out2 . t , out2 . X { 2 }(:, 2 ), 'Color' , '#0072BD' , 'LineWidth' , 1.5 ) plot ( out2 . t , out2 . X { 1 }(:, 2 ), 'Color' , '#77AC30' , 'LineWidth' , 1.5 ) xlabel ( 'Time [s]' , 'FontSize' , 15 ); ylabel ( 'Frequency Deviation' , 'FontSize' , 15 ); legend ({ 'Frequency deviation of Generator 2 (without AGC)' , 'Frequency deviation of Generator 1 (without AGC)' , ... 'Frequency deviation of Generator 2 (with AGC)' , 'Frequency deviation of Generator 1 (with AGC)' }, ... 'Location' , 'east' ) title ( 'Frequency Deviation Synchronous Generator' , 'FontSize' , 20 ) hold off","title":"Guided Example"},{"location":"SeriesAnalysis/0TopPage/#guided_example","text":"This page provides a guided example in which the most important functionalities of GUILDA are shown: Define a Power System, Simulate the System's Response, Add a Controller, Simulate the System's Response with a Controller. For this example, a 3-bus system is implemented from scratch in GUILDA, which is covered in the reference text . The process flow from network definition to its analysis is structured to be a single story, so you can deepen your understanding by reading through the pages in order and running the simulations on your own. Contents: Power System Model Construction. Power Network Class. Branch Class. Bus Class. Component Class. Derivation of Admittance Matrix. Simulating. Simulation Conditions. Running the Simulation. Plotting Results. Adding Controllers. Definition of Controller Class. Simulating with Controller. Results Analysis. Comparison of Results. Complete Sample Code.","title":"Guided Example"},{"location":"SeriesAnalysis/0TopPage/#power_system_model_construction","text":"In this example a 3-bus system, as the one in the figure below is implemented.","title":"Power System Model Construction"},{"location":"SeriesAnalysis/0TopPage/#power_network_class","text":"The power_network class is the general framework of the power system model. This class defines properties and methods . The properties organize and store information of each busbar, branch, components, etc. The methods perform the simulation and other analysis using this data. The definition of the power_network class is simple and can be executed as follows. net = power_network ();","title":"Power Network Class"},{"location":"SeriesAnalysis/0TopPage/#branch_class","text":"To define the branch class is important to have the network's power line information organized. For it, consider that GUILDA implements two types of power lines: branch_pi and branch_pi_transfer . branch_pi class: Is a power line with a pi-type circuit model. branch_pi_tranfer class: Is a power line that includes a phase adjustment transformer. In this example, there are two transmission lines (branches): From \"busbar 1\" to \"busbar 2\". From \"busbar 2\" to busbar 3\". For this example, it is assumed that the transmission lines do not include phase adjusting transformers. The impedance and ground capacitance values on each transmission line are assumed to be Branch (busbar connection) Branch Impedance Branch Ground Capacitance Busbar 1 - Busbar 2 x12 = 0.010 + 0.085j b12 = 0 Busbar 2 - Busbar 3 x23 = 0.017 + 0.092j b23 = 0 Implementing in GUILDA To define the tranmission lines, use the branch class for each one with its information. Class Structure\uff1a branch_pi(from,to,[xreal,ximag],b); from , to : Busbar number that the transmission line connects from and to, respectively. xreal , x_imag : Real and imaginary part of the transmission line's impedance. b : Transmission line's ground capacitance. Lastly, assign the created branches to the power network by using the method add_branch . The code for the example is %Definition of a transmission line connecting busbar 1 and busbar 2. branch12 = branch_pi ( 1 , 2 ,[ 0.010 , 0.085 ], 0 ); %Adding the created transmission line (branch12) to the power network. net . add_branch ( branch12 ); %Definition of a transmission line connecting busbar 2 and busbar 3. branch23 = branch_pi ( 2 , 3 ,[ 0.017 , 0.092 ], 0 ); %Adding the created transmission line (branch23) to the power network. net . add_branch ( branch23 ); For a more advanced tutorial on defining a power grid model please refer to the Creating a Power System Model page.","title":"Branch Class"},{"location":"SeriesAnalysis/0TopPage/#bus_class","text":"To define the bus class, the busbar type (i.e., PV, PQ, slack) and the value of the power flow in each busbar must be determined. For this example, the following are set Busbar Power Flow Busbar Type Busbar \uff11 \\(\\lvert V \\rvert = 2.0,\\) \\(\\angle V \uff1d 0.0\\) Slack Bus Busbar \uff12 \\(P = 0.5,\\) \\(\\lvert V \\rvert = 2.0\\) PV Bus Busbar \uff13 \\(P = -3.0,\\) \\(Q = 0.0\\) PQ Bus \\(\\small P, Q, |V|,\\) and \\(\\small \\angle V\\) in the table refer to \"active power\", \"reactive power\", \"bus bar voltage magnitude\", and \"voltage phase angle\" respectively. For more information on busbar types and the meaning of each parameter in the power flow calculation, please refer to \"Power System Model (Simple)\" . Implementing in GUILDA The first step is to define the bus with its required variables (according to the bus type). Then the created busses are added to the power_network class via the add_bus method. There are 3 types of busses: bus_PV , bus_PQ , and bus_slack classes, which are used separately for each bus bar type. Slack Bus: bus_i = bus_slack(Vabs,Vangle,shunt); PV Bus: bus_i = bus_PV(P,Vabs,shunt); PQ Bus: bus_i = bus_PQ(P,Q,shunt); Note: The shunt argument is a 2 column vector wich refers to the real part (Conductance \\(\\small G\\) ) and imaginary part (susceptance \\(\\small S\\) ) of the admittance \\(\\small{(Y)}\\) of a shunt resistor connected to the ground (i.e., \\(\\small{[G_{shunt}, B_{shunt}]}\\) ). For more information on the arguments of each function, please refer to Creating a Power System Model page. %Definition of shunt admittance. shunt = [ 0 , 0 ]; %Definition of busses 1 to 3. bus_1 = bus_slack ( 2 , 0 , shunt ); bus_2 = bus_PV ( 0.5 , 2 , shunt ); bus_3 = bus_PQ ( - 3 , 0 , shunt ); %Adding the created busses to the power network. net . add_bus ( bus_1 ); net . add_bus ( bus_2 ); net . add_bus ( bus_3 ); Note that the power_network class manages the busses in the order in which they were defined by add_bus . When defining busbars, please assign them in the order of the busbar number.","title":"Bus Class"},{"location":"SeriesAnalysis/0TopPage/#component_class","text":"To define the component class, the devices to be added to each busbar of the 3-bus model must be determined. In this example, busbar 1 (slack bus) and busbar 2 (PV bus) are generator busbars, while busbar 3 (PQ bus) is a load busbar. In this example, the generator busbars are connected to a single axis model of a synchronous generator, and the load busbars are connected to a constant-impedance model load. The single axis model of the synchronous generator is shown in the equation below. When adapting the synchronous generator model, each parameter in the above equation must be determined. The above information for this example is summarized in the following table. Busbar Component Synchronous reactance \\((X_i)\\) (q-axis, d-axis) Transient synchronous reactance \\((X'_i)\\) (d-axis) Time constant of the field current \\((\\tau_i)\\) (d-axis) Inertia Coefficient \\((M_i)\\) Damping Factor \\((D_i)\\) Busbar \uff11 Synchronous Generator (1 Axis Model) Xd = 1.569 Xq = 0.963 Xd_prime = 0.963 T = 5.14 M = 100 D = 2 Busbar\uff12 Synchronous Generator (1 Axis Model) Xd = 1.220 Xq = 0.667 Xd_prime = 0.667 T = 8.97 M = 12 D = 10 Busbar 3 Constant-load model N/A N/A N/A N/A N/A Note: Due to restrictions on variable names that can be implemented in MATLAB the following are rewritten as follows \\(X'_i \u2192\\) Xd_prime \\(\\tau_i \u2192\\) T Implementing in GUILDA In contrast to the definition of the branch and bus classes, which are added to the power_network one, the component class is added to the bus class. This is because the components are connected to each busbar separately. The single axis model of a synchronous generator is defined in the class generator_1axis . The constant impedance model is defined in the class load_impedance . The component implementation code is as follows %Definition of the power system's frequency. omega0 = 60 * 2 * pi ; %Adds the 1-axis model of a synchronous generator to busbar 1. Xd = 1.569 ; Xd_prime = 0.963 ; Xq = 0.963 ; T = 5.14 ; M = 100 ; D = 10 ; mac_data = table ( Xd , Xd_prime , Xq , T , M , D ); component1 = generator_1axis ( omega0 , mac_data ); net . a_bus { 1 }. set_component ( component1 ); %Adds the 1-axis model of a synchronous generator to busbar 2. Xd = 1.220 ; Xd_prime = 0.667 ; Xq = 0.667 ; T = 8.97 ; M = 12 ; D = 10 ; mac_data = table ( Xd , Xd_prime , Xq , T , M , D ); component2 = generator_1axis ( omega0 , mac_data ); net . a_bus { 2 }. set_component ( component2 ); %Adds the constant impedance load model to busbar 3. component3 = load_impedance (); net . a_bus { 3 }. set_component ( component3 ); Note on mac_data : Since the generator_1axis() method takes mac_data as an argument, it means that it reads the variable names for each parameter from it; thus, the defined variables names should be consistent. All of the power system model compenents have now been added. To finilize the power system model denifinition use net . initialize ; This method called initialize is defined in the power_network class. It calculates the power flow, the equilibrium point of the entire system, and stores each value. These values can be viewed from the workspace. For more information on these parameters, please refer to the Network Parameters page.","title":"Component Class"},{"location":"SeriesAnalysis/0TopPage/#derivation_of_admittance_matrix","text":"In the reference text , the admittance matrix was obtained based on the branch parameters. This can be done by the simulator by running the following code >> net . get_admittance_matrix ans = ( 1 , 1 ) 1.3652 - 11 . 6041 i ( 2 , 1 ) - 1.3652 + 11 . 6041 i ( 1 , 2 ) - 1.3652 + 11 . 6041 i ( 2 , 2 ) 3.3074 - 22 . 1148 i ( 3 , 2 ) - 1.9422 + 10 . 5107 i ( 2 , 3 ) - 1.9422 + 10 . 5107 i ( 3 , 3 ) 1.9422 - 10 . 5107 i This should be the output for this example. Admittance matrices are generally sparse matrices, and are outputted as a table in the form of (entry index, value). If you want to display it as a matrix, run the following code >> full ( net . get_admittance_matrix ) ans = 1.3652 - 11 . 6041 i - 1.3652 + 11 . 6041 i 0.0000 + 0 . 0000 i - 1.3652 + 11 . 6041 i 3.3074 - 22 . 1148 i - 1.9422 + 10 . 5107 i 0.0000 + 0 . 0000 i - 1.9422 + 10 . 5107 i 1.9422 - 10 . 5107 i Incidentally, this function get_admittance_matrix is also used inside the calculation of the function initialize described earlier, as you can see from the fact that the admittance matrix is needed for the power flow calculation.","title":"Derivation of Admittance Matrix"},{"location":"SeriesAnalysis/0TopPage/#simulating","text":"","title":"Simulating"},{"location":"SeriesAnalysis/0TopPage/#simulation_conditions","text":"For this example the load in busbar 3 will be increased in two steps: 5% increase in the real part of the impedance value. 10% increase in the real part of the impedance value. The objective is to observe the \"frequency deviation of the synchronous generators\" in busbars 1 and 2. The following is a summary of the simulation setup conditions. Total Analysis Time Time of Condition Change Condition Change 0-60 seconds 10 seconds 20 seconds 5% increase in the real part of the impedance value. 10% increase in the real part of the impedance value. The following shows the simulation conditions graphically.","title":"Simulation Conditions"},{"location":"SeriesAnalysis/0TopPage/#running_the_simulation","text":"In this page only the execution code is presented. For a more detailed explanation on the variables and how to set the simulating conditions, please refer to the dedicated page Simulating . %Define the important time steps. time = [ 0 , 10 , 20 , 60 ]; %Define the affected busbar. u_idx = 3 ; %Define the input value for each busbar. u = [ 0 , 0.05 , 0.1 , 0.1 ; ... 0 , 0 , 0 , 0 ]; %Store the simulation results. out1 = net . simulate ( time , u , u_idx );","title":"Running the Simulation"},{"location":"SeriesAnalysis/0TopPage/#plotting_results","text":"Running the above code will perform the simulation, the progress will be displayed in the command window. When the simulation is finished, take a look at the output results. For this example, the objective is to observe the frequency deviation between busbars 1 and 2, thus the focus is on the variable X (generator state) of the output ( out1 ). In the case of the 1-axis generator model, the entries of the state x are: Rotor declination \\((\\delta)\\) . Frequency deviation \\((\\Delta \\omega)\\) . Internal voltage \\((E)\\) . Thus, for this example, only the second entry of the state is needed. For more information on how to read the data in the output results, please refer to Simulating . %Data extraction. sampling_time = out1 . t ; omega1 = out1 . X { 1 }(:, 2 ); omega2 = out1 . X { 2 }(:, 2 ); %Plot the results. figure ; hold on ; plot ( sampling_time , omega2 , 'LineWidth' , 2 ) plot ( sampling_time , omega1 , 'LineWidth' , 2 ) xlabel ( 'Time [s]' , 'FontSize' , 15 ); ylabel ( 'Frequency Deviation' , 'FontSize' , 15 ); legend ({ 'Frequency deviation of Generator 2' , 'Frequency deviation of Generator 1' }) title ( 'Frequency Deviation Synchronous Generator' , 'FontSize' , 20 ) hold off The results show that the frequency deviation changes significantly at the 10-second and 20-second mark, which is when the impedance value of the load is increased. This is because the supply-demand balance is no longer achieved, due to the increase in load power consumption. Continuous power supply with a non-zero frequency deviation is not good for power quality, and is a major problem for factories and other facilities that handle precision equipment. Therefore, in actual power system operation, a controller is incorporated to restore the frequency deviation to zero. In the next section, a standard controller called Automatic Generation Control (AGC) is incorporated into the power system model. Code Sumary until now %Define a new Power Network net = power_network (); %Definition of a transmission line connecting busbar 1 and busbar 2. branch12 = branch_pi ( 1 , 2 ,[ 0.010 , 0.085 ], 0 ); %Adding the created transmission line (branch12) to the power network. net . add_branch ( branch12 ); %Definition of a transmission line connecting busbar 2 and busbar 3. branch23 = branch_pi ( 2 , 3 ,[ 0.017 , 0.092 ], 0 ); %Adding the created transmission line (branch23) to the power network. net . add_branch ( branch23 ); %Definition of shunt admittance. shunt = [ 0 , 0 ]; %Definition of busses 1 to 3. bus_1 = bus_slack ( 2 , 0 , shunt ); bus_2 = bus_PV ( 0.5 , 2 , shunt ); bus_3 = bus_PQ ( - 3 , 0 , shunt ); %Adding the created busses to the power network. net . add_bus ( bus_1 ); net . add_bus ( bus_2 ); net . add_bus ( bus_3 ); %Definition of the power system's frequency. omega0 = 60 * 2 * pi ; %Adds the 1-axis model of a synchronous generator to busbar 1. Xd = 1.569 ; Xd_prime = 0.963 ; Xq = 0.963 ; T = 5.14 ; M = 100 ; D = 10 ; mac_data = table ( Xd , Xd_prime , Xq , T , M , D ); component1 = generator_1axis ( omega0 , mac_data ); net . a_bus { 1 }. set_component ( component1 ) %Adds the 1-axis model of a synchronous generator to busbar 2. Xd = 1.220 ; Xd_prime = 0.667 ; Xq = 0.667 ; T = 8.97 ; M = 12 ; D = 10 ; mac_data = table ( Xd , Xd_prime , Xq , T , M , D ); component2 = generator_1axis ( omega0 , mac_data ); net . a_bus { 2 }. set_component ( component2 ); %Adds the constant impedance load model to busbar 3. component3 = load_impedance (); net . a_bus { 3 }. set_component ( component3 ); %Initilize the Power Network net . initialize ; %Define the important time steps. time = [ 0 , 10 , 20 , 60 ]; %Define the affected busbar. u_idx = 3 ; %Define the input value for each busbar. u = [ 0 , 0.05 , 0.1 , 0.1 ; ... 0 , 0 , 0 , 0 ]; %Store the simulation results. out1 = net . simulate ( time , u , u_idx ); %Data extraction. sampling_time = out1 . t ; omega1 = out1 . X { 1 }(:, 2 ); omega2 = out1 . X { 2 }(:, 2 ); %Plot the results. figure ; hold on ; plot ( sampling_time , omega2 , 'LineWidth' , 2 ) plot ( sampling_time , omega1 , 'LineWidth' , 2 ) xlabel ( 'Time [s]' , 'FontSize' , 15 ); ylabel ( 'Frequency Deviation' , 'FontSize' , 15 ); legend ({ 'Frequency deviation of Generator 2' , 'Frequency deviation of Generator 1' }) title ( 'Frequency Deviation Synchronous Generator' , 'FontSize' , 20 ) hold off","title":"Plotting Results"},{"location":"SeriesAnalysis/0TopPage/#adding_controllers","text":"For this example, the standard controller AGC is added to the power system model. It is a Proportional-Ingetral (PI) controller that observes the frequency deviation values from the all or some of the synchronous generators in the network, and transmits the required mechanical input \\((P_{mech})\\) value to each generator to balance the supply and demand of the entire system.","title":"Adding Controllers"},{"location":"SeriesAnalysis/0TopPage/#definition_of_controller_class","text":"GUILDA defines AGC with the class name controller_broadcast_PI_AGC . Class Structure: controller_broadcast_PI_AGC(net,y_idx,u_idx,Kp,Ki); net : Power system network to which the controller is added. y_idx : Index of the generator to observe. u_idx : Index of the generators to control. Kp, Ki : P and I controller gains, respectively. For a more detailed explanation, please refer to the dedicated page Simulating . In this example, the synchronous generators connected to busbars 1 and 2 are the observation, as well as the input targets. Therefore, y_idx=1:2 and u_idx=1:2 . For it use the following code %Define AGC controller con = controller_broadcast_PI_AGC ( net , 1 : 2 , 1 : 2 , - 10 , - 500 ); %Assign controller class to power system net . add_controller_global ( con );","title":"Definition of controller class"},{"location":"SeriesAnalysis/0TopPage/#simulating_with_controller","text":"","title":"Simulating with Controller"},{"location":"SeriesAnalysis/0TopPage/#results_analysis","text":"Now, let's run the same simulation as before using the system model with the controller added. %Analysis Execution out2 = net . simulate ( time , u , u_idx ); %data extraction sampling_time = out2 . t ; omega1 = out2 . X { 1 }(:, 2 ); omega2 = out2 . X { 2 }(:, 2 ); %Plot figure ; hold on ; plot ( sampling_time , omega2 , 'LineWidth' , 2 ) plot ( sampling_time , omega1 , 'LineWidth' , 2 ) xlabel ( 'Time [s]' , 'FontSize' , 15 ); ylabel ( 'Frequency Deviation' , 'FontSize' , 15 ); legend ({ 'Frequency deviation of Generator 2' , 'Frequency deviation of Generator 1' }) title ( 'Frequency Deviation Synchronous Generator ' , 'FontSize' , 20 ) hold off The results show that the frequency deviations of each generator converge to 0 after the controller is added. Although, there are still oscillations at the time marks when the load was increased (10 second and 20 second mark).","title":"Results Analysis"},{"location":"SeriesAnalysis/0TopPage/#comparison_of_results","text":"This is the comparison of responses of the system with and without the controller. The figure below plots the two results above on the same scale. It can be clearly seen that for the same load variation, the frequency deviation is significantly more without the AGC controller. In other words, the AGC controller is able to balance the supply and demand of the entire system and suppress the frequency deviation. This concludes this example. As a final note, we emphasize that the simulator has been designed to be scalable so that it can be used to implement various power system models. This is just one example, but if you would like to know more about the different usage of each class, please refer to pages such as GUILDA in Detail , for more detailed information on each class and its usage.","title":"Comparison of Results"},{"location":"SeriesAnalysis/0TopPage/#complete_sample_code","text":"%Create a framework for the power system net = power_network ; %Branch Definition %Definition of a transmission line connecting busbar 1 and busbar 2 branch12 = branch_pi ( 1 , 2 ,[ 0.010 , 0.085 ], 0 ); net . add_branch ( branch12 ); %Definition of a transmission line connecting busbar 2 and busbar 3 branch23 = branch_pi ( 2 , 3 ,[ 0.017 , 0.092 ], 0 ); net . add_branch ( branch23 ); %Definition of busbar (bus) shunt = [ 0 , 0 ]; %Definition of busbar 1 bus_1 = bus_slack ( 2 , 0 , shunt ); net . add_bus ( bus_1 ); %Definition of busbar 2 bus_2 = bus_PV ( 0.5 , 2 , shunt ); net . add_bus ( bus_2 ); %Definition of busbar 3 bus_3 = bus_PQ ( - 3 , 0 , shunt ); net . add_bus ( bus_3 ); %Definition of component %Definition of grid frequency omega0 = 60 * 2 * pi ; %1-axis model of synchronous generator added to bus-bar 1 Xd = 1.569 ; Xd_prime = 0.963 ; Xq = 0.963 ; T = 5.14 ; M = 100 ; D = 10 ; mac_data = table ( Xd , Xd_prime , Xq , T , M , D ); component1 = generator_1axis ( omega0 , mac_data ); net . a_bus { 1 }. set_component ( component1 ); %A single axis model of a synchronous generator is also added to busbar 2. Xd = 1.220 ; Xd_prime = 0.667 ; Xq = 0.667 ; T = 8.97 ; M = 12 ; D = 10 ; mac_data = table ( Xd , Xd_prime , Xq , T , M , D ); comp2 = generator_1axis ( omega0 , mac_data ); net . a_bus { 2 }. set_component ( comp2 ); %A constant impedance model is added to bus-bar 3 comp3 = load_impedance (); net . a_bus { 3 }. set_component ( comp3 ); %Running tidal current calculations net . initialize %Aside ~Derivation of admittance matrix~. full ( net . get_admittance_matrix ) %Simulation run (without controller) %Condition Setting time = [ 0 , 10 , 20 , 60 ]; u_idx = 3 ; u = [ 0 , 0.05 , 0.1 , 0.1 ; ... 0 , 0 , 0 , 0 ]; %Input signal waveform plot figure ; hold on ; u_percent = u * 100 ; stairs ( time , u_percent ( 1 ,:), 'LineWidth' , 2 ) stairs ( time , u_percent ( 2 ,:), '--' , 'LineWidth' , 2 ) xlabel ( 'Time (s)' , 'FontSize' , 15 ); ylabel ( 'Percentage change from steady-state value(%)' , 'FontSize' , 15 ); ylim ([ - 20 , 20 ]) legend ({ 'Real part of impedance' , 'Imaginary part of impedance' }, 'Location' , 'southeast' ) title ( 'Change in the value of the impedance of bus-bar 3' , 'FontSize' , 20 ) hold off ; %Analysis Execution out1 = net . simulate ( time , u , u_idx ); %data extraction sampling_time = out1 . t ; omega1 = out1 . X { 1 }(:, 2 ); omega2 = out1 . X { 2 }(:, 2 ); %plot figure ; hold on ; plot ( sampling_time , omega2 , 'LineWidth' , 2 ) plot ( sampling_time , omega1 , 'LineWidth' , 2 ) xlabel ( 'Time (s)' , 'FontSize' , 15 ); ylabel ( 'Frequency Deviation' , 'FontSize' , 15 ); legend ({ 'Frequency deviation of Generator 2' , 'Frequency deviation of Generator 1' }) title ( 'Frequency Deviation Synchronous Generator' , 'FontSize' , 20 ) hold off %Adding a controller to the power system %Define AGC controller con = controller_broadcast_PI_AGC ( net , 1 : 2 , 1 : 2 , - 10 , - 500 ); %Assign controller class to power system net . add_controller_global ( con ); %Simulation run (with controller) %Analysis Execution out2 = net . simulate ( time , u , u_idx ); %data extraction sampling_time = out2 . t ; omega1 = out2 . X { 1 }(:, 2 ); omega2 = out2 . X { 2 }(:, 2 ); %Plot figure ; hold on ; plot ( sampling_time , omega2 , 'LineWidth' , 2 ) plot ( sampling_time , omega1 , 'LineWidth' , 2 ) xlabel ( 'Time (s)' , 'FontSize' , 15 ); ylabel ( 'Frequency Deviation' , 'FontSize' , 15 ); legend ({ 'Frequency deviation of Generator 2' , 'Frequency deviation of Generator 1' }) title ( 'Frequency Deviation Synchronous Generator' , 'FontSize' , 20 ) hold off %Comparison plots before and after adding the controller figure ; hold on ; plot ( out1 . t , out1 . X { 2 }(:, 2 ), 'Color' , '#A2142F' , 'LineWidth' , 1.5 ) plot ( out1 . t , out1 . X { 1 }(:, 2 ), 'Color' , '#EDB120' , 'LineWidth' , 1.5 ) plot ( out2 . t , out2 . X { 2 }(:, 2 ), 'Color' , '#0072BD' , 'LineWidth' , 1.5 ) plot ( out2 . t , out2 . X { 1 }(:, 2 ), 'Color' , '#77AC30' , 'LineWidth' , 1.5 ) xlabel ( 'Time [s]' , 'FontSize' , 15 ); ylabel ( 'Frequency Deviation' , 'FontSize' , 15 ); legend ({ 'Frequency deviation of Generator 2 (without AGC)' , 'Frequency deviation of Generator 1 (without AGC)' , ... 'Frequency deviation of Generator 2 (with AGC)' , 'Frequency deviation of Generator 1 (with AGC)' }, ... 'Location' , 'east' ) title ( 'Frequency Deviation Synchronous Generator' , 'FontSize' , 20 ) hold off","title":"Complete Sample Code"},{"location":"SetEnvironment/0TopPage/","text":"GUILDA Setup \u00b6 This section explains how to download the public source code and set up the environment. Contents: Requirements Download Operation in MATLAB Workflow Requirements \u00b6 MATLAB Toolboxes necessary to run this simulator: Optimizaiton Toolbox. Control System Toolbox. Robus Control Toolbox. Download GUILDA Source Code \u00b6 The source code is available to the public on Git. Please use the link from the GUILDA introduction site on the Ishizaki Laboratory's website. You can clone and manage the download from the Git repository. The following images show the procedure to save the files to your local computer as a zip file. Operation in MATLAB \u00b6 To open GUILDA in MATLAB: Extract the source code zip file you have just downloaded, open MATLAB and navigate to the directory. Make sure that the \"current folder\" window of MATLAB is showing the correct directory. It can be checked by localizing the first folder @power_network , as shown in the image below. Check if the required toolboxes for GUILDA are installed. To do it write ver in the command window of MATLAB and check if the required toolboxes are installed, these are: Optimization Toolbox, Control System Toolbox, Robust Control Toolbox. Workflow \u00b6 In MATLAB it's possible to work one line at the time (via the command window), or several lines at the time (in a script), when performing analysis the latter is recommended. Recommended workflow: 1. Create a working directory: It is recommended that a separated working directory is created, as it will avoid mixing the new created code with the source code. In this example, a new directory named +user is created. The name of the directory can be anything, but make sure to put + at the beginning . This allows the m-files of the source code to be passed through, while also allowing the m-files in the +user folder to be executed. %Execution command mkdir + user 2. Create a new script file: Create a new script file by clicking on \"New Script\" in the upper left corner of the window, which will launch a new file in the editor. 3. Write the Analysis' Code: In the newly created script file, enter the code for the analysis you wish to perform. This documentation and its tutorials mainly focusses on explaining how to write the code in this area. However, for now, just to understand the workflow use the following code as an example; the details are explained in further sections. %Example code \"sample.m\" net = network_IEEE68bus ; Time = [ 0 , 10 ]; out = net . simulate ( Time , 'fault' , {{[ 1 , 1.01 ], 14 }}); figure ; hold on ; arrayfun (@( idx ) plot ( out . t , out . X { idx }(:, 2 )), 1 : 16 ); xlabel ( 'Time [s]' ) ylabel ( 'Frequency deviation [pu]' ) hold off 4. Execute: Save the script file you have created and actually execute it. For this example, we will save the script file as sample.m . Note that the newly created file sample.m can be seen now under the +user folder. To execute the code you can press the \"Run\" button or via the command window, for the latter use the command user.sample.m . This can be use since the user folder has + at the beginning of the directory name. Thus it can be executed as (directory name).(file name) . %Execution command user . sample 5. Analyze the Results: The analysis performed used the IEEE 68-bus Model, and the plot shows the frequency deviation response of each generator (connected to 1-16th busbar) at [0-10] seconds when a ground fault occurs on the 14th busbar during the timespan of [1-1.01] seconds. Create a working directory Save the sample file Run the file (via Editor) Run the file (via Command Window)","title":"GUILDA Setup"},{"location":"SetEnvironment/0TopPage/#guilda_setup","text":"This section explains how to download the public source code and set up the environment. Contents: Requirements Download Operation in MATLAB Workflow","title":"GUILDA Setup"},{"location":"SetEnvironment/0TopPage/#requirements","text":"MATLAB Toolboxes necessary to run this simulator: Optimizaiton Toolbox. Control System Toolbox. Robus Control Toolbox.","title":"Requirements"},{"location":"SetEnvironment/0TopPage/#download_guilda_source_code","text":"The source code is available to the public on Git. Please use the link from the GUILDA introduction site on the Ishizaki Laboratory's website. You can clone and manage the download from the Git repository. The following images show the procedure to save the files to your local computer as a zip file.","title":"Download GUILDA Source Code"},{"location":"SetEnvironment/0TopPage/#operation_in_matlab","text":"To open GUILDA in MATLAB: Extract the source code zip file you have just downloaded, open MATLAB and navigate to the directory. Make sure that the \"current folder\" window of MATLAB is showing the correct directory. It can be checked by localizing the first folder @power_network , as shown in the image below. Check if the required toolboxes for GUILDA are installed. To do it write ver in the command window of MATLAB and check if the required toolboxes are installed, these are: Optimization Toolbox, Control System Toolbox, Robust Control Toolbox.","title":"Operation in MATLAB"},{"location":"SetEnvironment/0TopPage/#workflow","text":"In MATLAB it's possible to work one line at the time (via the command window), or several lines at the time (in a script), when performing analysis the latter is recommended. Recommended workflow: 1. Create a working directory: It is recommended that a separated working directory is created, as it will avoid mixing the new created code with the source code. In this example, a new directory named +user is created. The name of the directory can be anything, but make sure to put + at the beginning . This allows the m-files of the source code to be passed through, while also allowing the m-files in the +user folder to be executed. %Execution command mkdir + user 2. Create a new script file: Create a new script file by clicking on \"New Script\" in the upper left corner of the window, which will launch a new file in the editor. 3. Write the Analysis' Code: In the newly created script file, enter the code for the analysis you wish to perform. This documentation and its tutorials mainly focusses on explaining how to write the code in this area. However, for now, just to understand the workflow use the following code as an example; the details are explained in further sections. %Example code \"sample.m\" net = network_IEEE68bus ; Time = [ 0 , 10 ]; out = net . simulate ( Time , 'fault' , {{[ 1 , 1.01 ], 14 }}); figure ; hold on ; arrayfun (@( idx ) plot ( out . t , out . X { idx }(:, 2 )), 1 : 16 ); xlabel ( 'Time [s]' ) ylabel ( 'Frequency deviation [pu]' ) hold off 4. Execute: Save the script file you have created and actually execute it. For this example, we will save the script file as sample.m . Note that the newly created file sample.m can be seen now under the +user folder. To execute the code you can press the \"Run\" button or via the command window, for the latter use the command user.sample.m . This can be use since the user folder has + at the beginning of the directory name. Thus it can be executed as (directory name).(file name) . %Execution command user . sample 5. Analyze the Results: The analysis performed used the IEEE 68-bus Model, and the plot shows the frequency deviation response of each generator (connected to 1-16th busbar) at [0-10] seconds when a ground fault occurs on the 14th busbar during the timespan of [1-1.01] seconds. Create a working directory Save the sample file Run the file (via Editor) Run the file (via Command Window)","title":"Workflow"},{"location":"SourceCode/0TopPage/","text":"Source Code Explanation \u00b6 This section explains the functions, properties, methods, classes, etc. used in the source code of GUILDA. Contents: Main Classes. Other Classes. Functions in the \"+function\" Directory. Functions in the \"+tools\" Directory. Main Classes \u00b6 In GUILDA there are mainly five \"super classes\", from which the rest are derived from. This section describes the member variables and methods implemented in these five super classes. Power Network Class ( power_network ) . Branch Class ( branch ) . Bus Class ( bus ) . Component Class ( component ) . Controller Class ( controller ) . Other Classes \u00b6 Explore Classes: In GUILDA, the basic rule is that classes and functions that are intended to be directly used by users, should have their purpose and usage commented out at the beginning of the \"m-file\". Thus, it is possible to find out such information by: 1. Opening the \"m-file\" or 2. by using the help or doc function as follows %If you want to examine the function of sample.m. help sample doc sample Example: The generator_1axis class, which represents a 1-Axis Synchronous Generator Model, is a child class of the component class that implements the equipment model. Therefore, please refer to the following component class description page for the explanation on its member variables and methods that the generator_1axis class inherits from the component class. For the member variables that are defined in the generator_1axis class, those can accessed by executing >> help generator_1axis Search Classes: To see the list of classes that are implemented on GUILDA, the function function.class_dictionary('class_name') . For more information please refer to the \"+function\" in this page, which contains a function for searching for classes. %To list all the classes that inherit from the \"handle\" class (no argument given). >> function . class_dictionary (); %To search for a specific class (e.g., the component class). >> function . class_dictionary ( 'component' ); Example: List all the classes that inherit from the \"handle\" class (no argument given). Search : \"handle\" class\uff0e\uff0e\uff0e handle class\uff1a ================================================== = Link \u3000\u3000 \u3000 class tree ================================================== = [ help ], [ doc ] handle [ help ], [ doc ] \u2523\u2501 tools . simulationResult [ help ], [ doc ] \u2523\u2501 tools . Reporter [ help ], [ doc ] \u2523\u2501 power_network [ help ], [ doc ] \u2503 \u2523\u2501 network_IEEE68bus [ help ], [ doc ] \u2503 \u2517\u2501 network_sample3bus [ help ], [ doc ] \u2523\u2501 avr [ help ], [ doc ] \u2503 \u2523\u2501 avr_IEEE_ST1 [ help ], [ doc ] \u2503 \u2517\u2501 avr_sadamoto2019 [ help ], [ doc ] \u2523\u2501 branch [ help ], [ doc ] \u2503 \u2523\u2501 branch_pi [ help ], [ doc ] \u2503 \u2517\u2501 branch_pi_transformer [ help ], [ doc ] \u2523\u2501 bus [ help ], [ doc ] \u2503 \u2523\u2501 bus_PQ [ help ], [ doc ] \u2503 \u2523\u2501 bus_PV [ help ], [ doc ] \u2503 \u2517\u2501 bus_slack [ help ], [ doc ] \u2523\u2501 component [ help ], [ doc ] \u2503 \u2523\u2501 component_empty [ help ], [ doc ] \u2503 \u2523\u2501 generator_1axis [ help ], [ doc ] \u2503 \u2523\u2501 generator_classical [ help ], [ doc ] \u2503 \u2517\u2501 load_impedance [ help ], [ doc ] \u2523\u2501 controller [ help ], [ doc ] \u2503 \u2517\u2501 controller_broadcast_PI_AGC [ help ], [ doc ] \u2523\u2501 governor [ help ], [ doc ] \u2517\u2501 pss ================================================== = Functions in the \"+function\" Directory \u00b6 This directory stores functions that may be useful for work efficiency in using GUILDA. In these documents, its purpose and usage is also commented out at the begining of the \"m-file\". Thus, the file can be directly explored, or by using the help or doc functions. Please take a look at them! Functions in the \"+tools\" Directory \u00b6 This directory stores functions used in the code of classes and functions. It is created for the purpose of modularization of frequently used executables and for better listing of the source code. Therefore, the code under this directory is not a function directly used by the user and will not be explained in this tutorial.","title":"Source Code Explanation"},{"location":"SourceCode/0TopPage/#source_code_explanation","text":"This section explains the functions, properties, methods, classes, etc. used in the source code of GUILDA. Contents: Main Classes. Other Classes. Functions in the \"+function\" Directory. Functions in the \"+tools\" Directory.","title":"Source Code Explanation"},{"location":"SourceCode/0TopPage/#main_classes","text":"In GUILDA there are mainly five \"super classes\", from which the rest are derived from. This section describes the member variables and methods implemented in these five super classes. Power Network Class ( power_network ) . Branch Class ( branch ) . Bus Class ( bus ) . Component Class ( component ) . Controller Class ( controller ) .","title":"Main Classes"},{"location":"SourceCode/0TopPage/#other_classes","text":"Explore Classes: In GUILDA, the basic rule is that classes and functions that are intended to be directly used by users, should have their purpose and usage commented out at the beginning of the \"m-file\". Thus, it is possible to find out such information by: 1. Opening the \"m-file\" or 2. by using the help or doc function as follows %If you want to examine the function of sample.m. help sample doc sample Example: The generator_1axis class, which represents a 1-Axis Synchronous Generator Model, is a child class of the component class that implements the equipment model. Therefore, please refer to the following component class description page for the explanation on its member variables and methods that the generator_1axis class inherits from the component class. For the member variables that are defined in the generator_1axis class, those can accessed by executing >> help generator_1axis Search Classes: To see the list of classes that are implemented on GUILDA, the function function.class_dictionary('class_name') . For more information please refer to the \"+function\" in this page, which contains a function for searching for classes. %To list all the classes that inherit from the \"handle\" class (no argument given). >> function . class_dictionary (); %To search for a specific class (e.g., the component class). >> function . class_dictionary ( 'component' ); Example: List all the classes that inherit from the \"handle\" class (no argument given). Search : \"handle\" class\uff0e\uff0e\uff0e handle class\uff1a ================================================== = Link \u3000\u3000 \u3000 class tree ================================================== = [ help ], [ doc ] handle [ help ], [ doc ] \u2523\u2501 tools . simulationResult [ help ], [ doc ] \u2523\u2501 tools . Reporter [ help ], [ doc ] \u2523\u2501 power_network [ help ], [ doc ] \u2503 \u2523\u2501 network_IEEE68bus [ help ], [ doc ] \u2503 \u2517\u2501 network_sample3bus [ help ], [ doc ] \u2523\u2501 avr [ help ], [ doc ] \u2503 \u2523\u2501 avr_IEEE_ST1 [ help ], [ doc ] \u2503 \u2517\u2501 avr_sadamoto2019 [ help ], [ doc ] \u2523\u2501 branch [ help ], [ doc ] \u2503 \u2523\u2501 branch_pi [ help ], [ doc ] \u2503 \u2517\u2501 branch_pi_transformer [ help ], [ doc ] \u2523\u2501 bus [ help ], [ doc ] \u2503 \u2523\u2501 bus_PQ [ help ], [ doc ] \u2503 \u2523\u2501 bus_PV [ help ], [ doc ] \u2503 \u2517\u2501 bus_slack [ help ], [ doc ] \u2523\u2501 component [ help ], [ doc ] \u2503 \u2523\u2501 component_empty [ help ], [ doc ] \u2503 \u2523\u2501 generator_1axis [ help ], [ doc ] \u2503 \u2523\u2501 generator_classical [ help ], [ doc ] \u2503 \u2517\u2501 load_impedance [ help ], [ doc ] \u2523\u2501 controller [ help ], [ doc ] \u2503 \u2517\u2501 controller_broadcast_PI_AGC [ help ], [ doc ] \u2523\u2501 governor [ help ], [ doc ] \u2517\u2501 pss ================================================== =","title":"Other Classes"},{"location":"SourceCode/0TopPage/#functions_in_the_function_directory","text":"This directory stores functions that may be useful for work efficiency in using GUILDA. In these documents, its purpose and usage is also commented out at the begining of the \"m-file\". Thus, the file can be directly explored, or by using the help or doc functions. Please take a look at them!","title":"Functions in the \"+function\" Directory"},{"location":"SourceCode/0TopPage/#functions_in_the_tools_directory","text":"This directory stores functions used in the code of classes and functions. It is created for the purpose of modularization of frequently used executables and for better listing of the source code. Therefore, the code under this directory is not a function directly used by the user and will not be explained in this tutorial.","title":"Functions in the \"+tools\" Directory"},{"location":"SourceCode/NetProperties/","text":"Power Network Class - Properties \u00b6 In GUILDA, the power system model is defined as a variable of the class power_network . The purpose of this section is to provide an imagine of what kind of power system model is implemented by looking at the values of the properties of this power_network class. Contents: Power System Model Power Network Class - Properties Equilibrium Properties. Busbar Properties. Branch Properties. Controller Properties. Extract Network Information Example 1 - Obtain Busbar Indexes. Example 2 - Obtain Busbar Power Flow Parameters. Example 3 - Obtain Busbar Components. Example 4 - Obtain Network's Graph. Power System Model \u00b6 For this example, the IEEE 68-bus 16-Machine Power System Model is used. This power model is already predefined in GUILDA, to create an instance of it, use the following command. net = network_IEEE68bus ; IEEE 68-bus Model Power Network Class - Properties \u00b6 This section explains all the variables (properties) included in the IEEE 68-bus power system model just defined in the net variable. To access that information, double-click in net in the workspace, which should show the following variables (properties) x_equilibrium V_equilibrium I_equilibrium a_bus a_controller_global a_controller_local a_branch Equilibrium Properties \u00b6 x_equilibrium : Equilibrium points of the state variables of the components (i.e., generators). In the case of this IEEE 68-bus model, there are 16 generators and 35 loads. Remember that each generator is defined by 7 internal states, while the load model has 0 states. Therefore, the number of states of this power system is \\(\\small (16 \\times 7) + (35 \\times 0) = 112\\) \". Thus, the number of elements of its equilibrium point ( x_equilibrium ) is also 112 x 1. The order of the elements corresponds to the order of the busbar they correspond, starting with the state variables of the busbar 1. Note: For details on the state variables for each component, please refer to the dedicated site New Components . V_equilibrium : Stores the voltage of the equilibrium point of each busbar in a complex array of \"busbars\" x 1. For this model with 68 busbars, a 68 x 1 array is obtained. I_equilibrium : Stores the current of the equilibrium point of each busbar in a complex array of \"busbars\" x 1. For this model with 68 busbars, a 68 x 1 array is obtained. Busbar Properties \u00b6 a_bus In GUILDA, the class bus is the one that stores the busbar information. Each busbar is defined as a variable of this class. On the other hand, the property a_bus contains the instances of the bus class as a properties in a cell array. Therefore, when the IEEE 68-bus model is defined, the a_bus property is a 68 x 1 cell array since there are 68 bus lines that make up the system. There are 6 variables in each bus cell array. Vabs : Voltage Magnitude \\(\\small (\\lvert V \\rvert)\\) . \\(\\star\\) Vangle : Voltage Phase Angle \\(\\small (\\angle V)\\) . \\(\\star\\) P : Active Power \\(\\small (P)\\) . \\(\\star\\) Q : Reactive Power \\(\\small (Q)\\) . \\(\\star\\) component : Defines what component (i.e., generator or load) is attached to each busbar. In this model, the busbar 1 to 16 have a generator attached (i.e., generator_1axis ). All classes that define devices in GUILDA, including generator_1axis , have are child classes of the \"super class\" called component . V_equlibrium : Array containing the Equilibrium Voltage \\(\\small (V)\\) ([real part; imaginary part]). I_equilibrium : Array containing the Equilibrium Current \\(\\small (V)\\) ([real part; imaginary part]). shunt : The shunt resistor admittance \\(\\small (Y_{shunt})\\) ([real part; imaginary part]) value between the bus and ground. If the busbar is not connected to Ground, then the admittance value is \\(0\\) . \\(\\star\\) Two of these properties are assigned to each busbar when it is defined, depending on the busbar type (i.e., PV bus, PQ bus, Slack bus). In the following image can be seen that the a_bus property has 1 cell array per bus (i.e., 68 cell arrays in total). Each cell array contains the information that defines the bus, depending on the type of bus. Branch Properties \u00b6 a_branch Similarly to the case of the a_bus property. In GUILDA, the class branch is the one that stores the branch information. Each branch is defined as a variable of this class. The property a_branch contains the instances of the branch class as a properties in a cell array. Therefore, when the IEEE 68-bus model is defined, the a_branch property is a 83 x 1 cell array since there are 83 branches (i.e., transmission lines) that make up the system. There are 6 variables in each branch cell array. from : Busbar number that the branch (i.e., transmission lines) connect from. to :Busbar number that the branch (i.e., transmission lines) connect to. x : Real and Imaginary part of the branch's impedance (i.e., Resistance \\(\\small (R)\\) and Reactance \\(\\small (X)\\) ). The reciprocal of these values are Conductance \\(\\small (G)\\) and Susceptance \\(\\small (B)\\) , respectively. y : Ground Capacitance of the branch. tap : Phase Adjustment of Transformer Parameters. phase : Phase Adjustment of Transformer Parameters. In the following image can be seen that the a_branch property has 1 cell array per branch (i.e., 83 cell arrays in total). Each cell array contains the information that defines the branch, depending on the branch type (i.e., Transformer Branch or Transmission Branch). Controller Properties \u00b6 a_controller_local & a_controller_global Similarly to the case of the a_bus and a_branch properties. In GUILDA, the class controller_broadcast_PI_AGC_normal defines the Global controller Automatic Generation Control (AGC). Meanwhile, local controllers, like the Retrofit control, can be implement as a new class, however they must be firstly defined as such. In a 3-bus model: Taking as example the a_controller_global generated from the AGC Controller ( controller_broadcast_PI_AGC_normal ), which is added to busbar 1 and 2 (i.e., the ones with generators) as observation and input targers. Then, there is only 1 cell array, since it's global, an its variables are Kp : Proportional gain of the controller. Ki : Integrative gain of the controller. K_input : ASK K_observe : ASK index_input : Busbar number to which the output signal of the controller (i.e., the input signal to the system) is applied. index_observe : Busbar number observed by the controller. index_all : Busbar number that are observed and to which input is applied to. get_dx_u_func : Function to obtain the controller state derivative. Note: For more examples on the controller class, plese refer to the dedicated site Controllers . In the following image can be seen that the a_controller_global property has 1 cell array. It contains the information that defines the global controller. Extract Network Information \u00b6 The following are a series of examples on how to extract values from the properties of the power_network class and process them well to organize the information of the power system model. Example 1 - Obtain Busbar Indexes \u00b6 To obtain the indexes of the busbars according to its type (i.e., PV bus, PQ bus, Slack bus). bus_num = numel ( net . a_bus ); bus_idx = zeros ( 1 , bus_num ); for idx = 1 : bus_num switch class(net.a_bus{idx}) case 'bus_PV' bus_idx ( idx ) = 1 ; case 'bus_PQ' bus_idx ( idx ) = 2 ; case 'bus_slack' bus_idx ( idx ) = 3 ; end end PV_bus_idx = find ( bus_idx == 1 ) PQ_bus_idx = find ( bus_idx == 2 ) slack_bus_idx = find ( bus_idx == 3 ) Example 2 - Obtain Busbar Power Flow Parameters \u00b6 To obtain the power flow parameters (i.e., active power, reactive power, voltage magnitude, voltage phase angle) of each busbar. bus_num = numel ( net . a_bus ); bus_idx = cell ( bus_num , 1 ); Vabs = nan ( bus_num , 1 ); Vangle = nan ( bus_num , 1 ); P = nan ( bus_num , 1 ); Q = nan ( bus_num , 1 ); for idx = 1 : bus_num switch class(net.a_bus{idx}) case 'bus_PV' P ( idx ) = net . a_bus { idx }. P ; Vabs ( idx ) = net . a_bus { idx }. Vabs ; case 'bus_PQ' P ( idx ) = net . a_bus { idx }. P ; Q ( idx ) = net . a_bus { idx }. Q ; case 'bus_slack' Vabs ( idx ) = net . a_bus { idx }. Vabs ; Vangle ( idx )= net . a_bus { idx }. Vangle ; end end idx = ( 1 : bus_num ) ' ; powerflow_set = table ( idx , Vabs , Vangle , P , Q ) Example 3 - Obtain Busbar Components \u00b6 To obtain the type of component (i.e., generator or load) that is connected to each busbar. bus_num = numel ( net . a_bus ); component_list = arrayfun (@( idx ) {[ 'bus' , num2str ( idx )] , class ( net . a_bus { idx }. component )},( 1 : bus_num ) ' , 'UniformOutput' , false ); cell2table ( vertcat ( component_list {:}) , \"VariableNames\" ,[ \"idx\" \"component\" ]) Example 4 - Obtain Network's Graph \u00b6 To obtain a visual graph of the structure of the power system model. branch_num = numel ( net . a_branch ); bus_num = numel ( net . a_bus ); adjacency_matrix = zeros ( bus_num , bus_num ); for idx = 1 : branch_num from = net . a_branch { idx }. from ; to = net . a_branch { idx }. to ; adjacency_matrix ( from , to )= 1 ; adjacency_matrix ( to , from )= 1 ; end plot(graph(adjacency_matrix))","title":"Power Network Class - Properties"},{"location":"SourceCode/NetProperties/#power_network_class_-_properties","text":"In GUILDA, the power system model is defined as a variable of the class power_network . The purpose of this section is to provide an imagine of what kind of power system model is implemented by looking at the values of the properties of this power_network class. Contents: Power System Model Power Network Class - Properties Equilibrium Properties. Busbar Properties. Branch Properties. Controller Properties. Extract Network Information Example 1 - Obtain Busbar Indexes. Example 2 - Obtain Busbar Power Flow Parameters. Example 3 - Obtain Busbar Components. Example 4 - Obtain Network's Graph.","title":"Power Network Class - Properties"},{"location":"SourceCode/NetProperties/#power_system_model","text":"For this example, the IEEE 68-bus 16-Machine Power System Model is used. This power model is already predefined in GUILDA, to create an instance of it, use the following command. net = network_IEEE68bus ; IEEE 68-bus Model","title":"Power System Model"},{"location":"SourceCode/NetProperties/#power_network_class_-_properties_1","text":"This section explains all the variables (properties) included in the IEEE 68-bus power system model just defined in the net variable. To access that information, double-click in net in the workspace, which should show the following variables (properties) x_equilibrium V_equilibrium I_equilibrium a_bus a_controller_global a_controller_local a_branch","title":"Power Network Class - Properties"},{"location":"SourceCode/NetProperties/#equilibrium_properties","text":"x_equilibrium : Equilibrium points of the state variables of the components (i.e., generators). In the case of this IEEE 68-bus model, there are 16 generators and 35 loads. Remember that each generator is defined by 7 internal states, while the load model has 0 states. Therefore, the number of states of this power system is \\(\\small (16 \\times 7) + (35 \\times 0) = 112\\) \". Thus, the number of elements of its equilibrium point ( x_equilibrium ) is also 112 x 1. The order of the elements corresponds to the order of the busbar they correspond, starting with the state variables of the busbar 1. Note: For details on the state variables for each component, please refer to the dedicated site New Components . V_equilibrium : Stores the voltage of the equilibrium point of each busbar in a complex array of \"busbars\" x 1. For this model with 68 busbars, a 68 x 1 array is obtained. I_equilibrium : Stores the current of the equilibrium point of each busbar in a complex array of \"busbars\" x 1. For this model with 68 busbars, a 68 x 1 array is obtained.","title":"Equilibrium Properties"},{"location":"SourceCode/NetProperties/#busbar_properties","text":"a_bus In GUILDA, the class bus is the one that stores the busbar information. Each busbar is defined as a variable of this class. On the other hand, the property a_bus contains the instances of the bus class as a properties in a cell array. Therefore, when the IEEE 68-bus model is defined, the a_bus property is a 68 x 1 cell array since there are 68 bus lines that make up the system. There are 6 variables in each bus cell array. Vabs : Voltage Magnitude \\(\\small (\\lvert V \\rvert)\\) . \\(\\star\\) Vangle : Voltage Phase Angle \\(\\small (\\angle V)\\) . \\(\\star\\) P : Active Power \\(\\small (P)\\) . \\(\\star\\) Q : Reactive Power \\(\\small (Q)\\) . \\(\\star\\) component : Defines what component (i.e., generator or load) is attached to each busbar. In this model, the busbar 1 to 16 have a generator attached (i.e., generator_1axis ). All classes that define devices in GUILDA, including generator_1axis , have are child classes of the \"super class\" called component . V_equlibrium : Array containing the Equilibrium Voltage \\(\\small (V)\\) ([real part; imaginary part]). I_equilibrium : Array containing the Equilibrium Current \\(\\small (V)\\) ([real part; imaginary part]). shunt : The shunt resistor admittance \\(\\small (Y_{shunt})\\) ([real part; imaginary part]) value between the bus and ground. If the busbar is not connected to Ground, then the admittance value is \\(0\\) . \\(\\star\\) Two of these properties are assigned to each busbar when it is defined, depending on the busbar type (i.e., PV bus, PQ bus, Slack bus). In the following image can be seen that the a_bus property has 1 cell array per bus (i.e., 68 cell arrays in total). Each cell array contains the information that defines the bus, depending on the type of bus.","title":"Busbar Properties"},{"location":"SourceCode/NetProperties/#branch_properties","text":"a_branch Similarly to the case of the a_bus property. In GUILDA, the class branch is the one that stores the branch information. Each branch is defined as a variable of this class. The property a_branch contains the instances of the branch class as a properties in a cell array. Therefore, when the IEEE 68-bus model is defined, the a_branch property is a 83 x 1 cell array since there are 83 branches (i.e., transmission lines) that make up the system. There are 6 variables in each branch cell array. from : Busbar number that the branch (i.e., transmission lines) connect from. to :Busbar number that the branch (i.e., transmission lines) connect to. x : Real and Imaginary part of the branch's impedance (i.e., Resistance \\(\\small (R)\\) and Reactance \\(\\small (X)\\) ). The reciprocal of these values are Conductance \\(\\small (G)\\) and Susceptance \\(\\small (B)\\) , respectively. y : Ground Capacitance of the branch. tap : Phase Adjustment of Transformer Parameters. phase : Phase Adjustment of Transformer Parameters. In the following image can be seen that the a_branch property has 1 cell array per branch (i.e., 83 cell arrays in total). Each cell array contains the information that defines the branch, depending on the branch type (i.e., Transformer Branch or Transmission Branch).","title":"Branch Properties"},{"location":"SourceCode/NetProperties/#controller_properties","text":"a_controller_local & a_controller_global Similarly to the case of the a_bus and a_branch properties. In GUILDA, the class controller_broadcast_PI_AGC_normal defines the Global controller Automatic Generation Control (AGC). Meanwhile, local controllers, like the Retrofit control, can be implement as a new class, however they must be firstly defined as such. In a 3-bus model: Taking as example the a_controller_global generated from the AGC Controller ( controller_broadcast_PI_AGC_normal ), which is added to busbar 1 and 2 (i.e., the ones with generators) as observation and input targers. Then, there is only 1 cell array, since it's global, an its variables are Kp : Proportional gain of the controller. Ki : Integrative gain of the controller. K_input : ASK K_observe : ASK index_input : Busbar number to which the output signal of the controller (i.e., the input signal to the system) is applied. index_observe : Busbar number observed by the controller. index_all : Busbar number that are observed and to which input is applied to. get_dx_u_func : Function to obtain the controller state derivative. Note: For more examples on the controller class, plese refer to the dedicated site Controllers . In the following image can be seen that the a_controller_global property has 1 cell array. It contains the information that defines the global controller.","title":"Controller Properties"},{"location":"SourceCode/NetProperties/#extract_network_information","text":"The following are a series of examples on how to extract values from the properties of the power_network class and process them well to organize the information of the power system model.","title":"Extract Network Information"},{"location":"SourceCode/NetProperties/#example_1_-_obtain_busbar_indexes","text":"To obtain the indexes of the busbars according to its type (i.e., PV bus, PQ bus, Slack bus). bus_num = numel ( net . a_bus ); bus_idx = zeros ( 1 , bus_num ); for idx = 1 : bus_num switch class(net.a_bus{idx}) case 'bus_PV' bus_idx ( idx ) = 1 ; case 'bus_PQ' bus_idx ( idx ) = 2 ; case 'bus_slack' bus_idx ( idx ) = 3 ; end end PV_bus_idx = find ( bus_idx == 1 ) PQ_bus_idx = find ( bus_idx == 2 ) slack_bus_idx = find ( bus_idx == 3 )","title":"Example 1 - Obtain Busbar Indexes"},{"location":"SourceCode/NetProperties/#example_2_-_obtain_busbar_power_flow_parameters","text":"To obtain the power flow parameters (i.e., active power, reactive power, voltage magnitude, voltage phase angle) of each busbar. bus_num = numel ( net . a_bus ); bus_idx = cell ( bus_num , 1 ); Vabs = nan ( bus_num , 1 ); Vangle = nan ( bus_num , 1 ); P = nan ( bus_num , 1 ); Q = nan ( bus_num , 1 ); for idx = 1 : bus_num switch class(net.a_bus{idx}) case 'bus_PV' P ( idx ) = net . a_bus { idx }. P ; Vabs ( idx ) = net . a_bus { idx }. Vabs ; case 'bus_PQ' P ( idx ) = net . a_bus { idx }. P ; Q ( idx ) = net . a_bus { idx }. Q ; case 'bus_slack' Vabs ( idx ) = net . a_bus { idx }. Vabs ; Vangle ( idx )= net . a_bus { idx }. Vangle ; end end idx = ( 1 : bus_num ) ' ; powerflow_set = table ( idx , Vabs , Vangle , P , Q )","title":"Example 2 - Obtain Busbar Power Flow Parameters"},{"location":"SourceCode/NetProperties/#example_3_-_obtain_busbar_components","text":"To obtain the type of component (i.e., generator or load) that is connected to each busbar. bus_num = numel ( net . a_bus ); component_list = arrayfun (@( idx ) {[ 'bus' , num2str ( idx )] , class ( net . a_bus { idx }. component )},( 1 : bus_num ) ' , 'UniformOutput' , false ); cell2table ( vertcat ( component_list {:}) , \"VariableNames\" ,[ \"idx\" \"component\" ])","title":"Example 3 - Obtain Busbar Components"},{"location":"SourceCode/NetProperties/#example_4_-_obtain_networks_graph","text":"To obtain a visual graph of the structure of the power system model. branch_num = numel ( net . a_branch ); bus_num = numel ( net . a_bus ); adjacency_matrix = zeros ( bus_num , bus_num ); for idx = 1 : branch_num from = net . a_branch { idx }. from ; to = net . a_branch { idx }. to ; adjacency_matrix ( from , to )= 1 ; adjacency_matrix ( to , from )= 1 ; end plot(graph(adjacency_matrix))","title":"Example 4 - Obtain Network's Graph"},{"location":"SourceCode/branch/","text":"Branch Class \u00b6 This page explains the variables and functions used in the branch class ( branch ). Contents: Branch Class Branch Pi-Type Circuit Model Class Branch Pi-Type Circuit with Transformer Model Class Branch Class \u00b6 The branch class is one of the \"super classes\" in GUILDA. There are two main child classes that are derived from the branch class: 1. Branch Pi-Type Circuit Model Class ( branch_pi ), and 2. Branch Pi-Type Circuit with Transformer Model Class ( branch_pi_transformer ). graph TD branch---branch_pi branch---branch_pi_transformer The branch super class is composed of Variables from : Busbar number that the branch (i.e., transmission lines) connect from. to : Busbar number that the branch (i.e., transmission lines) connect to. Abstract Methods y = get_admittance_matrix(obj) : Function to generate the network's admittance matrix. Branch Pi-Type Circuit Model Class \u00b6 This child class implements the \u03c0-type circuit model of a transmission line with ground-to-ground capacitance. Variables x : Real and Imaginary part of the branch's impedance (i.e., Resistance \\(\\small (R)\\) and Reactance \\(\\small (X)\\) ). The reciprocal of these values are Conductance \\(\\small (G)\\) and Susceptance \\(\\small (B)\\) , respectively. y : Ground Capacitance of the branch. Constructor Method obj = branch_pi(from, to, x, y) : The arguments are the variables explained above. Branch Pi-Type Circuit with Transformer Model Class \u00b6 This child class implements the \u03c0-type circuit model of a transmission line with ground capacitance and a phase adjusting transformer built in. Variables x : Real and Imaginary part of the branch's impedance (i.e., Resistance \\(\\small (R)\\) and Reactance \\(\\small (X)\\) ). The reciprocal of these values are Conductance \\(\\small (G)\\) and Susceptance \\(\\small (B)\\) , respectively. y : Ground Capacitance of the branch. tap \uff1aTransformer's gain. phase \uff1aTransformer's phase difference. Constructor Method obj = branch_pi_transformer(from, to, x, y, tap, phase) : The arguments are the variables explained above.","title":"Branch Class"},{"location":"SourceCode/branch/#branch_class","text":"This page explains the variables and functions used in the branch class ( branch ). Contents: Branch Class Branch Pi-Type Circuit Model Class Branch Pi-Type Circuit with Transformer Model Class","title":"Branch Class"},{"location":"SourceCode/branch/#branch_class_1","text":"The branch class is one of the \"super classes\" in GUILDA. There are two main child classes that are derived from the branch class: 1. Branch Pi-Type Circuit Model Class ( branch_pi ), and 2. Branch Pi-Type Circuit with Transformer Model Class ( branch_pi_transformer ). graph TD branch---branch_pi branch---branch_pi_transformer The branch super class is composed of Variables from : Busbar number that the branch (i.e., transmission lines) connect from. to : Busbar number that the branch (i.e., transmission lines) connect to. Abstract Methods y = get_admittance_matrix(obj) : Function to generate the network's admittance matrix.","title":"Branch Class"},{"location":"SourceCode/branch/#branch_pi-type_circuit_model_class","text":"This child class implements the \u03c0-type circuit model of a transmission line with ground-to-ground capacitance. Variables x : Real and Imaginary part of the branch's impedance (i.e., Resistance \\(\\small (R)\\) and Reactance \\(\\small (X)\\) ). The reciprocal of these values are Conductance \\(\\small (G)\\) and Susceptance \\(\\small (B)\\) , respectively. y : Ground Capacitance of the branch. Constructor Method obj = branch_pi(from, to, x, y) : The arguments are the variables explained above.","title":"Branch Pi-Type Circuit Model Class"},{"location":"SourceCode/branch/#branch_pi-type_circuit_with_transformer_model_class","text":"This child class implements the \u03c0-type circuit model of a transmission line with ground capacitance and a phase adjusting transformer built in. Variables x : Real and Imaginary part of the branch's impedance (i.e., Resistance \\(\\small (R)\\) and Reactance \\(\\small (X)\\) ). The reciprocal of these values are Conductance \\(\\small (G)\\) and Susceptance \\(\\small (B)\\) , respectively. y : Ground Capacitance of the branch. tap \uff1aTransformer's gain. phase \uff1aTransformer's phase difference. Constructor Method obj = branch_pi_transformer(from, to, x, y, tap, phase) : The arguments are the variables explained above.","title":"Branch Pi-Type Circuit with Transformer Model Class"},{"location":"SourceCode/bus/","text":"Bus Class \u00b6 This page explains the variables and functions used in the bus class ( bus ). Contents: Bus Class Slack Bus PV Bus PQ Bus Bus Class \u00b6 The bus class is one of the \"super classes\" in GUILDA. There are three main child classes that are derived from the bus class: 1. Slack Bus ( bus_slack ), 2. PV Bus ( bus_PV ), 3. PQ Bus ( bus_PQ ). graph TD bus---bus_PQ bus---bus_PV bus---bus_slack The bus super class is composed of Variables component : Defines what component (i.e., generator or load) is attached to each busbar. In this model, the busbar 1 to 16 have a generator attached (i.e., generator_1axis ). All classes that define devices in GUILDA, including generator_1axis , have are child classes of the \"super class\" called component . V_equilibrium : Array containing the Equilibrium Voltage \\(\\small (V)\\) ([real part; imaginary part]). I_equilibrium : Array containing the Equilibrium Current \\(\\small (I)\\) ([real part; imaginary part]). shunt : The shunt resistor admittance \\(\\small (Y_{shunt})\\) ([real part; imaginary part]) value between the bus and ground. If the busbar is not connected to Ground, then the admittance value is \\(0\\) . Constructor Method set_component(obj, component) : Instances of the component class, for example generators, loads, or controllers. Slack Bus \u00b6 Most of the Buses with Generators are classified as PV buses. However, one of those buses is classified as a Slack Bus. The main difference is that it is specified by the voltage magnitude \\(\\small (\\lvert V \\rvert)\\) and the voltage phase angle \\(\\small (\\angle V)\\) . This is necessary because the voltage phase difference between the busbars can generally be obtained, but the voltage phase of each busbar is not uniquely determined. Therefore, specifying the voltage phase angle of one busbar allows to uniquely determine the voltage phase angle of the rest of busbars. Additionally, if multiple slack buses are defined, it may happen that no solution satisfies all the specified parameters. This is why there is only one slack bus for all matrices. Variables Vabs : Voltage Magnitude \\(\\small (\\lvert V \\rvert)\\) . Vangle : Voltage Phase Angle \\(\\small (\\angle V)\\) . shunt : The shunt resistor admittance \\(\\small (Y_{shunt})\\) ([real part; imaginary part]) value between the bus and ground. If the busbar is not connected to Ground, then the admittance value is \\(0\\) . Constructor Method obj = bus_slack(Vabs, Vangle, shunt) : The arguments are the variables explained above. PV Bus \u00b6 Generator buses are generally classified as PV buses, since they are defined by the active power \\(\\small (P)\\) and the voltage magnitude \\(\\small (\\lvert V \\rvert)\\) . Variables P : Active Power \\(\\small (P)\\) . Vabs : Voltage Magnitude \\(\\small (\\lvert V \\rvert)\\) . shunt : The shunt resistor admittance \\(\\small (Y_{shunt})\\) ([real part; imaginary part]) value between the bus and ground. If the busbar is not connected to Ground, then the admittance value is \\(0\\) . Constructor Method obj =bus_PV(P, V, shunt) : The arguments are the variables explained above. PQ Bus \u00b6 Load buses and Non-unit buses (i.e., buses with no load) are classified as PQ buses, since they are defined by the active power \\(\\small (P)\\) and reactive power \\(\\small (Q)\\) . Regarding Non-unit buses: These are busbars with no load added. They serve as interconnection points between transmission lines. However, they are also classified as PQ buses, since they can be regarded as load busbars with an infinite load. Variables P : Active Power \\(\\small (P)\\) . Q : Reactive Power \\(\\small (Q)\\) . shunt : The shunt resistor admittance \\(\\small (Y_{shunt})\\) ([real part; imaginary part]) value between the bus and ground. If the busbar is not connected to Ground, then the admittance value is \\(0\\) . Constructor Method obj =bus_PQ(P, V, shunt) : The arguments are the variables explained above.","title":"Bus Class"},{"location":"SourceCode/bus/#bus_class","text":"This page explains the variables and functions used in the bus class ( bus ). Contents: Bus Class Slack Bus PV Bus PQ Bus","title":"Bus Class"},{"location":"SourceCode/bus/#bus_class_1","text":"The bus class is one of the \"super classes\" in GUILDA. There are three main child classes that are derived from the bus class: 1. Slack Bus ( bus_slack ), 2. PV Bus ( bus_PV ), 3. PQ Bus ( bus_PQ ). graph TD bus---bus_PQ bus---bus_PV bus---bus_slack The bus super class is composed of Variables component : Defines what component (i.e., generator or load) is attached to each busbar. In this model, the busbar 1 to 16 have a generator attached (i.e., generator_1axis ). All classes that define devices in GUILDA, including generator_1axis , have are child classes of the \"super class\" called component . V_equilibrium : Array containing the Equilibrium Voltage \\(\\small (V)\\) ([real part; imaginary part]). I_equilibrium : Array containing the Equilibrium Current \\(\\small (I)\\) ([real part; imaginary part]). shunt : The shunt resistor admittance \\(\\small (Y_{shunt})\\) ([real part; imaginary part]) value between the bus and ground. If the busbar is not connected to Ground, then the admittance value is \\(0\\) . Constructor Method set_component(obj, component) : Instances of the component class, for example generators, loads, or controllers.","title":"Bus Class"},{"location":"SourceCode/bus/#slack_bus","text":"Most of the Buses with Generators are classified as PV buses. However, one of those buses is classified as a Slack Bus. The main difference is that it is specified by the voltage magnitude \\(\\small (\\lvert V \\rvert)\\) and the voltage phase angle \\(\\small (\\angle V)\\) . This is necessary because the voltage phase difference between the busbars can generally be obtained, but the voltage phase of each busbar is not uniquely determined. Therefore, specifying the voltage phase angle of one busbar allows to uniquely determine the voltage phase angle of the rest of busbars. Additionally, if multiple slack buses are defined, it may happen that no solution satisfies all the specified parameters. This is why there is only one slack bus for all matrices. Variables Vabs : Voltage Magnitude \\(\\small (\\lvert V \\rvert)\\) . Vangle : Voltage Phase Angle \\(\\small (\\angle V)\\) . shunt : The shunt resistor admittance \\(\\small (Y_{shunt})\\) ([real part; imaginary part]) value between the bus and ground. If the busbar is not connected to Ground, then the admittance value is \\(0\\) . Constructor Method obj = bus_slack(Vabs, Vangle, shunt) : The arguments are the variables explained above.","title":"Slack Bus"},{"location":"SourceCode/bus/#pv_bus","text":"Generator buses are generally classified as PV buses, since they are defined by the active power \\(\\small (P)\\) and the voltage magnitude \\(\\small (\\lvert V \\rvert)\\) . Variables P : Active Power \\(\\small (P)\\) . Vabs : Voltage Magnitude \\(\\small (\\lvert V \\rvert)\\) . shunt : The shunt resistor admittance \\(\\small (Y_{shunt})\\) ([real part; imaginary part]) value between the bus and ground. If the busbar is not connected to Ground, then the admittance value is \\(0\\) . Constructor Method obj =bus_PV(P, V, shunt) : The arguments are the variables explained above.","title":"PV Bus"},{"location":"SourceCode/bus/#pq_bus","text":"Load buses and Non-unit buses (i.e., buses with no load) are classified as PQ buses, since they are defined by the active power \\(\\small (P)\\) and reactive power \\(\\small (Q)\\) . Regarding Non-unit buses: These are busbars with no load added. They serve as interconnection points between transmission lines. However, they are also classified as PQ buses, since they can be regarded as load busbars with an infinite load. Variables P : Active Power \\(\\small (P)\\) . Q : Reactive Power \\(\\small (Q)\\) . shunt : The shunt resistor admittance \\(\\small (Y_{shunt})\\) ([real part; imaginary part]) value between the bus and ground. If the busbar is not connected to Ground, then the admittance value is \\(0\\) . Constructor Method obj =bus_PQ(P, V, shunt) : The arguments are the variables explained above.","title":"PQ Bus"},{"location":"SourceCode/component/","text":"Component Class \u00b6 This page explains the variables and functions used in the component class ( component ). Contents: Component Class Empty Component Generator Load Component Class \u00b6 The component class is one of the \"super classes\" in GUILDA. As the name implies, a component is a piece of equipment, such as generators or loads. There are three main child classes that are derived from the component class: 1. Empty Component ( component_empty ), 2. Generator ( generator_1axis ), 3. Load ( load_impedance ). graph TD component---component_empty component---generator_1axis component---load_impedance The component super class is composed of Abstract Methods \u00b6 Set Equilibrium ( set_equilibrium(obj,Veq,Ieq) ) This method performs the initialization processing, determines the equilibrium points via power flow calculation (equilibrium voltage \\(\\small (V_{eq})\\) and equilibrium current \\(\\small (I_{eq})\\) ), and derives the equilibrium state. Structure: x = set_equilibrium(obj,Veq,Ieq) Input Arguments Veq : Equilibrium point of the voltage (complex number) \\(-\\) obtained from the power flow calculation. Ieq : Equilibrium point of the current (complex number) \\(-\\) obtained from the power flow calculation. Output Parameters x \uff1aEquilibrium state corresponding to the specified equilibrium point. Input State Order ( get_nu(obj) ) This method is used to determine the order of the input state ( u ). Class Structure nu = get_nu(obj) Input Arguments None Output Parameters nu \uff1aOrder of input state ( u ). State Derivative ( get_dx_constraint(obj,t, x, V, I, u) ) This method is used to obtain the derivative of the state \\(\\small (x)\\) ; when an input is applied it also provides the derivative of the current \\(\\small (I)\\) . Class Structure: [dx,constraint] = get_dx_constraint(obj,t, x, V, I, u) Input Arguments t : Time \\(\\small (t)\\) . x : State \\(\\small (x)\\) . V : Busbar Voltage \\(\\small (V)\\) ([real part; imaginary part]). I : Busbar Current \\(\\small (I)\\) ([real part; imaginary part]). u : Input Signal \\(\\small (u)\\) . Output arguments dx \uff1aDerivative of the State \\(\\small (\\dot{x})\\) . constraint \uff1aThe difference between the actual busbar's current \\(\\small (I)\\) and the derived one from the provided arguments \"state\" \\(\\small (x)\\) and \"voltage\" \\(\\small (V)\\) . The constraint condition is that the difference between both currents \\(\\small (I)\\) should be zero. Empty Component \u00b6 This child class implements an empty device ( component_empty ), that means that it only inherits all the characteristics of the parent class, but doesn't add anything. Generator \u00b6 This child class implementats a generator model. In GUILDA a 1-Axis Synchronous Generator Model is used ( generator_1axis ). Variables \u00b6 Generator Parameters ( x ) Xd : Synchronous Reactance around the d-axis \\(\\small (X_d)\\) . Xq : Synchronous Reactance around the q-axis \\(\\small (X_q)\\) . Xd_prime : Transient Synchronous Reactance around the d-axis \\(\\small (X'_d)\\) . T \uff1aTime constant of the field current around the d-axis \\(\\small (\\tau)\\) . M \uff1aInertia Coefficient \\(\\small (M)\\) . D \uff1aDamping Factor \\(\\small (D)\\) . Equilibrium State ( x_equilibrium ) Equilibrium point of the internal state of the generator delta \uff1aRotor declination angle \\(\\small (\\delta)\\) . omega \uff1aAngular frequency deviation \\(\\small (\\Delta \\omega)\\) . E \uff1aInternal voltage \\(\\small (E)\\) . x_avr \uff1aAutomatic Voltage Regulator (AVR) State. x_gov \uff1aGovernor State. x_pss \uff1aPower System Stabilizer (PSS) State. Equilibrium Voltage ( V_equilibrium ) Array containing the Equilibrium Voltage \\(\\small (V)\\) ([real part; imaginary part]). Equilibrium Current ( I_equilibrium ) Array containing the Equilibrium Current \\(\\small (I)\\) ([real part; imaginary part]). Automatic Voltage Regulator (AVR) Controller ( set_avr ) Ka \uff1aAVR Gain. Te \uff1aExciter Time Constant. Governor governor \uff1aInstance of the governor class. Power System Stabilizer ( set_pss ) Kpss : PSS Gain. Tpss : Washout Filter Time Constant. TL1p, TL1 : Phase Advance-Delay Time Constant of the First Stage. TL2p, TL2 : Phase Advance-Delay Time Constant of the Second Stage. omega0 \uff1aReference Angular Frequency (Grid's frequency \\(\\small (\\omega_0)\\) ). Methods \u00b6 obj = generator_1axis(omega, parameter) omega \uff1aReference Angular Frequency (Grid's frequency \\(\\small (\\omega_0)\\) ). parameter \uff1aGenerator parameters (see above). Load \u00b6 This child class implements a constant impedance load model ( load_impedance ). Methods \u00b6 obj = load_impedance(varargin) Impedance values are determined from equilibrium voltage and equilibrium current; thus, no arguments are required.","title":"Component Class"},{"location":"SourceCode/component/#component_class","text":"This page explains the variables and functions used in the component class ( component ). Contents: Component Class Empty Component Generator Load","title":"Component Class"},{"location":"SourceCode/component/#component_class_1","text":"The component class is one of the \"super classes\" in GUILDA. As the name implies, a component is a piece of equipment, such as generators or loads. There are three main child classes that are derived from the component class: 1. Empty Component ( component_empty ), 2. Generator ( generator_1axis ), 3. Load ( load_impedance ). graph TD component---component_empty component---generator_1axis component---load_impedance The component super class is composed of","title":"Component Class"},{"location":"SourceCode/component/#abstract_methods","text":"Set Equilibrium ( set_equilibrium(obj,Veq,Ieq) ) This method performs the initialization processing, determines the equilibrium points via power flow calculation (equilibrium voltage \\(\\small (V_{eq})\\) and equilibrium current \\(\\small (I_{eq})\\) ), and derives the equilibrium state. Structure: x = set_equilibrium(obj,Veq,Ieq) Input Arguments Veq : Equilibrium point of the voltage (complex number) \\(-\\) obtained from the power flow calculation. Ieq : Equilibrium point of the current (complex number) \\(-\\) obtained from the power flow calculation. Output Parameters x \uff1aEquilibrium state corresponding to the specified equilibrium point. Input State Order ( get_nu(obj) ) This method is used to determine the order of the input state ( u ). Class Structure nu = get_nu(obj) Input Arguments None Output Parameters nu \uff1aOrder of input state ( u ). State Derivative ( get_dx_constraint(obj,t, x, V, I, u) ) This method is used to obtain the derivative of the state \\(\\small (x)\\) ; when an input is applied it also provides the derivative of the current \\(\\small (I)\\) . Class Structure: [dx,constraint] = get_dx_constraint(obj,t, x, V, I, u) Input Arguments t : Time \\(\\small (t)\\) . x : State \\(\\small (x)\\) . V : Busbar Voltage \\(\\small (V)\\) ([real part; imaginary part]). I : Busbar Current \\(\\small (I)\\) ([real part; imaginary part]). u : Input Signal \\(\\small (u)\\) . Output arguments dx \uff1aDerivative of the State \\(\\small (\\dot{x})\\) . constraint \uff1aThe difference between the actual busbar's current \\(\\small (I)\\) and the derived one from the provided arguments \"state\" \\(\\small (x)\\) and \"voltage\" \\(\\small (V)\\) . The constraint condition is that the difference between both currents \\(\\small (I)\\) should be zero.","title":"Abstract Methods"},{"location":"SourceCode/component/#empty_component","text":"This child class implements an empty device ( component_empty ), that means that it only inherits all the characteristics of the parent class, but doesn't add anything.","title":"Empty Component"},{"location":"SourceCode/component/#generator","text":"This child class implementats a generator model. In GUILDA a 1-Axis Synchronous Generator Model is used ( generator_1axis ).","title":"Generator"},{"location":"SourceCode/component/#variables","text":"Generator Parameters ( x ) Xd : Synchronous Reactance around the d-axis \\(\\small (X_d)\\) . Xq : Synchronous Reactance around the q-axis \\(\\small (X_q)\\) . Xd_prime : Transient Synchronous Reactance around the d-axis \\(\\small (X'_d)\\) . T \uff1aTime constant of the field current around the d-axis \\(\\small (\\tau)\\) . M \uff1aInertia Coefficient \\(\\small (M)\\) . D \uff1aDamping Factor \\(\\small (D)\\) . Equilibrium State ( x_equilibrium ) Equilibrium point of the internal state of the generator delta \uff1aRotor declination angle \\(\\small (\\delta)\\) . omega \uff1aAngular frequency deviation \\(\\small (\\Delta \\omega)\\) . E \uff1aInternal voltage \\(\\small (E)\\) . x_avr \uff1aAutomatic Voltage Regulator (AVR) State. x_gov \uff1aGovernor State. x_pss \uff1aPower System Stabilizer (PSS) State. Equilibrium Voltage ( V_equilibrium ) Array containing the Equilibrium Voltage \\(\\small (V)\\) ([real part; imaginary part]). Equilibrium Current ( I_equilibrium ) Array containing the Equilibrium Current \\(\\small (I)\\) ([real part; imaginary part]). Automatic Voltage Regulator (AVR) Controller ( set_avr ) Ka \uff1aAVR Gain. Te \uff1aExciter Time Constant. Governor governor \uff1aInstance of the governor class. Power System Stabilizer ( set_pss ) Kpss : PSS Gain. Tpss : Washout Filter Time Constant. TL1p, TL1 : Phase Advance-Delay Time Constant of the First Stage. TL2p, TL2 : Phase Advance-Delay Time Constant of the Second Stage. omega0 \uff1aReference Angular Frequency (Grid's frequency \\(\\small (\\omega_0)\\) ).","title":"Variables"},{"location":"SourceCode/component/#methods","text":"obj = generator_1axis(omega, parameter) omega \uff1aReference Angular Frequency (Grid's frequency \\(\\small (\\omega_0)\\) ). parameter \uff1aGenerator parameters (see above).","title":"Methods"},{"location":"SourceCode/component/#load","text":"This child class implements a constant impedance load model ( load_impedance ).","title":"Load"},{"location":"SourceCode/component/#methods_1","text":"obj = load_impedance(varargin) Impedance values are determined from equilibrium voltage and equilibrium current; thus, no arguments are required.","title":"Methods"},{"location":"SourceCode/controller/","text":"Controller Class \u00b6 This page explains the variables and functions used in the controller class ( controller ). Contents: Controller Class Automatic Generation Control (AGC) Controller Class \u00b6 In GUILDA, the controllers are classified into two categories: local controllers and global controllers. Local Controller: A controller that is added locally to each device. Example: Retrofit controller. Global Controller: A controller for multiple devices. Example: Automatic Generation Control (AGC). Both of these controllers are defined as objects of the controller class. The difference is that the local controller includes the input value of the global controller as an argument. This can be seen in the code, for example with the method \"Controller State Derivative\" ( get_dx_u ), which is defined in the controller class, but it is called differently, depending on the controller type, as follows. Controller State Derivative - Local Controller [ dx , u ] = get_dx_u ( obj , t , x , X , V , I , u_global ) Controller State Derivative - Global Controller [ dx , u ] = get_dx_u ( obj , t , x , X , V , I , []) Variables \u00b6 idx_input : Busbar number to which the output signal of the controller (i.e., the input signal to the system) are applied. idx_observe : Busbar number observed by the controller. idx \uff1a idx_input and idx_observe as aligned vectors. get_dx_u_func : Anonymous functio that must be specified for each instance, for example get_dx_u for the predefined controllers in GUILDA. Required Methods \u00b6 Controller State Derivative This method is used to obtain the derivative of the controller state \\(\\small (x)\\) ; and the output signal \\((\\small u)\\) (i.e., the input signal to the system). Class Structure: [dx, u] = get_dx_u(obj, x, X, V, I, U_global) Note: The following notation is different to the ones used in other classes, e.g., Component class. Input Arguments x \uff1aController state \\(\\small (x)\\) . X \uff1aState of the Device connected to each bus \\(\\small (X)\\) . V \uff1aBusbar Voltage \\(\\small (V)\\) ([real part; imaginarty part]). I \uff1aBusbar Current \\(\\small (I)\\) ([real part; imaginarty part]). U_global \uff1a Input signals applied to each bus by the global controller \\(\\small (U)\\) . The controller model can only observe the above parameters. Therefore, even if there are other physical quantities required, they will have to be calculated on their own from the values of the arguments. Output Parameters dx \uff1aDertivative of the controller state \\(\\small (\\dot{x})\\) . u \uff1aOutput signal of the controller (i.e., input signal to the system) \\(\\small (u)\\) . Note: The controller class is commonly inherited by the global controller, retrofit controller, and other controllers. Therefore, when creating a distributed controller, it is necessary to explicitly write which signals may be referenced and which signals may not be referenced, in the derived class. It is not possible to reference the state of other controllers. If communication between controllers is required, they must be implemented as a single controller. Controller State Order This method is used to obtain the order (dimension) of the controller state. Class Structure: nx = get_nx(obj) Input Arguments None Output Parameters nx : Oder of the controller state. Recommended Methods \u00b6 The newly defined controller can be implemented without the following methods; however, these are necessary for performing analysis with an approximate linearization of the power system model. Approximate Linearization This method, as the name states, allows to linearize the power system model. It returns the system matrices \\(\\small [A, B, C, D, BV, DV, BI, DI, R, S]\\) of the linearized state-space representation as in the following equation. \\begin{align*} \\dot{x} &= A(x-x^*)+B(u-u^*)+B_V(V-V^*)+B_I(I-I^*)\uff0bRd\\\\ 0 &= C(x-x^*)+D(u-u^*)+D_V(V-V^*)+D_I(I-I^*)\\\\ z &= S(x^*-x) \\end{align*} Class Structure: [A, B, C, D, BV, DV, BI, DI, R, S] = get_linear_matrix(obj,x_st, Vst) Input Arguments x_st \uff1aEquilibrium point of the state variable. Vst \uff1aEquilibrium point of the voltage \\(-\\) obtained from the power flow calculation. Output Arguments [A, B, C, D, BV, DV, BI, DI, R, S] \uff1aSystem matrix of the state-space model shown above. R : Disturbance matrix. S : Output of the evaluation function. Note: Both R and S are needed when designing a control system; however, they are different from the properties of the device. Therefore, when simply performing a simulation without controller, it is safe to use R and S as zero matrices. Linear Controller State Derivation This method is used to obtain the derivative of the state \\(\\small (\\dot{x})\\) of the linearized controller, as well as its input \\(\\small (u)\\) , satisfying the following equation \\dot{x}=Ax+B_X (X-X^*)+B_V (V-V^*)+B_I (I-I^*)+B_u U_{global}\\\\ u=Cx+D_X (X-X^*)+D_V (V-V^*)+D_I (I-I^*)+D_u U_{global} Class Structure: [dx, u] = get_dx_u_linear(obj, t, x, X, V, U_global) Input Arguments t : Time \\(\\small (t)\\) . x \uff1aController state \\(\\small (x)\\) . X \uff1aState of the Device connected to each bus \\(\\small (X)\\) . V \uff1aBusbar Voltage \\(\\small (V)\\) ([real part; imaginarty part]). I \uff1aBusbar Current \\(\\small (I)\\) ([real part; imaginarty part]). U_global \uff1a Input signals applied to each bus by the global controller \\(\\small (U)\\) . The controller model can only observe the above parameters. Therefore, even if there are other physical quantities required, they will have to be calculated on their own from the values of the arguments. Output Parameters dx \uff1aDertivative of the controller state \\(\\small (\\dot{x})\\) . u \uff1aOutput signal of the controller (i.e., input signal to the system) \\(\\small (u)\\) . A \uff1aA matrix of controllers. BX \uff1aB matrix of the controller (regarding the stacked vector of bus states to be observed). BV \uff1aB matrix of the controller (regarding the stacked vector of voltages on all buses). BI \uff1aB matrix of the controller (regarding the stacked vector of currents on all buses). Bu \uff1aB matrix of the controller (regarding the stacked vector of input signals to all buses generated by the global controller). C \uff1aC matrix of controller. DX \uff1aD matrix of the controller (with respect to the bus state vector to be observed). DV \uff1aD matrix of the controller (regarding the stacked vector of voltages on all buses). DI \uff1aD matrix of the controller (regarding the stacked vector of currents on all buses). Du \uff1aD matrix of the controller (regarding the stacked vector of input signals to all buses generated by the global controller). Abstract Methods \u00b6 Linear Controller State Derivation ( [dx, u] = get_dx_u_linear(obj, t, x, X, V, U_global) ) This method is used to obtain the derivative of the state \\(\\small (\\dot{x})\\) of the linearized controller, as well as its input \\(\\small (u)\\) . Class Structure: [dx, u] = get_dx_u_linear(obj, t, x, X, V, U_global) Input Arguments t : Time \\(\\small (t)\\) . x \uff1aController state \\(\\small (x)\\) . X \uff1aState of the Device connected to each bus \\(\\small (X)\\) . V \uff1aBusbar Voltage \\(\\small (V)\\) ([real part; imaginarty part]). I \uff1aBusbar Current \\(\\small (I)\\) ([real part; imaginarty part]). U_global \uff1a Input signals applied to each bus by the global controller \\(\\small (U)\\) . The controller model can only observe the above parameters. Therefore, even if there are other physical quantities required, they will have to be calculated on their own from the values of the arguments. Output Parameters dx \uff1aDertivative of the controller state \\(\\small (\\dot{x})\\) . u \uff1aOutput signal of the controller (i.e., input signal to the system) \\(\\small (u)\\) . Automatic Generation Control (AGC) \u00b6 This child class implements a Broadcast Controller (PI Controller) class (i.e., controller_broadcast_PI_AGC ), which assumes that a 1-Axis Synchronous Generator Model (i.e., generator_1axis ) is used. Variables \u00b6 idx_observe : Busbar number observed by the controller. idx_input : Busbar number to which the output signal of the controller (i.e., the input signal to the system) are applied. net : Instance of the power network (i.e., the power system model) to which the controller will be added. Kp : Proportional gain of the controller. Ki : Integral gain of the controller. K_broadcast : Proportional gain for each generator (usually, all 1). Constructor Method \u00b6 AGC Controller ( obj = controller_broadcast_PI_AGC(net, y_idx, u_idx, Kp, Ki) ) Input Argument net : Instance of the power network (i.e., the power system model) to which the controller will be added. y_idx : The number of the busbar whose output is to be observed. u_idx : Number of the busbar to which the input is applied. Kp : Proportional gain of the controller. Ki : Integral gain of the controller.","title":"Controller Class"},{"location":"SourceCode/controller/#controller_class","text":"This page explains the variables and functions used in the controller class ( controller ). Contents: Controller Class Automatic Generation Control (AGC)","title":"Controller Class"},{"location":"SourceCode/controller/#controller_class_1","text":"In GUILDA, the controllers are classified into two categories: local controllers and global controllers. Local Controller: A controller that is added locally to each device. Example: Retrofit controller. Global Controller: A controller for multiple devices. Example: Automatic Generation Control (AGC). Both of these controllers are defined as objects of the controller class. The difference is that the local controller includes the input value of the global controller as an argument. This can be seen in the code, for example with the method \"Controller State Derivative\" ( get_dx_u ), which is defined in the controller class, but it is called differently, depending on the controller type, as follows. Controller State Derivative - Local Controller [ dx , u ] = get_dx_u ( obj , t , x , X , V , I , u_global ) Controller State Derivative - Global Controller [ dx , u ] = get_dx_u ( obj , t , x , X , V , I , [])","title":"Controller Class"},{"location":"SourceCode/controller/#variables","text":"idx_input : Busbar number to which the output signal of the controller (i.e., the input signal to the system) are applied. idx_observe : Busbar number observed by the controller. idx \uff1a idx_input and idx_observe as aligned vectors. get_dx_u_func : Anonymous functio that must be specified for each instance, for example get_dx_u for the predefined controllers in GUILDA.","title":"Variables"},{"location":"SourceCode/controller/#required_methods","text":"Controller State Derivative This method is used to obtain the derivative of the controller state \\(\\small (x)\\) ; and the output signal \\((\\small u)\\) (i.e., the input signal to the system). Class Structure: [dx, u] = get_dx_u(obj, x, X, V, I, U_global) Note: The following notation is different to the ones used in other classes, e.g., Component class. Input Arguments x \uff1aController state \\(\\small (x)\\) . X \uff1aState of the Device connected to each bus \\(\\small (X)\\) . V \uff1aBusbar Voltage \\(\\small (V)\\) ([real part; imaginarty part]). I \uff1aBusbar Current \\(\\small (I)\\) ([real part; imaginarty part]). U_global \uff1a Input signals applied to each bus by the global controller \\(\\small (U)\\) . The controller model can only observe the above parameters. Therefore, even if there are other physical quantities required, they will have to be calculated on their own from the values of the arguments. Output Parameters dx \uff1aDertivative of the controller state \\(\\small (\\dot{x})\\) . u \uff1aOutput signal of the controller (i.e., input signal to the system) \\(\\small (u)\\) . Note: The controller class is commonly inherited by the global controller, retrofit controller, and other controllers. Therefore, when creating a distributed controller, it is necessary to explicitly write which signals may be referenced and which signals may not be referenced, in the derived class. It is not possible to reference the state of other controllers. If communication between controllers is required, they must be implemented as a single controller. Controller State Order This method is used to obtain the order (dimension) of the controller state. Class Structure: nx = get_nx(obj) Input Arguments None Output Parameters nx : Oder of the controller state.","title":"Required Methods"},{"location":"SourceCode/controller/#recommended_methods","text":"The newly defined controller can be implemented without the following methods; however, these are necessary for performing analysis with an approximate linearization of the power system model. Approximate Linearization This method, as the name states, allows to linearize the power system model. It returns the system matrices \\(\\small [A, B, C, D, BV, DV, BI, DI, R, S]\\) of the linearized state-space representation as in the following equation. \\begin{align*} \\dot{x} &= A(x-x^*)+B(u-u^*)+B_V(V-V^*)+B_I(I-I^*)\uff0bRd\\\\ 0 &= C(x-x^*)+D(u-u^*)+D_V(V-V^*)+D_I(I-I^*)\\\\ z &= S(x^*-x) \\end{align*} Class Structure: [A, B, C, D, BV, DV, BI, DI, R, S] = get_linear_matrix(obj,x_st, Vst) Input Arguments x_st \uff1aEquilibrium point of the state variable. Vst \uff1aEquilibrium point of the voltage \\(-\\) obtained from the power flow calculation. Output Arguments [A, B, C, D, BV, DV, BI, DI, R, S] \uff1aSystem matrix of the state-space model shown above. R : Disturbance matrix. S : Output of the evaluation function. Note: Both R and S are needed when designing a control system; however, they are different from the properties of the device. Therefore, when simply performing a simulation without controller, it is safe to use R and S as zero matrices. Linear Controller State Derivation This method is used to obtain the derivative of the state \\(\\small (\\dot{x})\\) of the linearized controller, as well as its input \\(\\small (u)\\) , satisfying the following equation \\dot{x}=Ax+B_X (X-X^*)+B_V (V-V^*)+B_I (I-I^*)+B_u U_{global}\\\\ u=Cx+D_X (X-X^*)+D_V (V-V^*)+D_I (I-I^*)+D_u U_{global} Class Structure: [dx, u] = get_dx_u_linear(obj, t, x, X, V, U_global) Input Arguments t : Time \\(\\small (t)\\) . x \uff1aController state \\(\\small (x)\\) . X \uff1aState of the Device connected to each bus \\(\\small (X)\\) . V \uff1aBusbar Voltage \\(\\small (V)\\) ([real part; imaginarty part]). I \uff1aBusbar Current \\(\\small (I)\\) ([real part; imaginarty part]). U_global \uff1a Input signals applied to each bus by the global controller \\(\\small (U)\\) . The controller model can only observe the above parameters. Therefore, even if there are other physical quantities required, they will have to be calculated on their own from the values of the arguments. Output Parameters dx \uff1aDertivative of the controller state \\(\\small (\\dot{x})\\) . u \uff1aOutput signal of the controller (i.e., input signal to the system) \\(\\small (u)\\) . A \uff1aA matrix of controllers. BX \uff1aB matrix of the controller (regarding the stacked vector of bus states to be observed). BV \uff1aB matrix of the controller (regarding the stacked vector of voltages on all buses). BI \uff1aB matrix of the controller (regarding the stacked vector of currents on all buses). Bu \uff1aB matrix of the controller (regarding the stacked vector of input signals to all buses generated by the global controller). C \uff1aC matrix of controller. DX \uff1aD matrix of the controller (with respect to the bus state vector to be observed). DV \uff1aD matrix of the controller (regarding the stacked vector of voltages on all buses). DI \uff1aD matrix of the controller (regarding the stacked vector of currents on all buses). Du \uff1aD matrix of the controller (regarding the stacked vector of input signals to all buses generated by the global controller).","title":"Recommended Methods"},{"location":"SourceCode/controller/#abstract_methods","text":"Linear Controller State Derivation ( [dx, u] = get_dx_u_linear(obj, t, x, X, V, U_global) ) This method is used to obtain the derivative of the state \\(\\small (\\dot{x})\\) of the linearized controller, as well as its input \\(\\small (u)\\) . Class Structure: [dx, u] = get_dx_u_linear(obj, t, x, X, V, U_global) Input Arguments t : Time \\(\\small (t)\\) . x \uff1aController state \\(\\small (x)\\) . X \uff1aState of the Device connected to each bus \\(\\small (X)\\) . V \uff1aBusbar Voltage \\(\\small (V)\\) ([real part; imaginarty part]). I \uff1aBusbar Current \\(\\small (I)\\) ([real part; imaginarty part]). U_global \uff1a Input signals applied to each bus by the global controller \\(\\small (U)\\) . The controller model can only observe the above parameters. Therefore, even if there are other physical quantities required, they will have to be calculated on their own from the values of the arguments. Output Parameters dx \uff1aDertivative of the controller state \\(\\small (\\dot{x})\\) . u \uff1aOutput signal of the controller (i.e., input signal to the system) \\(\\small (u)\\) .","title":"Abstract Methods"},{"location":"SourceCode/controller/#automatic_generation_control_agc","text":"This child class implements a Broadcast Controller (PI Controller) class (i.e., controller_broadcast_PI_AGC ), which assumes that a 1-Axis Synchronous Generator Model (i.e., generator_1axis ) is used.","title":"Automatic Generation Control (AGC)"},{"location":"SourceCode/controller/#variables_1","text":"idx_observe : Busbar number observed by the controller. idx_input : Busbar number to which the output signal of the controller (i.e., the input signal to the system) are applied. net : Instance of the power network (i.e., the power system model) to which the controller will be added. Kp : Proportional gain of the controller. Ki : Integral gain of the controller. K_broadcast : Proportional gain for each generator (usually, all 1).","title":"Variables"},{"location":"SourceCode/controller/#constructor_method","text":"AGC Controller ( obj = controller_broadcast_PI_AGC(net, y_idx, u_idx, Kp, Ki) ) Input Argument net : Instance of the power network (i.e., the power system model) to which the controller will be added. y_idx : The number of the busbar whose output is to be observed. u_idx : Number of the busbar to which the input is applied. Kp : Proportional gain of the controller. Ki : Integral gain of the controller.","title":"Constructor Method"},{"location":"SourceCode/power_network/","text":"Power Network Class \u00b6 This page explains the variables and functions used in the power network class ( power_network ), as well as one detailed example to better understand those variables and functions in an actual power system model. Contents: Power Network Class. Variables. Functions. 3-Bus Sample Model. IEEE 68-Bus Model. Power Network Class - Properties. Power Network Class \u00b6 This is one of the five main classes in GUILDA. From this class ( power_network ), all the power system models are derived. Variables \u00b6 x_equilibrium \uff1aArray containing the internal state of a generator. The internal state of each generator is composed of seven variables: 1. Rotor Declination Angle \\(\\small (\\delta)\\) , 2. Angular Frequency Deviation \\(\\small (\\Delta \\omega)\\) , 3. Internal Voltage \\(\\small (E)\\) , 4. Automatic Voltage Regulator (AVR) Variable, and 5-7. Power System Stabilizer (PSS) Variables. V_equilibrium \uff1aArray containing the Equilibrium Voltage \\(\\small (V)\\) ([real part; imaginary part]) for each busbar. I_equilibrium \uff1aArray containing the Equilibrium Current \\(\\small (I)\\) ([real part; imaginary part]) for each busbar. a_bus \uff1aArray containing all the busbar information. The information on the i-th busbar is stored in the i-th element and can be obtained in the form of a structure like power_network.a_bus{5}.V_equilibrium to get the equilibrium point of the voltage on the 5-th bus bar. a_controller_global \uff1aArray containing the Global Controller information. a_controller_local \uff1aArray containing the Local Controller information. a_branch \uff1aArray containing the branches infromation. Functions \u00b6 Simulate ( simulate ) Function to simulate the system and output the results. Class Structure: out = simulate(obj, t, varargin) Input Arguments t = [start, end] : Time \\(\\small (t)\\) . u : Input signal to the bus \\(\\small (u)\\) . \\(\\star\\) idx_u : Target bus for the input signal. \\(\\star\\) options : Struture-type variable that contains the information of the simulation conditions, such as linear \uff1aSets if the simulation is linear (i.e., true ) or nonlinear (i.e., false ). fault \uff1aSets the ground fault conditions in the form of {[start time, end time], target busbar} . x0_sys \uff1aSets the initial value conditions of the state as a cell array per bus or as a vector with all buses stacked. V0 \uff1aSets the initial busbar voltage as a cell array per bus or as a vector with all buses stacked. I0 \uff1aSets the initial busbar current as a cell array per bus or as a vector with all buses stacked. X0_con_local \uff1aSets the initial busbar local controller value as a cell array per bus or as a vector with all buses stacked. x0_con_global \uff1aSets the initial busbar global controller value as a cell array per bus or as a vector with all buses stacked. rest_time \uff1aForced termination time for the ODE15S Solver. do_retry \uff1a Sets if, once the forced termination time is reached, retry (i.e., true ) or not (i.e., false ) the numerical integration. \\(\\star\\) The input signal ( u ) and it's target bus ( idx_u ) are optional arguments. When used, they must be entered immediately after the time ( t ) argument. Output Parameters ( out ) Structure containing time response data of the system, composed of the following parameters t \uff1aTime \\(\\small (t)\\) as an array containing the \"number of samplings\". X \uff1aResponse data of the state of the generators connected to each busbar as an array with \"number of samplings\" \u2715 \"number of device states\". V \uff1aBusbar voltage as an array with \"number of samplings\" \u2715 2 (Real Part, Imaginary Part). I \uff1aBusbar current as an array with \"number of samplings\" \u2715 2 (Real Part, Imaginary Part). fault_bus \uff1aFor each segment of the analysis, this field stores the cell array classification of the index of the busbar where the ground fault occurs. \\(\\star \\star\\) U_global \uff1aContains the response of the input value from the global controller as an array \"Input Ports of the Generator\" \u2715 \"Number of Generators\". U \uff1aContains the response of the input value from the local controller as an array \"Input Ports of the Generator\" \u2715 \"Number of Generators\". sols \uff1aFor each segment of the analysis: This field stores in an array the solvers running in each segment. \\(\\star \\star\\) \\(\\star \\star\\) For more information on what \"for each segment of the analysis\" means, as well as more information on the simulate class, plese refer to the dedicated section Simulating . Add Local Controller ( add_controller_local ) Function to add a local controller to the system. Class Structure: add_controller_local(obj, controller) Input Arguments controller : An already defined controller (i.e., instance of the controller class). Note that, if a controller has already been added to the specified busbar, delete the previous one before adding. Output Parameters None Add Global Controller ( add_controller_global ) Function to add a global controller to the system. Class Structure: add_controller_global(obj, controller) Input Arguments controller : An already defined controller (i.e., instance of the controller class). Note that, if a controller has already been added to the specified busbar, delete the previous one before adding. Output Parameters None Remove Local Controller ( remove_controller_local ) Function to delete a local controller from the system. Class Structure: remove_controller_local(obj, idx) Input Arguments idx : Busbar with the controller to be removed. Output Parameters None Remove Global Controller ( remove_controller_global ) Function to delete a global controller from the system. Class Structure: remove_controller_global(obj, idx) Input Arguments idx : Busbar with the controller to be removed. Output Parameters None Note: For more information on the controller class related functions, please refer to the dedicated section Controllers . 3-Bus Sample Model \u00b6 The 3-bus system model is the one used in the Guided Example , which is also covered in the reference text . For a detailed explanation, please refer to the mentioned materials. The model is composed of 3 busbars. 2 generators (busbar 1 and busbar 2). 1 load (busbar 3). IEEE 68-Bus Model \u00b6 The IEEE 68-Bus 16-Machine System Model is already implemented in GUILDA derived from the power_network class. For more information on it refer to the book Robust Control in Power Systems . In this model, the Synchronous Generator is modelled by the 1-Axis model (i.e., generator_1axis class) and the Loads are modelled by Constant Impedance Model (i.e., load_impedance class). Power Network Class - Properties \u00b6 In GUILDA, the power system model is defined as a variable of the class power_network . The purpose of this section is to provide an imagine of what kind of power system model is implemented by looking at the values of the properties of this power_network class (Click on the Illustration \u2193).","title":"Power Network Class"},{"location":"SourceCode/power_network/#power_network_class","text":"This page explains the variables and functions used in the power network class ( power_network ), as well as one detailed example to better understand those variables and functions in an actual power system model. Contents: Power Network Class. Variables. Functions. 3-Bus Sample Model. IEEE 68-Bus Model. Power Network Class - Properties.","title":"Power Network Class"},{"location":"SourceCode/power_network/#power_network_class_1","text":"This is one of the five main classes in GUILDA. From this class ( power_network ), all the power system models are derived.","title":"Power Network Class"},{"location":"SourceCode/power_network/#variables","text":"x_equilibrium \uff1aArray containing the internal state of a generator. The internal state of each generator is composed of seven variables: 1. Rotor Declination Angle \\(\\small (\\delta)\\) , 2. Angular Frequency Deviation \\(\\small (\\Delta \\omega)\\) , 3. Internal Voltage \\(\\small (E)\\) , 4. Automatic Voltage Regulator (AVR) Variable, and 5-7. Power System Stabilizer (PSS) Variables. V_equilibrium \uff1aArray containing the Equilibrium Voltage \\(\\small (V)\\) ([real part; imaginary part]) for each busbar. I_equilibrium \uff1aArray containing the Equilibrium Current \\(\\small (I)\\) ([real part; imaginary part]) for each busbar. a_bus \uff1aArray containing all the busbar information. The information on the i-th busbar is stored in the i-th element and can be obtained in the form of a structure like power_network.a_bus{5}.V_equilibrium to get the equilibrium point of the voltage on the 5-th bus bar. a_controller_global \uff1aArray containing the Global Controller information. a_controller_local \uff1aArray containing the Local Controller information. a_branch \uff1aArray containing the branches infromation.","title":"Variables"},{"location":"SourceCode/power_network/#functions","text":"Simulate ( simulate ) Function to simulate the system and output the results. Class Structure: out = simulate(obj, t, varargin) Input Arguments t = [start, end] : Time \\(\\small (t)\\) . u : Input signal to the bus \\(\\small (u)\\) . \\(\\star\\) idx_u : Target bus for the input signal. \\(\\star\\) options : Struture-type variable that contains the information of the simulation conditions, such as linear \uff1aSets if the simulation is linear (i.e., true ) or nonlinear (i.e., false ). fault \uff1aSets the ground fault conditions in the form of {[start time, end time], target busbar} . x0_sys \uff1aSets the initial value conditions of the state as a cell array per bus or as a vector with all buses stacked. V0 \uff1aSets the initial busbar voltage as a cell array per bus or as a vector with all buses stacked. I0 \uff1aSets the initial busbar current as a cell array per bus or as a vector with all buses stacked. X0_con_local \uff1aSets the initial busbar local controller value as a cell array per bus or as a vector with all buses stacked. x0_con_global \uff1aSets the initial busbar global controller value as a cell array per bus or as a vector with all buses stacked. rest_time \uff1aForced termination time for the ODE15S Solver. do_retry \uff1a Sets if, once the forced termination time is reached, retry (i.e., true ) or not (i.e., false ) the numerical integration. \\(\\star\\) The input signal ( u ) and it's target bus ( idx_u ) are optional arguments. When used, they must be entered immediately after the time ( t ) argument. Output Parameters ( out ) Structure containing time response data of the system, composed of the following parameters t \uff1aTime \\(\\small (t)\\) as an array containing the \"number of samplings\". X \uff1aResponse data of the state of the generators connected to each busbar as an array with \"number of samplings\" \u2715 \"number of device states\". V \uff1aBusbar voltage as an array with \"number of samplings\" \u2715 2 (Real Part, Imaginary Part). I \uff1aBusbar current as an array with \"number of samplings\" \u2715 2 (Real Part, Imaginary Part). fault_bus \uff1aFor each segment of the analysis, this field stores the cell array classification of the index of the busbar where the ground fault occurs. \\(\\star \\star\\) U_global \uff1aContains the response of the input value from the global controller as an array \"Input Ports of the Generator\" \u2715 \"Number of Generators\". U \uff1aContains the response of the input value from the local controller as an array \"Input Ports of the Generator\" \u2715 \"Number of Generators\". sols \uff1aFor each segment of the analysis: This field stores in an array the solvers running in each segment. \\(\\star \\star\\) \\(\\star \\star\\) For more information on what \"for each segment of the analysis\" means, as well as more information on the simulate class, plese refer to the dedicated section Simulating . Add Local Controller ( add_controller_local ) Function to add a local controller to the system. Class Structure: add_controller_local(obj, controller) Input Arguments controller : An already defined controller (i.e., instance of the controller class). Note that, if a controller has already been added to the specified busbar, delete the previous one before adding. Output Parameters None Add Global Controller ( add_controller_global ) Function to add a global controller to the system. Class Structure: add_controller_global(obj, controller) Input Arguments controller : An already defined controller (i.e., instance of the controller class). Note that, if a controller has already been added to the specified busbar, delete the previous one before adding. Output Parameters None Remove Local Controller ( remove_controller_local ) Function to delete a local controller from the system. Class Structure: remove_controller_local(obj, idx) Input Arguments idx : Busbar with the controller to be removed. Output Parameters None Remove Global Controller ( remove_controller_global ) Function to delete a global controller from the system. Class Structure: remove_controller_global(obj, idx) Input Arguments idx : Busbar with the controller to be removed. Output Parameters None Note: For more information on the controller class related functions, please refer to the dedicated section Controllers .","title":"Functions"},{"location":"SourceCode/power_network/#3-bus_sample_model","text":"The 3-bus system model is the one used in the Guided Example , which is also covered in the reference text . For a detailed explanation, please refer to the mentioned materials. The model is composed of 3 busbars. 2 generators (busbar 1 and busbar 2). 1 load (busbar 3).","title":"3-Bus Sample Model"},{"location":"SourceCode/power_network/#ieee_68-bus_model","text":"The IEEE 68-Bus 16-Machine System Model is already implemented in GUILDA derived from the power_network class. For more information on it refer to the book Robust Control in Power Systems . In this model, the Synchronous Generator is modelled by the 1-Axis model (i.e., generator_1axis class) and the Loads are modelled by Constant Impedance Model (i.e., load_impedance class).","title":"IEEE 68-Bus Model"},{"location":"SourceCode/power_network/#power_network_class_-_properties","text":"In GUILDA, the power system model is defined as a variable of the class power_network . The purpose of this section is to provide an imagine of what kind of power system model is implemented by looking at the values of the properties of this power_network class (Click on the Illustration \u2193).","title":"Power Network Class - Properties"},{"location":"aboutPowerSystem/0TopPage/","text":"Power System Model (Simple) \u00b6 This page provides a brief description of the Power System Model configuration and its components. Contents: Electric Power Systems Busbar Branch Components Types of Components Obtaining a Power System Model Electric Power Systems \u00b6 Before we start to simulate, we would like to introduce the configuration of the power system models handled by this simulator. We will use the IEEE 68-bus model already implemented in GUILDA as an example. IEEE 68-bus Model This model is composed of 68 busbars (Bus in figure). 16 generators (Gen in the figure). 35 loads (\u25bc in the figure). And branches connecting each busbar (lines connecting busbars). The components are brifly explained one-by-one in the following segments. Busbar \u00b6 The busbar is the interconnection point (like a relay) between generators, loads, and the power grid. The power flow calculation, which determines the supply-demand balance of electricity, considers the Active Power \\(\\small (P)\\) and Reactive Power \\(\\small (Q)\\) sent from and to the busbars, as well as the Voltage Magnitude \\(\\small (|V|)\\) , and Phase Angle \\(\\small (\\angle V)\\) at each bus bar to derive the parameters to achieve the desired supply-demand balance. Branch \u00b6 It is a power transmission line between busbars. It corresponds to electric wires in the real world. Components \u00b6 As the name implies, a component is a piece of equipment, such as generators or loads. In GUILDA, these devices are defined in a class called component , thus the term \"component\" is used here. If you refer to the code, you will see that the load and generator classes are defined as child classes of the component class. Types of Components \u00b6 Generator (PV bus): Generator buses are generally classified as PV buses, since they are defined by the active power \\(\\small (P)\\) and the voltage magnitude \\(\\small (V)\\) . Generator (Slack bus): It is a special type of bus, as only one of the generators in the model is specified as a \"slack bus\". The main difference is that it is specified by the voltage magnitude \\(\\small (\\lvert V \\rvert)\\) and the voltage phase angle \\(\\small (\\angle V)\\) . This is necessary because the voltage phase difference between the busbars can generally be obtained, but the voltage phase of each busbar is not uniquely determined. Therefore, specifying the voltage phase angle of one busbar allows to uniquely determine the voltage phase angle of the rest of busbars. Additionally, if multiple slack buses are defined, it may happen that no solution satisfies all the specified parameters. This is why there is only one slack bus for all matrices. Load (PQ bus): Load buses are classified as PQ buses, since they are defined by the active power \\(\\small (P)\\) and reactive power \\(\\small (Q)\\) . Non-unit busbar (PQ bus): These are busbars with no load added. They serve as interconnection points between transmission lines. However, they are also classified as PQ buses, since they can be regarded as load busbars with an infinite load. Remember that the power flow calculation considers four parameters per busbar: Active Power \\(\\small (P)\\) , Reactive Power \\(\\small (Q)\\) , Voltage Magnitude \\(\\small (\\lvert V \\rvert)\\) , and Phase Angle \\(\\small (\\angle V)\\) . Thus, a total of \\(4 n\\) parameters for a power network consisting of \\(n\\) busbars. Naturally, if some of these parameters are not specified, the others will not be uniquely determined. Therefore, we specify some of the 4 parameters for each bus bar, according to its type (i.e., PV bus, Slack bus, PQ bus). Obtaining a Power System Model \u00b6 When modeling a power system, two main types of systems are considered: Algebraic Equation Model defined by the transmission lines. Differential Algebraic Equation Model that is formed between each busbar and the component. The entire power system model works as a single system with changing dynamics, since the components connected to each busbar also have dynamic characteristics that affect each other as they are interconnected by the algebraic equations of the network.","title":"Power System Model (Simple)"},{"location":"aboutPowerSystem/0TopPage/#power_system_model_simple","text":"This page provides a brief description of the Power System Model configuration and its components. Contents: Electric Power Systems Busbar Branch Components Types of Components Obtaining a Power System Model","title":"Power System Model (Simple)"},{"location":"aboutPowerSystem/0TopPage/#electric_power_systems","text":"Before we start to simulate, we would like to introduce the configuration of the power system models handled by this simulator. We will use the IEEE 68-bus model already implemented in GUILDA as an example. IEEE 68-bus Model This model is composed of 68 busbars (Bus in figure). 16 generators (Gen in the figure). 35 loads (\u25bc in the figure). And branches connecting each busbar (lines connecting busbars). The components are brifly explained one-by-one in the following segments.","title":"Electric Power Systems"},{"location":"aboutPowerSystem/0TopPage/#busbar","text":"The busbar is the interconnection point (like a relay) between generators, loads, and the power grid. The power flow calculation, which determines the supply-demand balance of electricity, considers the Active Power \\(\\small (P)\\) and Reactive Power \\(\\small (Q)\\) sent from and to the busbars, as well as the Voltage Magnitude \\(\\small (|V|)\\) , and Phase Angle \\(\\small (\\angle V)\\) at each bus bar to derive the parameters to achieve the desired supply-demand balance.","title":"Busbar"},{"location":"aboutPowerSystem/0TopPage/#branch","text":"It is a power transmission line between busbars. It corresponds to electric wires in the real world.","title":"Branch"},{"location":"aboutPowerSystem/0TopPage/#components","text":"As the name implies, a component is a piece of equipment, such as generators or loads. In GUILDA, these devices are defined in a class called component , thus the term \"component\" is used here. If you refer to the code, you will see that the load and generator classes are defined as child classes of the component class.","title":"Components"},{"location":"aboutPowerSystem/0TopPage/#types_of_components","text":"Generator (PV bus): Generator buses are generally classified as PV buses, since they are defined by the active power \\(\\small (P)\\) and the voltage magnitude \\(\\small (V)\\) . Generator (Slack bus): It is a special type of bus, as only one of the generators in the model is specified as a \"slack bus\". The main difference is that it is specified by the voltage magnitude \\(\\small (\\lvert V \\rvert)\\) and the voltage phase angle \\(\\small (\\angle V)\\) . This is necessary because the voltage phase difference between the busbars can generally be obtained, but the voltage phase of each busbar is not uniquely determined. Therefore, specifying the voltage phase angle of one busbar allows to uniquely determine the voltage phase angle of the rest of busbars. Additionally, if multiple slack buses are defined, it may happen that no solution satisfies all the specified parameters. This is why there is only one slack bus for all matrices. Load (PQ bus): Load buses are classified as PQ buses, since they are defined by the active power \\(\\small (P)\\) and reactive power \\(\\small (Q)\\) . Non-unit busbar (PQ bus): These are busbars with no load added. They serve as interconnection points between transmission lines. However, they are also classified as PQ buses, since they can be regarded as load busbars with an infinite load. Remember that the power flow calculation considers four parameters per busbar: Active Power \\(\\small (P)\\) , Reactive Power \\(\\small (Q)\\) , Voltage Magnitude \\(\\small (\\lvert V \\rvert)\\) , and Phase Angle \\(\\small (\\angle V)\\) . Thus, a total of \\(4 n\\) parameters for a power network consisting of \\(n\\) busbars. Naturally, if some of these parameters are not specified, the others will not be uniquely determined. Therefore, we specify some of the 4 parameters for each bus bar, according to its type (i.e., PV bus, Slack bus, PQ bus).","title":"Types of Components"},{"location":"aboutPowerSystem/0TopPage/#obtaining_a_power_system_model","text":"When modeling a power system, two main types of systems are considered: Algebraic Equation Model defined by the transmission lines. Differential Algebraic Equation Model that is formed between each busbar and the component. The entire power system model works as a single system with changing dynamics, since the components connected to each busbar also have dynamic characteristics that affect each other as they are interconnected by the algebraic equations of the network.","title":"Obtaining a Power System Model"}]}